<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <script type="text/javascript" src="/js/logo.js"></script>
  <script type="text/javascript" src="/js/force-autoplay.js"></script>
  <script type="text/javascript" src="/js/contextmenu.js"></script>
  <script type="text/javascript" src="/js/click-effect.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#007FFF"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/img/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.png">
  <link rel="mask-icon" href="/img/favicon.png" color="#007FFF">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-center-atom.css">
  <script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"republicengineeringstudent.gitee.io","root":"/","images":"/img","scheme":"Pisces","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#FFFFFF","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="https://republicengineeringstudent.gitee.io/2022/04/30/ES6-ES11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://republicengineeringstudent.gitee.io/2022/04/30/ES6-ES11/","path":"2022/04/30/ES6-ES11/","title":"JavaScript ES6~ES11"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaScript ES6~ES11 | 形而上的坏死，形而下的凋亡</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <meta name="msvalidate.01" content="2DC98D673CEA63668E0E0390B0D5A92E" />
  <meta name="google-site-verification" content="1oFThEwTKR5SObaIdOL2PxGLwX-rE5ClaZKSAdhq3LY" />
  <meta name="google-site-verification" content="a7h6HxqLG_MHyjCraHg6yzJYNk3na2UIjP7AcWOrg_E" />
  <meta name="baidu-site-verification" content="code-PFGV5jFemX" />
  <meta name="baidu-site-verification" content="code-Z4QAODNN82" />
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">形而上的坏死，形而下的凋亡</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">共和国工科生的博客</p>
      <img class="custom-logo-image" src="/img/logo.png" alt="形而上的坏死，形而下的凋亡">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">20</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">39</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <link rel="stylesheet" type="text/css" href="/css/aplayer.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/js/aplayer.js"></script>
  <script type="text/javascript" src="/js/music.js"></script>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81ES6%E6%A0%87%E5%87%86"><span class="nav-text">二、ES6标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-let"><span class="nav-text">(1) let</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%A6%81%E6%AD%A2%E4%BA%8C%E6%AC%A1%E5%A3%B0%E6%98%8E"><span class="nav-text">1. 禁止二次声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">2. 块级作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%97%A0%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-text">3. 无变量提升</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-const"><span class="nav-text">(2) const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%A7%A3%E6%9E%84"><span class="nav-text">(3) 解构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">(4) 模板字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">(5) lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0"><span class="nav-text">(6) 可变长度参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">(7) 扩展运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Symbol%E7%B1%BB%E5%9E%8B"><span class="nav-text">(8) Symbol类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%89%B9%E6%80%A7"><span class="nav-text">1. 特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-for-%E6%96%B9%E6%B3%95"><span class="nav-text">2. for()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">3. iterator迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A0-%E9%BB%98%E8%AE%A4%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">Ⅰ. 默认的迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%85%A1-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">Ⅱ. 自定义迭代器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">(9) 生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Promise"><span class="nav-text">(10) Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">(11) 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="nav-text">1. Set（集合）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Map%EF%BC%88%E6%98%A0%E5%B0%84%EF%BC%89"><span class="nav-text">2. Map（映射）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-class%EF%BC%88%E7%B1%BB%EF%BC%89"><span class="nav-text">(12) class（类）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="nav-text">1. 定义类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">2. 静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BB%A7%E6%89%BF"><span class="nav-text">3. 继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-text">4. 重写父类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-getter%E4%B8%8Esetter"><span class="nav-text">5. getter与setter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-text">(13) 类的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%95%B0%E5%80%BC%E4%B8%8E%E8%BF%90%E7%AE%97%E6%89%A9%E5%B1%95"><span class="nav-text">1. 数值与运算扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-text">2. 对象的扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-text">(14) 模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%9B%B4%E6%8E%A5%E6%9A%B4%E9%9C%B2"><span class="nav-text">1. 直接暴露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BB%9F%E4%B8%80%E6%9A%B4%E9%9C%B2"><span class="nav-text">2. 统一暴露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%BB%98%E8%AE%A4%E6%9A%B4%E9%9C%B2"><span class="nav-text">3. 默认暴露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%80%9A%E7%94%A8%E5%BC%95%E5%85%A5"><span class="nav-text">4. 通用引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%A7%A3%E6%9E%84%E5%BC%95%E5%85%A5"><span class="nav-text">5. 解构引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-default%E5%BC%95%E5%85%A5"><span class="nav-text">6. default引入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81ES7%E6%A0%87%E5%87%86"><span class="nav-text">三、ES7标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-includes"><span class="nav-text">(1) includes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%AC%A1%E6%96%B9%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">(2) 次方运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81ES8%E6%A0%87%E5%87%86"><span class="nav-text">四、ES8标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-async%E4%B8%8Eawait"><span class="nav-text">(1) async与await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95-1"><span class="nav-text">(2) 对象的扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81ES9%E6%A0%87%E5%87%86"><span class="nav-text">五、ES9标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-text">(1) 扩展运算符的扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%A9%E5%B1%95"><span class="nav-text">(2) 正则表达式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8D%95%E8%8E%B7%E5%88%86%E7%BB%84%E5%91%BD%E5%90%8D"><span class="nav-text">1. 捕获分组命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%8D%E5%90%91%E6%96%AD%E8%A8%80"><span class="nav-text">2. 反向断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%85%A8%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="nav-text">3. .全匹配模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81ES10%E6%A0%87%E5%87%86"><span class="nav-text">六、ES10标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81ES11%E6%A0%87%E5%87%86"><span class="nav-text">七、ES11标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-text">(1) 私有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-matchAll"><span class="nav-text">(2) matchAll()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%AF%E9%80%89%E9%93%BE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">(3) 可选链操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5"><span class="nav-text">(4) 动态引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-BigInt"><span class="nav-text">(5) BigInt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BB%9D%E5%AF%B9%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="nav-text">(6) 绝对全局对象</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="共和国工科生"
      src="/img/avatar.png">
  <p class="site-author-name" itemprop="name">共和国工科生</p>
  <div class="site-description" itemprop="description">二次元，多语言许可(中/あ/Eng)，程序员，社科趣味，东四区作息</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Ayanami-Daisuki" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Ayanami-Daisuki" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/RepublicEngineeringStudent" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;RepublicEngineeringStudent" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="/engineeringstudent@qq.com" title="E-Mail → engineeringstudent@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/lib/@creativecommons/vocabulary/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      学习资料
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://docs.microsoft.com/zh-cn/dotnet/" title="https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;dotnet&#x2F;" rel="noopener" target="_blank">.NET</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://scisharp.github.io/SciSharp/" title="https:&#x2F;&#x2F;scisharp.github.io&#x2F;SciSharp&#x2F;" rel="noopener" target="_blank">SciSharp</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://jquery.cuishifeng.cn/" title="https:&#x2F;&#x2F;jquery.cuishifeng.cn&#x2F;" rel="noopener" target="_blank">jQuery</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://v3.cn.vuejs.org/api/" title="https:&#x2F;&#x2F;v3.cn.vuejs.org&#x2F;api&#x2F;" rel="noopener" target="_blank">VUE</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.electronjs.org/docs/latest/api/app" title="https:&#x2F;&#x2F;www.electronjs.org&#x2F;docs&#x2F;latest&#x2F;api&#x2F;app" rel="noopener" target="_blank">Electron</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://republicengineeringstudent.gitee.io/2022/04/30/ES6-ES11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/avatar.png">
      <meta itemprop="name" content="共和国工科生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="形而上的坏死，形而下的凋亡">
      <meta itemprop="description" content="二次元，多语言许可(中/あ/Eng)，程序员，社科趣味，东四区作息">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JavaScript ES6~ES11 | 形而上的坏死，形而下的凋亡">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript ES6~ES11
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-30 16:50:16" itemprop="dateCreated datePublished" datetime="2022-04-30T16:50:16+08:00">2022-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-03 17:30:15" itemprop="dateModified" datetime="2022-05-03T17:30:15+08:00">2022-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>25k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <img src="/2022/04/30/ES6-ES11/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要JavaScript基础。</div>
</div>

<span id="more"></span>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p>JavaScript最初设计出来的时候并没有像现在这样强大的功能。随着互联网的发展，JavaScript渐渐追加更多更强大的功能。目前JavaScript使用最广泛的标准是ES5，但每年JavaScript都会发布新的标准，截至本文开始编写时，已经到了ES13标准。因此有必要学习一下新的JavaScript标准。</p>
<p>所有的标准都是向前兼容的，因此不必担心已学的JavaScript语法在新版本下会失效。</p>
<h2 id="二、ES6标准"><a href="#二、ES6标准" class="headerlink" title="二、ES6标准"></a><strong>二、ES6标准</strong></h2><p>ES6标准的改动相对较多。</p>
<h3 id="1-let"><a href="#1-let" class="headerlink" title="(1) let"></a><strong>(1) <code>let</code></strong></h3><p>在ES6标准下，声明变量推荐使用<code>let</code>而不要使用<code>var</code> 。</p>
<h4 id="1-禁止二次声明"><a href="#1-禁止二次声明" class="headerlink" title="1. 禁止二次声明"></a><strong>1. 禁止二次声明</strong></h4><p>使用<code>var</code>声明的变量，允许被重复声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;114514&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114514</span><br></pre></td></tr></table></figure>

<p>使用<code>var</code>声明同名变量时，后者会覆盖前者。这可能会导致令人疑惑的错误。而当使用<code>let</code>声明变量时，支持ES6的解释器将直接抛出异常：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">D:\Files\Documents\Visual Studio Code\JavaScript\Hello.js:2</span><br><span class="line">let a = &quot;114514&quot;</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></pre></td></tr></table></figure>

<p>解释器不仅会直接抛出异常，还会指明引发错误的原因。不妨想想一下，使用<code>var</code>声明的变量，在绑定了一堆事件后，却因为命名空间污染导致被覆盖，因而无法实现程序员想要的网页效果，程序员打开控制台却一个异常也没有抛出的这种绝望感。如果不想体验这种绝望，请使用<code>let</code>或<code>const</code>来声明变量。</p>
<h4 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2. 块级作用域"></a><strong>2. 块级作用域</strong></h4><p>使用<code>let</code>声明的变量，只会在其所在的<code>&#123;&#125;</code>内生效，而使用<code>var</code>声明的变量，则将在<code>&#123;&#125;</code>外部也能生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不止 for，只要有 &#123;&#125; 就会出现下述情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">b = 114514</span><br></pre></td></tr></table></figure>

<p>上述代码的变量若使用<code>let</code>进行声明，将会抛出异常，因为在<code>&#123;&#125;</code>内的变量<code>b</code>将不会被外部获取到，因此将会抛出<code>b</code>未定义的异常。</p>
<p>请注意，块级作用域的限制只限制了不能向<code>&#123;&#125;</code>内寻找变量，它并不影响向<code>&#123;&#125;</code>的外部寻找变量。即，不影响作用域链，“全局变量可以在函数内生效” 。</p>
<h4 id="3-无变量提升"><a href="#3-无变量提升" class="headerlink" title="3. 无变量提升"></a><strong>3. 无变量提升</strong></h4><p>使用<code>var</code>定义变量时，解释器会预先定义所有变量，等执行到真实的初始化位置时再进行赋值。因此可以在该变量真实声明处之前获取到该变量，虽然其值是<code>undefined</code> 。</p>
<p>而使用<code>let</code>声明的变量，则不允许在其被声明之前使用该变量，否则将抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);     <span class="comment">// 将会抛出异常</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1919810</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);     <span class="comment">// 将会输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">114514</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-const"><a href="#2-const" class="headerlink" title="(2) const"></a><strong>(2) <code>const</code></strong></h3><p><code>const</code>与<code>let</code>有相似之处，它们都是符合块级作用域的。但<code>const</code>声明的变量必须在其声明处被初始化，并且不允许修改其在栈中的值。</p>
<p>对象在栈中的值都是一个指向堆的地址，因此可以使用<code>const</code>来声明对象，这样既可以修改对象的内容，又可以避免错误赋值导致指向的对象改变。</p>
<h3 id="3-解构"><a href="#3-解构" class="headerlink" title="(3) 解构"></a><strong>(3) 解构</strong></h3><p>类似于Python和C#的拆包。ES6标准允许JavaScript进行 “拆包” 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构数组</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Lacia&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = list</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构对象</span></span><br><span class="line"><span class="keyword">let</span> object = &#123; <span class="title class_">Kouka</span>: <span class="number">14</span>, <span class="title class_">Method</span>: <span class="number">16</span>, <span class="title class_">Lacia</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="title class_">Lacia</span> &#125; = object;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lacia =&quot;</span>, <span class="title class_">Lacia</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; node Hello.js</span><br><span class="line">a = Kouka</span><br><span class="line">b = Method</span><br><span class="line">c = Lacia</span><br><span class="line">Lacia = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>对象的解构可以按需取出，而数组则只能根据下标顺序依次取出。并且，函数在书写形参的时候，也可以使用解构。</p>
<h3 id="4-模板字符串"><a href="#4-模板字符串" class="headerlink" title="(4) 模板字符串"></a><strong>(4) 模板字符串</strong></h3><p>模板字符串与一般字符串不同，一般字符串是使用<code>""</code>或<code>''</code>括住，而模板字符串使用<code>``</code>（反引号）。</p>
<p>在一般的字符串不允许出现换行符，要想加入换行符必须使用转义字符<code>\n</code> ，而模板字符串中允许直接输入换行符。另外，模板字符串允许使用插值语法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Name</span> = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Age</span> = <span class="number">17</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;Name&#125;</span> is <span class="subst">$&#123;Age&#125;</span> years old.`</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Lacia is 17 years old.</span><br></pre></td></tr></table></figure>

<p>使用模板字符串就可以直接将变量插入字符串中，类似于其他语言的格式化字符串。它的好处在于不用再担心隐式类型转换与字符串拼接的问题了。</p>
<h3 id="5-lambda表达式"><a href="#5-lambda表达式" class="headerlink" title="(5) lambda表达式"></a><strong>(5) lambda表达式</strong></h3><p>使用<code>=></code>可以定义一个lambda表达式，即快速定义函数。这种函数没有<code>arguments</code>变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params">a, b</span>) =&gt; &#123; <span class="keyword">return</span> a ** b; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">test</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">16</span><br></pre></td></tr></table></figure>

<p>lambda表达式定义的函数与一般的函数的区别在于<code>this</code>指针。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 lambda 表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">Lambda</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lambda this =&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Traditional</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Traditional this =&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Lambda</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Traditional</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与当前环境的 this 进行对比</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lambda :&quot;</span>, a === <span class="variable language_">this</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Traditional :&quot;</span>, b === <span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node Hello.js &#125;</span><br><span class="line">Lambda this = &#123;&#125;</span><br><span class="line">Traditional this = &lt;ref *1&gt; Object [global] &#123;</span><br><span class="line">    /* 太过冗长此处省略 */</span><br><span class="line">&#125;</span><br><span class="line">Lambda : true</span><br><span class="line">Traditional : false</span><br></pre></td></tr></table></figure>

<p>可以看到通过lambda表达式定义的函数的<code>this</code>指针与定义它的环境下的<code>this</code>相同。另外，<code>lambda</code>表达式的<code>this</code>指针是静态的，不论是谁调用该函数，<code>this</code>指针均不变，而在一般函数中<code>this</code>将会指向调用它的对象。也因此，使用lambda表达式定义的函数不允许被用于构造函数。</p>
<h3 id="6-可变长度参数"><a href="#6-可变长度参数" class="headerlink" title="(6) 可变长度参数"></a><strong>(6) 可变长度参数</strong></h3><p>虽然一般函数中存在<code>arguments</code>变量以获取所有的参数，但<code>arguments</code>变量本身是一个伪数组。ES6标准定义了新的可变长度参数的书写方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式不含 arguments，但可以使用可变长度参数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params">...args</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args =&quot;</span>, args);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args instanceof Array =&quot;</span>, args <span class="keyword">instanceof</span> <span class="title class_">Array</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">114</span>, <span class="string">&quot;514&quot;</span>, &#123; <span class="string">&quot;1919&quot;</span>: <span class="number">810</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">args = [ 114, &#x27;514&#x27;, &#123; &#x27;1919&#x27;: 810 &#125; ]</span><br><span class="line">args instanceof Array = true</span><br></pre></td></tr></table></figure>

<p>可变长度参数只能放在参数列表的末尾，并且需要在参数名前加上 <code>...</code> 以标识它是一个可变长度参数。在函数中，可变长度参数本身是一个数组对象。</p>
<h3 id="7-扩展运算符"><a href="#7-扩展运算符" class="headerlink" title="(7) 扩展运算符"></a><strong>(7) 扩展运算符</strong></h3><p>与可变长度参数的标识符一致，扩展运算符就是<code>...</code> ，但区别在于前者用于形参列表，后者用于实参列表且仅能作用于可迭代对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处没有使用可变长度参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arguments =&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实参列表处使用扩展运算符</span></span><br><span class="line"><span class="title function_">test</span>(...[<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">arguments = [Arguments] &#123; &#x27;0&#x27;: 114, &#x27;1&#x27;: 514, &#x27;2&#x27;: 1919, &#x27;3&#x27;: 810 &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到扩展运算符的作用大致相当于将数组解构，并将每一个解构出来的元素作为参数，按照顺序传入函数。</p>
<p>扩展运算符也可以用于创建数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>];</span><br><span class="line"><span class="keyword">let</span> b = [...a, <span class="number">1919</span>, <span class="number">810</span>];</span><br></pre></td></tr></table></figure>

<h3 id="8-Symbol类型"><a href="#8-Symbol类型" class="headerlink" title="(8) Symbol类型"></a><strong>(8) <code>Symbol</code>类型</strong></h3><p><code>Symbol</code>既是一个对象，也可以作为<code>Symbol()</code>构造函数创建全新的<code>Symbol</code>类型的变量。</p>
<h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a><strong>1. 特性</strong></h4><p><code>Symbol</code>是一个新的变量类型。在ES6标准下，JavaScript的变量类型有<code>undefined</code> 、<code>String</code> 、<code>Symbol</code> 、<code>Object</code> 、<code>Number</code>和<code>Boolean</code>类型。</p>
<p>新加入的<code>Symbol</code>类型的变量创建很容易：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p><code>Symbol</code>类型的变量具有的特性是，不会出现相等的<code>Symbol</code>类型的变量，就像雪花都是雪花，但不会有同一形状的两片雪花。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a == b is&quot;</span>, a == b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a === b is&quot;</span>, a === b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a == b is false</span><br><span class="line">a === b is false</span><br></pre></td></tr></table></figure>

<p>因此可以使用它来定义对象的属性，保证不会重名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[<span class="title class_">Symbol</span>()] = <span class="string">&quot;114&quot;</span>;</span><br><span class="line">a[<span class="title class_">Symbol</span>()] = <span class="string">&quot;514&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = &#123; [Symbol()]: &#x27;114&#x27;, [Symbol()]: &#x27;514&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-for-方法"><a href="#2-for-方法" class="headerlink" title="2. for()方法"></a><strong>2. <code>for()</code>方法</strong></h4><p>在<code>Symbol</code>对象下有一个名为<code>for()</code>的方法。该方法与<code>Symbol()</code>类似，但可以生成 “相同的雪花” 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;114&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;114&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a == b is&quot;</span>, a == b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a === b is&quot;</span>, a === b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a == b is true</span><br><span class="line">a === b is true</span><br></pre></td></tr></table></figure>

<h4 id="3-iterator迭代器"><a href="#3-iterator迭代器" class="headerlink" title="3. iterator迭代器"></a><strong>3. <code>iterator</code>迭代器</strong></h4><h5 id="Ⅰ-默认的迭代器"><a href="#Ⅰ-默认的迭代器" class="headerlink" title="Ⅰ. 默认的迭代器"></a><strong>Ⅰ. 默认的迭代器</strong></h5><p>ES6标准在<code>Symbol</code>对象下，定义了一个<code>iterator</code>（迭代器）属性。该属性一般用于可迭代容器（例如数组、映射、字符串等），并且在ES6标准下，<code>Symbol.iterator</code>这个属性被定义到了常见可迭代容器的原型对象下。一般实现了<code>iterator</code>接口就是指该对象含有<code>Symbol.iterator</code>属性。<code>for of</code>循环的底层实现就是使用了该属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会打印下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会打印值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">114</span><br><span class="line">514</span><br><span class="line">1919</span><br><span class="line">810</span><br></pre></td></tr></table></figure>

<p><code>Symbol.iterator</code>属性本身是一个函数，它的返回值是一个迭代器对象。该对象下有一个<code>next()</code>方法，该方法调用时将会返回当前的元素，并让 “指针” 后移。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器对象</span></span><br><span class="line"><span class="keyword">let</span> iterator = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">&#123; value: 114, done: false &#125;</span><br><span class="line">&#123; value: 514, done: false &#125;</span><br><span class="line">&#123; value: 1919, done: false &#125;</span><br><span class="line">&#123; value: 810, done: false &#125;</span><br><span class="line">&#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>next()</code>方法返回的值是一个对象，其<code>value</code>属性表明当前元素的值，而<code>done</code>属性则指示迭代是否完成。</p>
<h5 id="Ⅱ-自定义迭代器"><a href="#Ⅱ-自定义迭代器" class="headerlink" title="Ⅱ. 自定义迭代器"></a><strong>Ⅱ. 自定义迭代器</strong></h5><p>迭代器是允许自定义的。我们可以使用它来控制<code>for of</code>对自定义对象的遍历模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="comment">// 定义对象的属性</span></span><br><span class="line">    <span class="title class_">Kouka</span>: <span class="string">&quot;Type:001&quot;</span>,</span><br><span class="line">    <span class="title class_">Method</span>: <span class="string">&quot;Type-004&quot;</span>,</span><br><span class="line">    <span class="title class_">Lacia</span>: <span class="string">&quot;Type-005&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义迭代器属性，它应当返回一个迭代器对象</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取对象的属性名列表</span></span><br><span class="line">        <span class="keyword">const</span> list = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="variable language_">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            list.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回迭代器对象，该对象应当有一个 next() 方法</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 定义 next() 方法，定义为 lambda 表达式，其中的 this 将指向对象 a</span></span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Index</span> &lt; list.<span class="property">length</span>)</span><br><span class="line">                    a = &#123; <span class="attr">value</span>: <span class="variable language_">this</span>[list[<span class="title class_">Index</span>]], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    a = &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">                <span class="title class_">Index</span>++;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Type:001</span><br><span class="line">Type-004</span><br><span class="line">Type-005</span><br></pre></td></tr></table></figure>

<h3 id="9-生成器"><a href="#9-生成器" class="headerlink" title="(9) 生成器"></a><strong>(9) 生成器</strong></h3><div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>不推荐</strong></div>

<div style="color:goldenrod;">最新的JavaScript标准中，已经有比生成器更好的异步实现了。</div>
</div>

<p>生成器本质是一个函数，它在底层也是使用了迭代器。声明一个生成器函数很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请注意要加 * （星号）</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title class_">Generator</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成器的返回对象是一个迭代器，即便你没有写<code>return</code>也是如此。生成器一般用于避免回调地狱，即回调函数互相嵌套的场景。但最新的标准中已经有了更好的解决方案，此处就不做过多赘述，叙述生成器的一些一般特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title class_">Generator</span>(<span class="title class_">First</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">First</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收下一次 next() 调用时的参数</span></span><br><span class="line">    <span class="comment">// 返回本次 next() 调用时的结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Second</span> = <span class="keyword">yield</span> <span class="title class_">First</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Second</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Third</span> = <span class="keyword">yield</span> <span class="title class_">Second</span> ** <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Third</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Third</span> ** <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Generator</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">3</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">4</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">5</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">2</span><br><span class="line">&#123; value: 4, done: false &#125;</span><br><span class="line">4</span><br><span class="line">&#123; value: 64, done: false &#125;</span><br><span class="line">5</span><br><span class="line">&#123; value: 625, done: true &#125;</span><br><span class="line">&#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，生成器函数一开始是没有被调用的。直到返回的迭代器对象调用<code>next()</code>方法时，才第一次调用并执行生成器函数。</p>
<p>每一次调用<code>next()</code>方法时，生成器函数都会执行到下一个<code>yield</code>关键字处，并且返回值是<code>yield</code>关键字后的值（类似于一般的<code>return</code> ）。下一次调用<code>next()</code>函数时，参数将返回至上一次<code>yield</code>关键字处。当执行到<code>return</code>语句时，返回值对象中的<code>done</code>属性将为<code>true</code> ，并且会正常返回值。</p>
<h3 id="10-Promise"><a href="#10-Promise" class="headerlink" title="(10) Promise"></a><strong>(10) <code>Promise</code></strong></h3><p><code>Promise</code>是比生成器更适合用于解决回调地狱的新异步方案。<code>Promise()</code>实际上是一个构造函数，该构造函数接受1个参数，该参数应该为函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Promise 类的对象</span></span><br><span class="line"><span class="comment">// 参数函数的参数应当有两个，成功时调用的函数和失败时调用的函数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Success, Fail</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 省略部分代码，此处一般为 I/O</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="title class_">Success</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line">    <span class="comment">// Fail(&quot;Request Failed.&quot;);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当执行完时 then() 方法才会调用</span></span><br><span class="line"><span class="comment">// 根据执行状态，成功则执行第一个回调函数，失败则执行第二个</span></span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>请注意，上述代码中的<code>Success</code>与<code>Fail</code>并不是程序员所定义的函数，程序员也不需要定义它，更不需要传参数。</p>
<p>作为<code>Promise()</code>构造函数参数的函数，它在执行时的参数会由<code>Promise</code>类的对象自行传入，并在该对象生成后自行执行。若在该函数中调用了第一个回调函数<code>Success()</code> ，该对象的状态将被修改为成功，若调用了第二个则视为失败。其参数分别对应了读取成功的数据和执行失败的原因。</p>
<p>当构造函数参数的函数执行完毕时，<code>Promise</code>类的对象的<code>then()</code>方法开始执行，并且会根据该对象的状态来执行第一个或第二个回调函数。参数也分别是读取成功的数据和执行失败的原因。</p>
<p><code>then()</code>方法也会返回一个<code>Promise</code>类的对象，该对象的状态由<code>then()</code>方法的执行结果确定。成功执行回调，则为<code>resolved</code> ，否则为<code>rejected</code> 。因为<code>then()</code>方法的返回值也是一个<code>Promise</code>类的对象，因此可以使用链式的<code>then()</code>方法。</p>
<p>关于<code>Promise</code>对象，本文不会深究而只做浅述。深入学习的部分将会放在其他文章中。</p>
<h3 id="11-数据结构"><a href="#11-数据结构" class="headerlink" title="(11) 数据结构"></a><strong>(11) 数据结构</strong></h3><p>ES6标准下的JavaScript存在新的数据结构。</p>
<h4 id="1-Set（集合）"><a href="#1-Set（集合）" class="headerlink" title="1. Set（集合）"></a><strong>1. <code>Set</code>（集合）</strong></h4><p><code>Set</code>对象中的每一个元素都是唯一的。该数据结构实现了<code>iterator</code>接口。<code>Set</code>对象的常见属性与方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名 &#x2F; 属性名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Set()</code></td>
<td align="center">无或可迭代对象</td>
<td align="center">构造函数</td>
<td align="center"><code>Set</code>对象</td>
</tr>
<tr>
<td align="center"><code>size</code></td>
<td align="center">\</td>
<td align="center">返回元素个数</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>add()</code></td>
<td align="center">元素</td>
<td align="center">向<code>Set</code>对象中添加元素</td>
<td align="center">当前<code>Set</code>对象</td>
</tr>
<tr>
<td align="center"><code>delete()</code></td>
<td align="center">元素</td>
<td align="center">删除指定的元素</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>has()</code></td>
<td align="center">元素</td>
<td align="center">检测<code>Set</code>对象中是否含有指定元素</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>clear()</code></td>
<td align="center">无</td>
<td align="center">清空<code>Set</code>对象</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>由于<code>Set</code>对象是可迭代的，因此该对象可以使用扩展运算符以快速转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">114</span>, <span class="number">1919</span>, <span class="number">810</span>, <span class="number">1919</span>, <span class="number">514</span>, <span class="number">114</span>, <span class="number">810</span>];</span><br><span class="line">a = [...<span class="keyword">new</span> <span class="title class_">Set</span>(a)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = [ 114, 514, 1919, 810 ]</span><br></pre></td></tr></table></figure>

<p>上述代码实现了可迭代容器的快速去重。</p>
<h4 id="2-Map（映射）"><a href="#2-Map（映射）" class="headerlink" title="2. Map（映射）"></a><strong>2. <code>Map</code>（映射）</strong></h4><p><code>Map</code>对象中存在键值对，键是唯一的而值可以重复出现。该数据结构实现了<code>iterator</code>接口。<code>Map</code>对象的常见属性与方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名 &#x2F; 属性名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Map()</code></td>
<td align="center">无</td>
<td align="center">构造函数</td>
<td align="center"><code>Map</code>对象</td>
</tr>
<tr>
<td align="center"><code>set()</code></td>
<td align="center">键，值</td>
<td align="center">向<code>Map</code>对象中插入或更新键值对</td>
<td align="center">当前<code>Map</code>对象</td>
</tr>
<tr>
<td align="center"><code>size</code></td>
<td align="center">\</td>
<td align="center">返回键值对个数</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>delete()</code></td>
<td align="center">键</td>
<td align="center">删除指定的键值对</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>get()</code></td>
<td align="center">键</td>
<td align="center">获取键对应的值</td>
<td align="center">值或<code>undefined</code></td>
</tr>
</tbody></table>
<h3 id="12-class（类）"><a href="#12-class（类）" class="headerlink" title="(12) class（类）"></a><strong>(12) <code>class</code>（类）</strong></h3><p>在ES6标准下，定义类的语法本质上是语法糖，而不是新的语法规则，其底层实现依然是ES5的那一套。即：在ES6及其以上的标准中，依然可以使用ES5的语法。</p>
<h4 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1. 定义类"></a><strong>1. 定义类</strong></h4><p>虽然ES5中已经有构造函数与类了，但ES6的标准让类的写法更像C++，代码阅读起来更轻松。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 HIE 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 固定写法，定义构造函数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写该类的方法</span></span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>);</span><br><span class="line"><span class="title class_">Lacia</span>.<span class="title class_">Info</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">HIE &#123; Name: &#x27;Lacia&#x27;, Type: &#x27;Type-005&#x27; &#125;</span><br><span class="line">My name is Lacia. Type is Type-005.</span><br></pre></td></tr></table></figure>

<p>上述代码的底层实现其实就是ES5定义类的那一套。</p>
<h4 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a><strong>2. 静态方法</strong></h4><p>与Java &#x2F; C#类似，JavaScript也允许在类中使用<code>static</code>关键字修饰成员变量或成员函数。被修饰的成员函数是静态的，只能通过类名调用而不能通过实例对象访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义静态成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Hello</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试通过实例对象来访问静态成员</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>.<span class="property">Hello</span>);</span><br><span class="line"><span class="variable constant_">HIE</span>.<span class="title class_">Hello</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">undefined</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>可以看到实例对象无法访问静态的成员，但类名可以。其底层实现仍然是基于ES5语法的。静态的成员实际上就是定义到了构造函数对象上，非静态的成员函数则是定义到了构造函数的原型对象上，而非静态的成员变量将会定义到实例化的对象上。</p>
<h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a><strong>3. 继承</strong></h4><p>在ES6标准下，一个类继承另一个类只需要使用<code>extends</code>关键字。JavaScript不允许多继承。<del>学Java的啥不好偏偏学了这个东西。</del></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Hello</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类，继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type, Age</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// super() 指父类的构造函数</span></span><br><span class="line">        <span class="variable language_">super</span>(<span class="title class_">Name</span>, <span class="title class_">Type</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Age</span> = <span class="title class_">Age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Speak</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.Age&#125;</span> years old.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Kouka</span> = <span class="keyword">new</span> <span class="title class_">Lacia</span>(<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Type-001&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Kouka</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Lacia &#123; Name: &#x27;Kouka&#x27;, Type: &#x27;Type-001&#x27;, Age: 17 &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码如果要用ES5的标准来写的话，应该是下述代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HIE</span>(<span class="params">Name, Type</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类成员方法</span></span><br><span class="line"><span class="variable constant_">HIE</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">Info</span> = <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类静态方法</span></span><br><span class="line"><span class="variable constant_">HIE</span>.<span class="property">Hello</span> = <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Lacia</span>(<span class="params">Name, Type, Age</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用父类构造函数</span></span><br><span class="line">    <span class="variable constant_">HIE</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="title class_">Name</span>, <span class="title class_">Type</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Age</span> = <span class="title class_">Age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承自父类，重设子类的原型对象为父类</span></span><br><span class="line"><span class="title class_">Lacia</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">HIE</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类方法</span></span><br><span class="line"><span class="title class_">Lacia</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">Speak</span> = <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.Age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Kouka</span> = <span class="keyword">new</span> <span class="title class_">Lacia</span>(<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Type-001&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Kouka</span>);</span><br></pre></td></tr></table></figure>

<p>想都不用想肯定是ES6的代码更清晰。要读懂并编写ES5的代码，要求读者对JavaScript的原型链有清楚的认知，而ES6标准下的代码像是对ES5的 “封装”，读者不必再了解其底层原理就能编写代码。</p>
<h4 id="4-重写父类方法"><a href="#4-重写父类方法" class="headerlink" title="4. 重写父类方法"></a><strong>4. 重写父类方法</strong></h4><p>ES6中允许子类存在与父类中同名的方法。子类在调用同名方法时，只会调用子类自身的方法，不会调用父类的方法。其底层实现是子类的原型对象（父类）上已经定义了子类自身的方法，在找到该方法后就不会再向原型对象的原型对象（父类的原型对象）上寻找该方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义父类同名方法</span></span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type, Age</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="title class_">Name</span>, <span class="title class_">Type</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Age</span> = <span class="title class_">Age</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义子类同名方法</span></span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>. Age is <span class="subst">$&#123;<span class="variable language_">this</span>.Age&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Kouka</span> = <span class="keyword">new</span> <span class="title class_">Lacia</span>(<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Type-001&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Kouka</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用子类方法</span></span><br><span class="line"><span class="title class_">Kouka</span>.<span class="title class_">Info</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试调用父类方法</span></span><br><span class="line"><span class="title class_">Kouka</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="title class_">Info</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Lacia &#123; Name: &#x27;Kouka&#x27;, Type: &#x27;Type-001&#x27;, Age: 17 &#125;</span><br><span class="line">My name is Kouka. Type is Type-001. Age is 17.</span><br><span class="line">My name is undefined. Type is undefined.</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>为什么是<code>undefined</code></strong></div>

<div style="color:royalblue;">可以看到虽然成功调用了父类方法，但输出却是<code>undefined</code> 。这是因为调用该方法的对象不是<code>Kouka</code> ，而是<code>Kouka</code>的原型对象的原型对象。子类实例的所有非静态属性是定义在子类实例对象上的，包括从父类继承的属性（理解这一点需要掌握ES5中继承的原理）。并且，调用者变为了原型对象的原型对象，因此<code>this</code>指针无法访问到对应的属性，就会输出<code>undefined</code>。</div>
</div>

<h4 id="5-getter与setter"><a href="#5-getter与setter" class="headerlink" title="5. getter与setter"></a><strong>5. <code>getter</code>与<code>setter</code></strong></h4><p>与Java &#x2F; C#类似，JavaScript的类中也存在<code>getter</code>与<code>setter</code> ，但其语法还是不如C#简洁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Capitalist</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Cashes</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Cashes</span> = <span class="title class_">Cashes</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">Capital</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getter 被调用了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">Cashes</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 setter</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">Capital</span>(<span class="params">Value</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Setter 被调用了&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Cashes</span> = <span class="title class_">Value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">JackMa</span> = <span class="keyword">new</span> <span class="title class_">Capitalist</span>(<span class="number">114514</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改与读取</span></span><br><span class="line"><span class="title class_">JackMa</span>.<span class="property">Capital</span> = <span class="number">1919810</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JackMa.Capital =&quot;</span>, <span class="title class_">JackMa</span>.<span class="property">Capital</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Setter 被调用了</span><br><span class="line">Getter 被调用了</span><br><span class="line">JackMa.Capital = 1919810</span><br></pre></td></tr></table></figure>

<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>不要让<code>getter()</code>或<code>setter()</code>与真实属性重名！</strong></div>

<div style="color:darkred;">如果出现了重名，尤其是与要读取 / 要修改的属性重名时，将会引发循环读取 / 循环写入。因为<code>getter()</code>和<code>setter()</code>的优先级比属性更高，使用时会优先使用它们。</div>
</div>

<h3 id="13-类的扩展"><a href="#13-类的扩展" class="headerlink" title="(13) 类的扩展"></a><strong>(13) 类的扩展</strong></h3><h4 id="1-数值与运算扩展"><a href="#1-数值与运算扩展" class="headerlink" title="1. 数值与运算扩展"></a><strong>1. 数值与运算扩展</strong></h4><p>ES6标准中定义了<code>Number</code>类的一些新的静态方法与静态属性。</p>
<table>
<thead>
<tr>
<th align="center">方法名 &#x2F; 属性名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>EPSILON</code></td>
<td align="center">\</td>
<td align="center">表示JavaScript中能表示的最小的数值</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>isFinite()</code></td>
<td align="center">任意值</td>
<td align="center">判断参数是否为有限的数</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>isNaN()</code></td>
<td align="center">任意值</td>
<td align="center">判断参数是否为<code>NaN</code></td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>parseInt()</code></td>
<td align="center">任意值</td>
<td align="center">将参数转换为整数</td>
<td align="center"><code>Number</code> ，转换失败时是<code>NaN</code></td>
</tr>
<tr>
<td align="center"><code>parseFloat()</code></td>
<td align="center">任意值</td>
<td align="center">将参数转换为浮点数</td>
<td align="center"><code>Number</code> ，转换失败时是<code>NaN</code></td>
</tr>
</tbody></table>
<p><code>Math</code>类中也新添了一些静态方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>trunc()</code></td>
<td align="center"><code>Number</code></td>
<td align="center">去掉该数字的小数部分</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>sign()</code></td>
<td align="center"><code>Number</code></td>
<td align="center">判断一个数是正数负数还是0。</td>
<td align="center"><code>1</code> 、<code>0</code> 、<code>-1</code> ，判断失败时是<code>NaN</code></td>
</tr>
</tbody></table>
<p>此外，ES6标准允许像C一样书写二进制、八进制与十六进制的数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0b11</span>;   <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0o77</span>;   <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0xFF</span>;   <span class="comment">// 十六进制</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 3</span><br><span class="line">b = 63</span><br><span class="line">c = 255</span><br></pre></td></tr></table></figure>

<h4 id="2-对象的扩展"><a href="#2-对象的扩展" class="headerlink" title="2. 对象的扩展"></a><strong>2. 对象的扩展</strong></h4><p><code>Object</code>本身也是一个对象，该对象也扩展了一些静态方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>is()</code></td>
<td align="center">任意值，任意值</td>
<td align="center">判断两个参数是否完全相等</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>assign()</code></td>
<td align="center"><code>Object</code> ，<code>Object</code></td>
<td align="center">合并两个对象，若有重名属性，则后者的属性值会覆盖前者</td>
<td align="center"><code>Object</code></td>
</tr>
<tr>
<td align="center"><code>setPrototypeOf()</code></td>
<td align="center"><code>Object</code> ，<code>Object</code></td>
<td align="center">将前者的原型对象设置为后者</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>getPrototypeOf()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">获取指定对象的原型对象</td>
<td align="center"><code>Object</code></td>
</tr>
</tbody></table>
<h3 id="14-模块化"><a href="#14-模块化" class="headerlink" title="(14) 模块化"></a><strong>(14) 模块化</strong></h3><p>JavaScript模块化，解决了JavaScript的命名空间污染、代码耦合度高、不便维护的问题。模块化的JavaScript文件，既可以被其他JavaScript文件引入，也可以被HTML文件中的<code>&lt;script&gt;</code>标签中的JavaScript代码引入。</p>
<p>要使用模块化，就需要指明这个模块对外暴露的变量或函数是什么。未被暴露的变量或方法，其他模块无权访问。可以使用<code>export</code>关键字修饰要暴露的变量或方法。</p>
<h4 id="1-直接暴露"><a href="#1-直接暴露" class="headerlink" title="1. 直接暴露"></a><strong>1. 直接暴露</strong></h4><p>直接暴露就是在声明变量或函数时就标注要暴露它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴露变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">114514</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1919810</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-统一暴露"><a href="#2-统一暴露" class="headerlink" title="2. 统一暴露"></a><strong>2. 统一暴露</strong></h4><p>统一暴露是指先把变量与函数都声明了，再在最后统一 “打包” 暴露。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">114514</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1919810</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 a，b 打包并暴露</span></span><br><span class="line"><span class="keyword">export</span> &#123; a, b &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-默认暴露"><a href="#3-默认暴露" class="headerlink" title="3. 默认暴露"></a><strong>3. 默认暴露</strong></h4><p>使用默认暴露时，一般是暴露匿名对象，并且要在<code>export</code>关键字后追加<code>default</code>关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Vue&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义函数</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">114514</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用默认暴露的模块不能使用解构引入。</p>
<h4 id="4-通用引入"><a href="#4-通用引入" class="headerlink" title="4. 通用引入"></a><strong>4. 通用引入</strong></h4><p>引入模块时，需要指明引入模块的什么部分与模块的路径。可以选择为引入的对象用<code>as</code>关键字声明一个别名。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Module</span> <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Module</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器的控制台中将会打印：</p>
<p><img src="/2022/04/30/ES6-ES11/1.png" alt="1" title="1"></p>
<p>可以看出<code>export</code>了的变量与函数是被<code>get()</code>和<code>set()</code>做了 “代理” 的。并且引入的变量与函数将被 “打包” 进一个变量。</p>
<p>不推荐以上述方式引入默认暴露的模块。因为当引入默认暴露的模块时，控制台的打印结果是：</p>
<p><img src="/2022/04/30/ES6-ES11/3.png" alt="3" title="3"></p>
<p>中间多夹了一层<code>default</code>对象。这也就意味着通过这种方式引入的模块，调用时要用形如<code>Module.default.a</code>的形式调用，很别扭。</p>
<h4 id="5-解构引入"><a href="#5-解构引入" class="headerlink" title="5. 解构引入"></a><strong>5. 解构引入</strong></h4><p>解构引入利用了ES6的解构特性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">b</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器的控制台中将会打印：</p>
<p><img src="/2022/04/30/ES6-ES11/2.png" alt="2" title="2"></p>
<p>解构引入同样可以声明别名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; a <span class="keyword">as</span> c, b &#125; <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在解构引入的情况下使用别名，一般是为了解决引入的不同模块之间的命名冲突问题。</p>
<h4 id="6-default引入"><a href="#6-default引入" class="headerlink" title="6. default引入"></a><strong>6. <code>default</code>引入</strong></h4><p>引入默认暴露的模块时，可以不需要<code>as</code>关键字，因为引入的就是一个对象，并且引入者可以用任意的变量名引入默认暴露的模块。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 引入 Hello.js 中默认暴露的模块</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> a <span class="comment">/* 此处可以填任意名字 */</span> <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 上述写法是简写形式，完整形式是</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> a &#125; <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，上述代码中的第一种写法<span style="color:red;">只能</span>用于默认暴露的模块。</p>
<h2 id="三、ES7标准"><a href="#三、ES7标准" class="headerlink" title="三、ES7标准"></a><strong>三、ES7标准</strong></h2><p>ES6标准是改动最多的，学完ES6剩下的就相对简单多了。</p>
<h3 id="1-includes"><a href="#1-includes" class="headerlink" title="(1) includes()"></a><strong>(1) <code>includes()</code></strong></h3><p><code>includes()</code>方法定义在了<code>Array()</code>构造函数的原型对象下，也就是说该方法是数组的方法。该方法用于判断数组中是否含有某个元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">includes</span>(<span class="number">114</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">includes</span>(<span class="string">&quot;114&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>需要注意的是，其底层判断原理是判断位于栈中的值与数组保存的数据（若为对象，则是其值是地址）是否相等，因此它不适合判断两个对象是否一致。除非是判断指向同一堆地址的对象，否则该方法都会返回<code>false</code> 。</p>
<h3 id="2-次方运算符"><a href="#2-次方运算符" class="headerlink" title="(2) 次方运算符"></a><strong>(2) 次方运算符</strong></h3><p>ES7标准增加了一种运算符<code>**</code> ，与其他语言类似，该运算符用于做次方运算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2 ** 8 =&quot;</span>, <span class="number">2</span> ** <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">2 ** 8 = 256</span><br></pre></td></tr></table></figure>

<p>本质上这是一个语法糖，其底层原理是<code>Math.pow()</code>方法。</p>
<h2 id="四、ES8标准"><a href="#四、ES8标准" class="headerlink" title="四、ES8标准"></a><strong>四、ES8标准</strong></h2><h3 id="1-async与await"><a href="#1-async与await" class="headerlink" title="(1) async与await"></a><strong>(1) <code>async</code>与<code>await</code></strong></h3><p><code>async</code>与<code>await</code>是关键字，它也可以用于解决回调地狱。它写起来像同步代码，但实际上其底层实现用到了<code>Promise</code> ， 即实际上还是异步。</p>
<p><code>async</code>用于修饰函数，被修饰的函数应当返回一个<code>Promise</code>对象或其他任意值。当返回值<span style="color:red;">不为</span> <code>Promise</code>对象时，真正返回的结果将是一个成功状态的<code>Promise</code>对象，并且其携带的值为返回值。即便是不写<code>return</code> ，也会返回一个<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回值为 undefined</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a() =&quot;</span>, <span class="title function_">a</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回一个失败状态的 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Succeed, Fail</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Fail</span>(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b() =&quot;</span>, <span class="title function_">b</span>());</span><br></pre></td></tr></table></figure>

<p>由于Node.js的打印并不会打印<code>Promise</code>对象的内部状态，此处就换为浏览器控制台来查看<code>Promise</code>对象：</p>
<p><img src="/2022/04/30/ES6-ES11/4.png" alt="4" title="4"></p>
<p><code>await</code>关键字只能出现在<code>async</code>关键字修饰的函数中，并且<code>await</code>后的值应当为一个<code>Promise</code>对象。<code>await</code>关键字有一个返回值，其值为<code>Promise</code>对象的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，其返回值是一个 Promise对象，但它不是 async 函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Succeed, Fail</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 成功返回值</span></span><br><span class="line">        <span class="title class_">Succeed</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Succeed, Fail</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将会抛出异常</span></span><br><span class="line">        <span class="title class_">Fail</span>(<span class="string">&quot;1919810&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为可能会抛出异常，因此需要进行错误处理</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 尝试获取成功结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">a</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功结果：&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="title class_">Error</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败信息：&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功结果：&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="title class_">Error</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败信息：&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="title function_">c</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">成功结果： 114514</span><br><span class="line">失败信息： 1919810</span><br></pre></td></tr></table></figure>

<p>上述写法很像同步语句，一方面完全规避了回调地狱，另一方面又规避了<code>Promise</code>的<code>then()</code>地狱（但又迎来了<code>try catch</code>地狱）。但至少上述写法阅读起来起来清爽简洁。</p>
<h3 id="2-对象的扩展-1"><a href="#2-对象的扩展-1" class="headerlink" title="(2) 对象的扩展"></a><strong>(2) 对象的扩展</strong></h3><p>ES8标准下的<code>Object</code>对象又多了一些方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>keys()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回指定对象的所有属性名</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>values()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回指定对象的所有属性值</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>entries()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回以<code>[属性名 , 属性值]</code>为元素的数组</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>getOwnPropertyDescriptors()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回指定对象的所有属性的描述对象</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>getOwnPropertyDescriptor()</code></td>
<td align="center"><code>Object</code> ，<code>String</code></td>
<td align="center">返回指定对象的指定属性名的描述对象</td>
<td align="center"><code>Array</code></td>
</tr>
</tbody></table>
<p>其中，<code>entries()</code>方法常用于一般对象转<code>Map</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="number">514</span>, <span class="attr">c</span>: <span class="string">&quot;1919&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;810&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值对</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Object.entries(a) =&quot;</span>, <span class="title class_">Object</span>.<span class="title function_">entries</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Map() 构造函数来初始化映射</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Object.entries(a) = [ [ &#x27;a&#x27;, 114 ], [ &#x27;b&#x27;, 514 ], [ &#x27;c&#x27;, &#x27;1919&#x27; ], [ &#x27;d&#x27;, &#x27;810&#x27; ] ]</span><br><span class="line">b = Map(4) &#123; &#x27;a&#x27; =&gt; 114, &#x27;b&#x27; =&gt; 514, &#x27;c&#x27; =&gt; &#x27;1919&#x27;, &#x27;d&#x27; =&gt; &#x27;810&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>而<code>getOwnPropertyDescriptors()</code>常用于深拷贝对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="number">514</span>, <span class="attr">c</span>: <span class="string">&quot;1919&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;810&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 a 的描述对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过描述对象来创建新对象</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">&#123;</span><br><span class="line">  a: &#123; value: 114, writable: true, enumerable: true, configurable: true &#125;,</span><br><span class="line">  b: &#123; value: 514, writable: true, enumerable: true, configurable: true &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    value: &#x27;1919&#x27;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    value: &#x27;810&#x27;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a = &#123; a: 114, b: 514, c: &#x27;1919&#x27;, d: &#x27;810&#x27; &#125;</span><br><span class="line">b = [Object: null prototype] &#123; a: 114, b: 514, c: &#x27;1919&#x27;, d: &#x27;810&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、ES9标准"><a href="#五、ES9标准" class="headerlink" title="五、ES9标准"></a><strong>五、ES9标准</strong></h2><h3 id="1-扩展运算符的扩展"><a href="#1-扩展运算符的扩展" class="headerlink" title="(1) 扩展运算符的扩展"></a><strong>(1) 扩展运算符的扩展</strong></h3><p>ES6标准下的扩展运算符只能用于数组，而在ES9标准下则可以用于对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="string">&quot;514&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">c</span>: <span class="string">&quot;1919&quot;</span>, <span class="attr">d</span>: <span class="number">810</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">c = &#123; a: 114, b: &#x27;514&#x27;, c: &#x27;1919&#x27;, d: 810 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-正则表达式扩展"><a href="#2-正则表达式扩展" class="headerlink" title="(2) 正则表达式扩展"></a><strong>(2) 正则表达式扩展</strong></h3><p>不知道什么是正则表达式？正则表达式的知识不用全都记牢，看过一遍就行，忘记了再翻翻教程网站就好。此处不会对JavaScript的正则表达式做解释，详情请参见 <a class="btn" target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions ">MDN 文档</a> 。</p>
<h4 id="1-捕获分组命名"><a href="#1-捕获分组命名" class="headerlink" title="1. 捕获分组命名"></a><strong>1. 捕获分组命名</strong></h4><p>在ES9标准下，可以对正则表达式捕获的分组做命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写待匹配的字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">HTML1</span> = <span class="string">&quot;&lt;div id=\&quot;app\&quot; class=\&quot;anime_top\&quot;&gt;主页&lt;/div&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写正则表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/&lt;div id=&quot;(a.*)&quot; class=&quot;anime_top&quot;&gt;(.*)&lt;\/div&gt;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>)[<span class="number">0</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>)[<span class="number">1</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>)[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">[</span><br><span class="line">  &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  &#x27;app&#x27;,</span><br><span class="line">  &#x27;主页&#x27;,</span><br><span class="line">  index: 0,</span><br><span class="line">  input: &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  groups: undefined</span><br><span class="line">]</span><br><span class="line">&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;</span><br><span class="line">app</span><br><span class="line">主页</span><br></pre></td></tr></table></figure>

<p>上述的正则表达式匹配提取方式需要根据下表来提取，不直观，也不便于代码维护。因此ES9提出了捕获分组命名。只需要在捕获的<code>()</code>内最开始处写上<code>?&lt;&gt;</code> ，将该分组的名称填入<code>&lt;&gt;</code>内即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">HTML1</span> = <span class="string">&quot;&lt;div id=\&quot;app\&quot; class=\&quot;anime_top\&quot;&gt;主页&lt;/div&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/&lt;div id=&quot;(?&lt;id&gt;a.*)&quot; class=&quot;anime_top&quot;&gt;(?&lt;innerHTML&gt;.*)&lt;\/div&gt;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意提取方式变了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">id</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">innerHTML</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">[</span><br><span class="line">  &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  &#x27;app&#x27;,</span><br><span class="line">  &#x27;主页&#x27;,</span><br><span class="line">  index: 0,</span><br><span class="line">  input: &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  groups: [Object: null prototype] &#123; id: &#x27;app&#x27;, innerHTML: &#x27;主页&#x27; &#125;</span><br><span class="line">]</span><br><span class="line">app</span><br><span class="line">主页</span><br></pre></td></tr></table></figure>

<p>这种提取方式更利于阅读与后期维护。</p>
<h4 id="2-反向断言"><a href="#2-反向断言" class="headerlink" title="2. 反向断言"></a><strong>2. 反向断言</strong></h4><p>在ES9标准之前的JavaScript的正则表达式，可以指定匹配项的后一个字符 &#x2F; 字符串，这就是断言。而反向断言，就是对匹配项的前一个字符 &#x2F; 字符串做判断。不符合要求的子串都会被认为不与正则表达式匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待匹配的字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">HTML1</span> = <span class="string">&quot;114514JS1919810h&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/[A-Z]+(?&lt;num&gt;\d+)(?=h)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向断言，需要加上 “&lt;” 以标明这是反向断言</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="regexp">/(?&lt;=JS)(?&lt;num&gt;\d+)/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">num</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">num</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">1919810</span><br><span class="line">1919810</span><br></pre></td></tr></table></figure>

<p>两种匹配方式都成功了。</p>
<h4 id="3-全匹配模式"><a href="#3-全匹配模式" class="headerlink" title="3. .全匹配模式"></a><strong>3. <code>.</code>全匹配模式</strong></h4><p>在JavaScript的正则表达式中，<code>.</code>只能匹配非换行符。在用JavaScript爬取网页时，经常会遇到网页中的标签之间含有换行符，因此只能使用<code>\s+</code>进行匹配。这是非常痛苦的，因为写正则表达式一时爽，写完后debug那叫一个火葬场（至少我很不愿意阅读正则表达式）。ES9标准下可以追加一个标识符来让 <code>.</code>也能匹配到换行符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写一个类似于 HTML 格式的字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">HTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Target&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式，末尾写上标识符 “s”，代表启用 . 的全匹配模式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/&lt;div&gt;.*&lt;h1&gt;(?&lt;target&gt;.*)&lt;\/h1&gt;.*&lt;\/div&gt;/</span>s;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="variable constant_">HTML</span>).<span class="property">groups</span>.<span class="property">target</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target</span><br></pre></td></tr></table></figure>

<p>在启用全匹配模时，对于正则表达式中的 <code>.*</code> ，建议启用禁止贪婪模式，即 <code>.*?</code> 。</p>
<h2 id="六、ES10标准"><a href="#六、ES10标准" class="headerlink" title="六、ES10标准"></a><strong>六、ES10标准</strong></h2><p>ES10标准的改动主要是针对静态方法的细节扩展，因此此处就不对ES10做全面的介绍。</p>
<p>ES10标注对<code>Object</code>对象的方法又又做了扩展。<del>梅开三度。</del></p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>fromEntries()</code></td>
<td align="center"><code>Map</code>或<code>Array</code></td>
<td align="center">根据参数生成对象</td>
<td align="center"><code>Object</code></td>
</tr>
</tbody></table>
<p><code>fromEntries()</code>方法的参数可以是<code>Map</code>的实例对象，也可以是格式形如<code>Object.entries()</code>方法的返回值的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114514</span>, <span class="attr">b</span>: <span class="number">1919810</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过数组生成</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Map 的实例对象生成</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(a)));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">b = &#123; a: 114514, b: 1919810 &#125;</span><br><span class="line">c = &#123; a: 114514, b: 1919810 &#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>fromEntries()</code>方法就是<code>entries()</code>方法的逆运算。</p>
<h2 id="七、ES11标准"><a href="#七、ES11标准" class="headerlink" title="七、ES11标准"></a><strong>七、ES11标准</strong></h2><p>终于要学完力！芜湖！</p>
<h3 id="1-私有属性"><a href="#1-私有属性" class="headerlink" title="(1) 私有属性"></a><strong>(1) 私有属性</strong></h3><p>ES11标准下的JavaScript可以使用私有属性。若属性名的前缀含有 <code>#</code> ，则该属性为私有属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用私有属性前，必须先定义它</span></span><br><span class="line">    #<span class="title class_">Type</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title class_">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">Type</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#<span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-001&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试打印实例对象与 getter 的返回值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>.<span class="property">Type</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会抛出异常</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>.#<span class="title class_">Type</span>);</span><br></pre></td></tr></table></figure>

<p>删除引发异常的代码后，输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js &#125;</span></span><br><span class="line">HIE &#123; Name: &#x27;Lacia&#x27; &#125;</span><br><span class="line">Type-001</span><br></pre></td></tr></table></figure>

<p>可以看到私有属性是完全不允许在类外访问的，但是在类外可以通过getter和setter访问与修改。</p>
<h3 id="2-matchAll"><a href="#2-matchAll" class="headerlink" title="(2) matchAll()"></a><strong>(2) <code>matchAll()</code></strong></h3><p><code>matchAll()</code>方法被定义在了<code>String()</code>构造函数的原型对象下，即该方法可以被所有的字符串类型的变量调用。该方法的参数应该为一个正则表达式对象，返回值是一个可迭代对象。该方法的功能相当于对调用该方法的字符串做全局匹配，匹配所有的符合正则表达式的结果。</p>
<p>返回的可迭代对象的<code>next()</code>方法将会返回一个正常的正则表达式的匹配结果对象。该方法常用于爬虫。</p>
<h3 id="3-可选链操作符"><a href="#3-可选链操作符" class="headerlink" title="(3) 可选链操作符"></a><strong>(3) 可选链操作符</strong></h3><p>有时函数需要接受一个对象作为参数，但对象中有些属性可能没有，甚至调用函数的时候根本没有传入参数。如果没有传入参数，那么函数中的形参就将是<code>undefined</code> 。如果此时在函数中尝试获取形参的属性，就将抛出异常：不能获取<code>undefined</code>的属性。因此需要先判断参数是否存在，然后判断形参的某个对象属性是否存在，然后再……这样太麻烦了。所以就有了可选链操作符<code>?</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params">config</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若 ? 前的对象不存在，则结果将为 undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(config?.<span class="property">a</span>?.<span class="property">b</span>?.<span class="property">c</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整定义参数对象时</span></span><br><span class="line"><span class="title function_">a</span>(&#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">b</span>: &#123;</span><br><span class="line">            <span class="attr">c</span>: <span class="number">114514</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不传参数时</span></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">114514</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<p>若没有使用可选链操作符，第二次调用函数时将会抛出异常。</p>
<h3 id="4-动态引入"><a href="#4-动态引入" class="headerlink" title="(4) 动态引入"></a><strong>(4) 动态引入</strong></h3><p>当一个JavaScript文件引入了大量其他模块时，执行该文件前的时间开销将很大。为了加快启动速度，按需加载模块（懒加载，用到的时候再加载），于是有了ES11定义的动态引入。</p>
<p>要使用动态引入，需要使用<code>import()</code>方法。该方法的参数是模块的路径，返回值是一个<code>Promise</code>对象。该对象的成功结果即为模块本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按需引入，只有当参数为 true 时才引入</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Module</span> = <span class="keyword">await</span> <span class="title function_">import</span>(<span class="string">&quot;./Test.mjs&quot;</span>);</span><br><span class="line">        <span class="title class_">Module</span>.<span class="title function_">a</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="title function_">a</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure>

<h3 id="5-BigInt"><a href="#5-BigInt" class="headerlink" title="(5) BigInt"></a><strong>(5) <code>BigInt</code></strong></h3><p>为了解决JavaScript的大整数运算问题，ES11标准定义了一个新的类型：<code>BigInt</code>类型。定义属于该类型的整数时，在字面量尾部加上<code>n</code>即可。将一般的整数数值转换为<code>BigInt</code>类型，使用<code>BigInt()</code>函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">114514n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;typeof a =&quot;</span>, <span class="keyword">typeof</span> a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(<span class="number">1919810</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">typeof a = bigint</span><br><span class="line">1919810n</span><br></pre></td></tr></table></figure>

<p>请注意，使用<code>BigInt()</code>函数时，只能传入值为整数的参数或可以隐式类型转换为整数的参数，否则将会抛出异常。</p>
<h3 id="6-绝对全局对象"><a href="#6-绝对全局对象" class="headerlink" title="(6) 绝对全局对象"></a><strong>(6) 绝对全局对象</strong></h3><p>有时我们希望能够在一个普通的函数中访问到当前运行环境对象。为了更方便地获取该对象，ES11标准定义了一个绝对全局对象<code>globalThis</code> 。</p>
<p>需要注意的是，在浏览器环境下<code>this === globalThis</code>的值是<code>true</code> ，而Node.js环境下则是<code>false</code> 。因此此处使用浏览器进行演示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this === globalThis is&quot;</span>, <span class="variable language_">this</span> === globalThis);</span></span><br><span class="line"><span class="language-javascript">    globalThis.<span class="property">a</span> = <span class="function">() =&gt;</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">a</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/04/30/ES6-ES11/5.png" alt="5" title="5"></p>
<p>可以看出二者是等价的。</p>
<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">JavaScript每年都会发布新的标准。并且随着互联网的发展，JavaScript将会有更多的功能。本文所介绍的只是已有知识的冰山一角，比如<code>Promise</code>与正则表达式，本文只是浅尝辄止未作深入。</div>
</div>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>共和国工科生
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://republicengineeringstudent.gitee.io/2022/04/30/ES6-ES11/" title="JavaScript ES6~ES11">https://republicengineeringstudent.gitee.io/2022/04/30/ES6-ES11/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://github.com/Ayanami-Daisuki">
          <span class="icon">
            <i class="fab fa-github"></i>
          </span>

          <span class="label">GitHub</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://gitee.com/RepublicEngineeringStudent">
          <span class="icon">
            <i class="fab fa-google"></i>
          </span>

          <span class="label">Gitee</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" rel="tag"><i class="fa fa-tag"></i> 计算机科学</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> 编程语言</a>
              <a href="/tags/JavaScript%E8%BF%9B%E9%98%B6/" rel="tag"><i class="fa fa-tag"></i> JavaScript进阶</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/23/VueGrammar03/" rel="prev" title="Vue基础（三）">
                  <i class="fa fa-chevron-left"></i> Vue基础（三）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/19/JavaScriptPromise/" rel="next" title="JavaScript Promise技术">
                  JavaScript Promise技术 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-scale-balanced"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">共和国工科生</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">309k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:41</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="/lib/pangu/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="/lib/hexo-generator-searchdb/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-7wT34TI0pEBeEFoi4z+vhuSddGh6vUTMWdqJ2SDe2jg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"/lib/mathjax/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
