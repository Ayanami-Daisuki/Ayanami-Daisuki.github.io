<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ajax入门</title>
    <url>/2022/04/22/Ajax/</url>
    <content><![CDATA[<img src="/2022/04/22/Ajax/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有HTML和JavaScript基础，并且最好有计算机网络基础。</div>
</div>

<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>什么是Ajax？Ajax就是应用于Web页面的异步JavaScript。此博客就采用了Ajax技术，因此可以做到点击网页进行跳转时并不重新渲染整个页面，而只是按需加载需要的部分，即无刷新加载。Ajax技术很大程度上能够减少网页的重复加载，提高复用性，减少网络流量，加快加载速度。<del>然而这个博客加载还是慢，当然这不能怪Ajax，都是CDN不稳定和图片太大造成的。<del></del></del></p>
<p>生活中常见的Ajax例子就是搜索引擎的搜索候选，网页既没有重新加载，也没有提交表单，却能够即时显示搜索候选项。其原理就是网页中的JavaScript在用户输入的时候异步向服务器发送请求，等服务器返回数据后，本地的JavaScript更新部分HTML页面，显示搜索候选项。</p>
<h2 id="二、前置"><a href="#二、前置" class="headerlink" title="二、前置"></a><strong>二、前置</strong></h2><h3 id="1-安装Express-js"><a href="#1-安装Express-js" class="headerlink" title="(1) 安装Express.js"></a><strong>(1) 安装<code>Express.js</code></strong></h3><p>因为Ajax是异步向服务端请求数据，因此就需要维护一个本地服务器。最好的解决方案，就是Node.js搭配<code>Express.js</code>模块。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install express -g</span></span><br></pre></td></tr></table></figure>

<p>在控制台中执行上述代码以全局安装<code>Express.js</code>模块。没有安装Node.js？找不到<code>npm</code>命令？很抱歉这不是本文要解决的问题，与Node.js相关的问题详情请查看 <a class="btn" href="https://Node.js.org/zh-cn/ ">Node.js官网</a> 或自行搜索教程。</p>
<h3 id="2-启动服务器"><a href="#2-启动服务器" class="headerlink" title="(2) 启动服务器"></a><strong>(2) 启动服务器</strong></h3><p><code>Express.js</code>模块可以搭建一个简易的服务器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告诉 Node.js ，该文件依赖 Express.js 模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个服务器对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Server</span> = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有浏览器请求根目录时，返回一个响应</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">Request, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启服务器，并监听 8080 端口</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Server activated on http://127.0.0.1:8080 .&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在控制台中执行上述代码：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Server.js</span></span><br><span class="line">Server activated on http://127.0.0.1:8080 .</span><br></pre></td></tr></table></figure>

<p>打开此网页，可以看到：</p>
<p><img src="/2022/04/22/Ajax/1.png" alt="1" title="1"></p>
<p>我们并没有传输任何HTML文件，但网页中却成功展示了被<code>&lt;h1&gt;</code>标签包围的 “Hello, world!” 文字。利用此技术既可以实现动态网页，也可以完成Ajax的请求。</p>
<h3 id="3-创建网页"><a href="#3-创建网页" class="headerlink" title="(3) 创建网页"></a><strong>(3) 创建网页</strong></h3><p>随随便便写个简单网页就行，为了方便与精简，就HTML、JavaScript混一块写了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略部分代码，主要是 &lt;head&gt; 标签内的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 编写 JavaScript --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 为按钮绑定事件</span></span></span><br><span class="line"><span class="language-javascript">        button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span></span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将文件保存，并记住它的目录。在上述的例子中已经提到了，以字符串形式保存的HTML通过<code>send()</code>函数发送给客户端后，客户端会以HTML的格式而不是纯字符串的形式进行解析。那么自然而然就会想到，通过文件流，以字符串形式读取 <code>.html</code>文件，再将其以字符串形式发送给客户端，就能完成传输网页。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 告诉 Node.js ，该文件需要文件流</span></span><br><span class="line"><span class="comment">// fs 模块是 Node.js 自带的，无需额外安装</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">File</span> = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Server</span> = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求主页时的响应</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步读取文件</span></span><br><span class="line">    <span class="title class_">File</span>.<span class="title function_">readFile</span>(<span class="string">&quot;Main.html&quot;</span>, <span class="function">(<span class="params"><span class="built_in">Error</span>, Data</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Error</span> !== <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Error</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="title class_">Data</span>.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Server activated on http://127.0.0.1:8080 .&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行上述代码，可以在你的浏览器里查看到一个简略的网页。这样，用于学习Ajax的页面就搭建好了。</p>
<h2 id="三、原生JavaScript实现"><a href="#三、原生JavaScript实现" class="headerlink" title="三、原生JavaScript实现"></a><strong>三、原生JavaScript实现</strong></h2><p>Ajax是一种技术名称而不是一个模块。有许多模块都能实现Ajax的功能，并且JavaScript本身也能实现。这里就循序渐进，先从不含模块的纯JavaScript实现Ajax讲起。因为模块实现Ajax，其实就是对纯JavaScript的Ajax功能的封装。</p>
<h3 id="1-XMLHttpRequest"><a href="#1-XMLHttpRequest" class="headerlink" title="(1) XMLHttpRequest"></a><strong>(1) <code>XMLHttpRequest</code></strong></h3><p><code>XMLHttpRequest</code>是一个在<code>window</code>对象下的构造函数。也就是说它可以在用于网页交互行为上的JavaScript里直接使用。该构造函数的实例，就是一个对服务器发起请求的对象。利用它可以完成异步JavaScript交互。</p>
<p>更改上述 <code>.html</code>文件中<code>&lt;button&gt;</code>的点击事件行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建新的请求对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Request</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定请求的方式与请求的地址</span></span><br><span class="line">    <span class="comment">// 请求方式一般为 GET 和 POST</span></span><br><span class="line">    <span class="comment">// 请注意请求的地址。该地址可以简写为 /test</span></span><br><span class="line">    <span class="title class_">Request</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://127.0.0.1:8080/test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="title class_">Request</span>.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当请求状态改变时，调用此回调函数</span></span><br><span class="line">    <span class="title class_">Request</span>.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Request</span>.<span class="property">readyState</span> !== <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="number">200</span> &lt;= <span class="title class_">Request</span>.<span class="property">status</span> &amp;&amp; <span class="title class_">Request</span>.<span class="property">status</span> &lt; <span class="number">300</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在控制台输出响应报文的报文头与报文体</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Request</span>.<span class="title function_">getAllResponseHeaders</span>());</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Request</span>.<span class="property">response</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>请求对象的<code>onreadystatechange</code>回调函数会在请求的状态改变时自动调用。请求状态，也就是请求对象的<code>readyState</code>属性。该属性有5个值：</p>
<ul>
<li>0：未初始化状态</li>
<li>1：已初始化（执行<code>open()</code>函数）</li>
<li>2：已发送请求（执行<code>send()</code>函数）</li>
<li>3：开始收到来自服务端的请求</li>
<li>4：来自服务端的请求接收完毕</li>
</ul>
<p>学过计算机网络的同学应该知道，HTTP请求的常见响应代号有200，302，404，500等。其中，200~299之间的响应代号表示服务器接受客户端的请求并发回了数据。因此当<code>Request.status</code>处于这一区间时，就应表明来自服务器的数据已经发送过来了。发送的数据，位于请求对象的<code>response</code>属性下。</p>
<h3 id="2-编写后端响应"><a href="#2-编写后端响应" class="headerlink" title="(2) 编写后端响应"></a><strong>(2) 编写后端响应</strong></h3><p>虽然前端的请求编写完毕了，但是后端的响应还没有编写完成。因此需要追加来自后端的响应代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置请求 /test 时的响应</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在响应头中追加一段信息</span></span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应信息</span></span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;button onclick=&#x27;alert(\&quot;干啥咧\&quot;);&#x27;&gt;按钮&lt;/button&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行上述代码，在浏览器中点击按钮，打开浏览器的控制台：</p>
<p><img src="/2022/04/22/Ajax/2.png" alt="2"></p>
<p>可以看到报文头信息与接收到的来自服务端的信息都能成功接收。那么再稍微改变一下前端的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Request</span>.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Request</span>.<span class="property">readyState</span> !== <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="number">200</span> &lt;= <span class="title class_">Request</span>.<span class="property">status</span> &amp;&amp; <span class="title class_">Request</span>.<span class="property">status</span> &lt; <span class="number">300</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        console.log(Request.getAllResponseHeaders());</span></span><br><span class="line"><span class="comment">        console.log(Request.response);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 HTML 的 &lt;div&gt; 元素</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置其内部的 HTML 文本</span></span><br><span class="line">    temp.<span class="property">innerHTML</span> = <span class="title class_">Request</span>.<span class="property">response</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其插入真实 HTML 文本中</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;body&quot;</span>).<span class="title function_">appendChild</span>(temp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重新执行上述代码，点击网页中的按钮，在网页没有刷新的情况下出现了第二个按钮，点击第二个按钮，结果如下图：</p>
<p><img src="/2022/04/22/Ajax/3.png" alt="3"></p>
<p>功能与预期完全一致。这就是Ajax。</p>
<h3 id="3-GET与POST请求"><a href="#3-GET与POST请求" class="headerlink" title="(3) GET与POST请求"></a><strong>(3) GET与POST请求</strong></h3><p>上文已经提到了，来自客户端的请求一般有GET与POST两种。前者往往是用于获取网页，可以是明文通讯；后者往往用于提交表单（包含参数），一般是加密通讯。使用Node.js + Express.js的服务端接受的请求当然也会包含这两种。但这两种请求要分别处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理 GET 请求</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;button onclick=&#x27;alert(\&quot;干啥咧\&quot;);&#x27;&gt;按钮&lt;/button&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 POST 请求</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">post</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;button onclick=&#x27;alert(\&quot;干啥咧\&quot;);&#x27;&gt;按钮&lt;/button&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理任意请求，与上面两者不兼容</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">all</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;button onclick=&#x27;alert(\&quot;干啥咧\&quot;);&#x27;&gt;按钮&lt;/button&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其实就是调用的方法改变了一下而已，大体结构并没有任何改变。请求同一地址的POST与GET请求的响应可以同时存在。POST与GET不同之处在于，POST的响应往往要处理一下前端提交的数据，然后根据这些数据来给出响应。</p>
<h3 id="4-通过POST提交数据"><a href="#4-通过POST提交数据" class="headerlink" title="(4) 通过POST提交数据"></a><strong>(4) 通过POST提交数据</strong></h3><p>在前端提交POST数据有两种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种：显式地在网址中加入数据，这些数据位于请求行中</span></span><br><span class="line"><span class="title class_">Request</span>.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://127.0.0.1:8849/test?a=114514&quot;</span>);</span><br><span class="line"><span class="title class_">Request</span>.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：隐式地提交数据，这些数据位于请求体中</span></span><br><span class="line"><span class="title class_">Request</span>.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://127.0.0.1:8849/test&quot;</span>);</span><br><span class="line"><span class="title class_">Request</span>.<span class="title function_">send</span>(<span class="string">&quot;114514&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中，第一种是很常见的动态网页提交数据的方法。使用百度搜索引擎时，你经常能看到网址里的 “?” 后有一大串看不懂的字符。这些就是浏览器向百度服务器提交的表单数据，即搜索关键字。</p>
<p>在服务端中，使用以下代码就能够查看来自客户端的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Server</span>.<span class="title function_">post</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">Request, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 查看第一种方式提交的数据</span></span><br><span class="line">    <span class="comment">// 其值是对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Request</span>.<span class="property">query</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看第二种方式提交的数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Request</span>.<span class="property">body</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;button onclick=&#x27;alert(\&quot;干啥咧\&quot;);&#x27;&gt;按钮&lt;/button&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>打印出的<code>Request.body</code>值为<code>undefined</code></strong></div>

<div style="color:goldenrod;">这是因为POST请求并不总是安全的，Express.js默认屏蔽了POST请求中的数据。要想接收数据，需要在开始配置服务端响应之前追加一行代码：</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Server</span>.<span class="title function_">use</span>(express.<span class="title function_">text</span>());</span><br></pre></td></tr></table></figure>

<div style="color:goldenrod;">该代码作用为以文本形式解析POST请求体。当然还能以其他形式解析，此处不做赘述。</div>
</div>

<h3 id="5-修改请求报文的头部信息"><a href="#5-修改请求报文的头部信息" class="headerlink" title="(5) 修改请求报文的头部信息"></a><strong>(5) 修改请求报文的头部信息</strong></h3><p>先回顾一下计算机网络的知识。HTTP的请求报文应符合如下格式：</p>
<blockquote>
<p>POST &#x2F;test?114514 HTTP&#x2F;1.1<br>Host: 127.0.0.1:8848<br>Cookie: 1145141919810<br>User-Agent: Microsoft Edge<br>······</p>
<p>数据</p>
</blockquote>
<p>其中，第1行为请求行，第2~4行为请求头部，第5行是必须要有的空行，第6行开始是前端发送的数据。要新增或者修改头部，请使用<code>setRequestHeader()</code>方法。该方法接受两个<code>String</code>类型的参数，前者是请求头部的 “属性名” ，后者是它的 “属性值”。该方法只能新增头部而不能修改或删除头部。</p>
<p>另外，需要注意的是，若服务端没有 “允许” 客户端发送含有自定义的请求头部的报文，那么所有添加了自定义头部信息的请求都<span style="color:red;">有可能</span>在前端被拒绝发送。想要 “允许” 使用自定义请求头部，需要在服务端中修改代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前端尝试发送请求时会先以 OPTIONS 方法询问后端是否接受自定义头部</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">options</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置响应头部，允许接受任何自定义头部</span></span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">post</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;button onclick=&#x27;alert(\&quot;干啥咧\&quot;);&#x27;&gt;按钮&lt;/button&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-传递对象"><a href="#6-传递对象" class="headerlink" title="(6) 传递对象"></a><strong>(6) 传递对象</strong></h3><p>上面提到的前端接收数据的方式，都是只能接受<code>String</code>类型的值。要想接受JavaScript对象，则需要借助<code>JSON</code> 。有两种处理方式，第一种就是手动将对象转换为<code>JSON</code>格式的字符串，即在后端调用<code>JSON.stringify()</code>方法，在前端调用<code>JSON.parse()</code>方法。</p>
<p>第二种方法则在前端处理上有所不同。在前端只需要在发送请求前加上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Request</span>.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>那么前端在接收到来自后端的数据时，就会自动将其转换为对象。</p>
<h3 id="7-超时"><a href="#7-超时" class="headerlink" title="(7) 超时"></a><strong>(7) 超时</strong></h3><p>网络服务永远是不完全可靠的，因此不能保证客户端发送的请求一定能被服务端接收，也不能保证服务端的响应一定能被客户端接收。因此有必要在前端添加超时设置，以避免 “死锁” 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置超时时间</span></span><br><span class="line"><span class="title class_">Request</span>.<span class="property">timeout</span> = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当响应超时后调用的回调函数</span></span><br><span class="line"><span class="title class_">Request</span>.<span class="property">ontimeout</span> = <span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;超时&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置网络异常时的回调函数</span></span><br><span class="line"><span class="title class_">Request</span>.<span class="property">onerror</span> = <span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;网络异常&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当超时发生时，前端会自动取消请求。当然，请求也可以手动取消：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Request</span>.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure>

<h3 id="8-取消重复请求"><a href="#8-取消重复请求" class="headerlink" title="(8) 取消重复请求"></a><strong>(8) 取消重复请求</strong></h3><p>当网络延迟较高时，客户端可能无法得到及时的响应。此时多次发送相同请求，一会造成服务器额外负担，二会造成客户端浪费流量接收重复数据。因此有必要在请求发送后，超时发生前取消所有同样的请求。</p>
<p>具体思路就是设置一个全局的 “锁”，当有请求开始发送前，尝试获得这把锁，若无法获得则撤销请求；发送完成时，释放这把锁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局锁，或者叫 flag</span></span><br><span class="line"><span class="title class_">Mutex</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Request</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="title class_">Request</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://127.0.0.1:8849/test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时</span></span><br><span class="line">    <span class="title class_">Request</span>.<span class="property">timeout</span> = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 超时也释放锁</span></span><br><span class="line">    <span class="title class_">Request</span>.<span class="property">ontimeout</span> = <span class="function">() =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Mutex</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查锁的状况，可获得就发送请求，否则不发送</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Mutex</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Mutex</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="title class_">Request</span>.<span class="title function_">send</span>();</span><br><span class="line">        <span class="title class_">Request</span>.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Request</span>.<span class="property">readyState</span> !== <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 一旦接收到响应报文就释放锁</span></span><br><span class="line">                <span class="title class_">Mutex</span> = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="number">200</span> &lt;= <span class="title class_">Request</span>.<span class="property">status</span> &amp;&amp; <span class="title class_">Request</span>.<span class="property">status</span> &lt; <span class="number">300</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">            temp.<span class="property">innerHTML</span> = <span class="title class_">Request</span>.<span class="property">response</span>;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;body&quot;</span>).<span class="title function_">appendChild</span>(temp);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="9-fetch"><a href="#9-fetch" class="headerlink" title="(9) fetch()"></a><strong>(9) <code>fetch()</code></strong></h3><p>该函数是定义在<code>window</code>对象下的函数，即该函数可以直接在前端JavaScript中直接使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数接受两个参数，请求地址和配置对象</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://127.0.0.1/test&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,     <span class="comment">// 设置请求方式</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&quot;&quot;</span>            <span class="comment">// 设置请求体（字符串格式）</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收到响应时，调用回调函数</span></span><br><span class="line">    <span class="comment">// 返回值为以字符串形式处理响应数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Response</span>.<span class="title function_">text</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印处理结束的响应数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fetch()</code>函数相比之前的处理方式，虽然简化了不少，但仍然略显繁琐？那不妨试试jQuery或者Axios。</p>
<h2 id="四、jQuery的实现"><a href="#四、jQuery的实现" class="headerlink" title="四、jQuery的实现"></a><strong>四、jQuery的实现</strong></h2><p>jQuery作为一个强大的JavaScript库，自然也封装了Ajax相关的操作，并且其功能相当简洁而强大（缺点就是这个库本身是重量级选手，不过相比起现在的网速，这根本不算什么）。</p>
<p>在开始之前应当先配置好jQuery的环境。可以使用CDN，也可以使用本地的jQuery。不过后者要麻烦一点，因为当使用本地的jQuery时，浏览器解析到使用了JavaScript文件时会向服务器请求此文件。如果使用CDN，请求的就是远程服务器，与我们无关；而是用本地JavaScript文件，则需要在服务端中追加一点点代码，思路与传输HTML文件是一致的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    此处我的 jQuery 文件与 HTML 文件处在同一路径下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/jquery.js&quot;</span>, <span class="function">(<span class="params">_, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 读取 jQuery 文件，并发送至前端</span></span><br><span class="line">    <span class="title class_">File</span>.<span class="title function_">readFile</span>(<span class="string">&quot;jquery.js&quot;</span>, <span class="function">(<span class="params"><span class="built_in">Error</span>, Data</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Error</span> !== <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Error</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="title class_">Data</span>.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="1-get"><a href="#1-get" class="headerlink" title="(1) $.get()"></a><strong>(1) <code>$.get()</code></strong></h3><p>其实使用GET方法也能从前端向后端发送数据，但只能将数据放在请求行内。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取 button 元素，并设置点击事件</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="function">() =&gt;</span></span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 发送 GET 请求</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 参数：请求地址、发送的数据（对象）、传回数据时的回调函数</span></span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8849/test?c=1919&quot;</span>, &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="number">514</span> &#125;, <span class="function">(<span class="params">Info</span>) =&gt;</span></span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 打印传回的数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Info</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和原生的相比起来简洁了不少。后端实现不需要做任何修改，但我们想看看后端有没有接收到数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">Request, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Request</span>.<span class="property">query</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Request</span>.<span class="property">body</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">&quot;&lt;button onclick=&#x27;alert(\&quot;干啥咧\&quot;);&#x27;&gt;按钮&lt;/button&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>前端的控制台输出为：</p>
<p><img src="/2022/04/22/Ajax/4.png" alt="4" title="4"></p>
<p>后端的控制台输出为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Server.js</span></span><br><span class="line">Server activated on http://127.0.0.1:8849 .</span><br><span class="line">&#123; c: &#x27;1919&#x27;, a: &#x27;114&#x27;, b: &#x27;514&#x27; &#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，jQuery的GET请求发送的数据是位于请求行中的。此外，还可以在回调函数后再加一个<code>String</code>类型的参数，该参数表明响应数据是什么格式的。不填就默认是字符串，可以填入 “json” 以直接将收到的数据解析为对象。</p>
<h3 id="2-post"><a href="#2-post" class="headerlink" title="(2) $.post()"></a><strong>(2) <code>$.post()</code></strong></h3><p>该方法与<code>get()</code>方法的使用方法完全一致，但结果不同。修改前端的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="function">() =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 更改为 POST 请求</span></span><br><span class="line">    $.<span class="title function_">post</span>(<span class="string">&quot;http://127.0.0.1:8849/test?c=1919&quot;</span>, &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="number">514</span> &#125;, <span class="function">(<span class="params">Info</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Info</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>前端控制台的输出不变，但后端的控制台输出却不一样：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Server.js</span></span><br><span class="line">Server activated on http://127.0.0.1:8849 .</span><br><span class="line">&#123; c: &#x27;1919&#x27; &#125;</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Request.body</code> 竟然为空。这是因为在服务端中缺少配置项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原有的，以文本形式解析请求体数据</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">use</span>(express.<span class="title function_">text</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新加的，以处理 URL 编码的形式解析请求体数据</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br></pre></td></tr></table></figure>

<p>追加上述代码以后，服务端控制台将会打印：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Server.js</span></span><br><span class="line">Server activated on http://127.0.0.1:8849 .</span><br><span class="line">&#123; c: &#x27;1919&#x27; &#125;</span><br><span class="line">[Object: null prototype] &#123; a: &#x27;114&#x27;, b: &#x27;514&#x27; &#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>URL编码</strong></div>

<div style="color:royalblue;">URL编码是为了方便传输带有歧义的字符（如 “\” 等）而使用的一种编码方式。详情请参见 <a class="btn" href="https://baike.baidu.com/item/URL%E7%BC%96%E7%A0%81/3703727 ">百度百科-URL编码</a></div>
</div>

<h3 id="3-ajax"><a href="#3-ajax" class="headerlink" title="(3) $.ajax()"></a><strong>(3) <code>$.ajax()</code></strong></h3><p>这是jQuery提供的通用的向服务端发送请求的方法。它的参数为一个配置对象。常见的配置对象属性如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8849/test&quot;</span>,  <span class="comment">// 目标地址</span></span><br><span class="line">    <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="number">514</span> &#125;,           <span class="comment">// 要发送的数据</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;&#125;,                        <span class="comment">// 自定义请求头</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,                        <span class="comment">// 请求方法</span></span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,                   <span class="comment">// 返回数据的类型</span></span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">Data</span>) =&gt;</span>                  <span class="comment">// 成功返回数据后要执行的回调函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">5000</span>,                      <span class="comment">// 超时判定时间</span></span><br><span class="line">    <span class="attr">error</span>: <span class="function">() =&gt;</span> &#123;&#125;                     <span class="comment">// 错误发生时的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处错误发生包含超时、请求被拒绝、无网络、返回数据解析出错等</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="五、Axios的实现"><a href="#五、Axios的实现" class="headerlink" title="五、Axios的实现"></a><strong>五、Axios的实现</strong></h2><p>Axios库是Vue作者推荐的适合与Vue搭配开发异步交互网页的第三方库。Vue本身不支持异步JavaScript，但它可以与第三方库搭配。由于jQuery的目标是操作HTML，而Vue的目标是减少对HTML的操作。因此二者的互相可替代性很大，也因此不推荐Vue搭配jQuery，因为这样很臃肿。</p>
<p><del>不过诸如做实验的时候老师要求使用前端框架可以加分这种情况，什么Vue、jQuery、Axios、React嗯塞就完事了，管他臃不臃肿兼不兼容，哪怕我只用某个框架写了一行代码那也是用。</del></p>
<p>Axios可以设置默认的链接地址：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&quot;http://127.0.0.1:8849&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>之后的请求就不需要再写完整的路径，只需要写像<code>/text</code>一样的相对地址即可。</p>
<h3 id="1-axios-get"><a href="#1-axios-get" class="headerlink" title="(1) axios.get()"></a><strong>(1) <code>axios.get()</code></strong></h3><p>Axios与jQuery的请求方式很像，但参数不一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;/test&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置请求行中的数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置自定义请求头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收到响应后执行的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里接收到的<code>Data</code>不是返回的数据，而是一个对象，返回的数据位于它的<code>data</code>属性下。</p>
<p><img src="/2022/04/22/Ajax/5.png" alt="5" title="5"></p>
<h3 id="2-axios-post"><a href="#2-axios-post" class="headerlink" title="(2) axios.post()"></a><strong>(2) <code>axios.post()</code></strong></h3><p>该方法用于发起POST请求。相比<code>axios.get()</code> ，它的参数中多了一个请求体数据的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;/test&quot;</span>, &#123; <span class="comment">/* 请求体数据 */</span> &#125;, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置请求行中的数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置自定义请求头</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接收到响应后执行的回调函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-axios"><a href="#3-axios" class="headerlink" title="(3) axios()"></a><strong>(3) <code>axios()</code></strong></h3><p>该函数为通用的发送请求的函数。它接受一个对象作为配置对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/test&quot;</span>,       <span class="comment">// 设置请求链接</span></span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,     <span class="comment">// 设置请求方式</span></span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置请求行</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置请求头</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="comment">// 设置请求体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印返回的数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>.<span class="property">data</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="六、同源策略与跨域"><a href="#六、同源策略与跨域" class="headerlink" title="六、同源策略与跨域"></a><strong>六、同源策略与跨域</strong></h2><p>上文所述的请求方式，都是需要完整的链接的，即必须指定前缀 “<a href="http://127.0.0.1:8849/">http://127.0.0.1:8849</a>” 。这就说明，使用Ajax请求链接时，可以请求不同域名的链接。但这对于一般用户来说是很危险的。所以目前一般遵循的规则是同源策略：Ajax请求目标的协议、域名、端口必须与此网页的协议、域名、端口完全相同。</p>
<p>但实际生产中，完全遵循同源策略是不可能的。一个有众多用户的网站可能在同一时间要为成千上万的用户提供服务，一台服务器可能很难胜任。多台服务器一起提供服务是个不错的选择，即，采用Ajax技术分别从不同的服务器加载不同部分的网页，而采用这种方式就必须违背同源策略，这就是跨域。</p>
<p>对于同源的资源，在请求时可以简写，不写协议、域名和端口。而跨域的请求则不能简写。</p>
<h3 id="1-原理与原生实现"><a href="#1-原理与原生实现" class="headerlink" title="(1) 原理与原生实现"></a><strong>(1) 原理与原生实现</strong></h3><p>虽说同源策略限制得很死，但也不是没有漏洞可以钻。HTML中的一些元素是允许跨域请求的，例如<code>&lt;script&gt;</code>标签，该标签可以跨域请求JavaScript脚本资源。</p>
<p>上文曾经提到了，请求本地的jQuery文件应该怎样处理。通过文件流，以字符串的方式发送JavaScript脚本。不难想到，处理方式可以是先在前端编写好处理函数，当通过<code>&lt;script&gt;</code>标签发起请求时，服务端做出判断后，传回调用前端函数的JavaScript文本。这种做法的缺点是，只能发起GET请求。</p>
<p>前端部分代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 编写后端要调用的函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">Handler</span>(<span class="params">Element</span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 代码功能：向网页中插入一个 &lt;h1&gt; 标签</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> temp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            temp.<span class="property">innerHTML</span> = <span class="title class_">Element</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;body&quot;</span>).<span class="title function_">appendChild</span>(temp);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过 &lt;script&gt; 标签发起请求 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端部分代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">Request, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="string">&quot;&#x27;测试&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试调用前端的函数</span></span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">`Handler(<span class="subst">$&#123;temp&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>网页展示结果为：</p>
<p><img src="/2022/04/22/Ajax/6.png" alt="6" title="6"></p>
<p>可以看见网页源代码中并没有展示 “测试” 的代码。该元素是Ajax技术即时生成的。</p>
<p>因此，在跨域发起Ajax请求时，可以在前端代码中编写向HTML中插入<code>&lt;script&gt;</code>标签的方式来控制什么时候发起Ajax请求。</p>
<h3 id="2-jQuery的实现"><a href="#2-jQuery的实现" class="headerlink" title="(2) jQuery的实现"></a><strong>(2) jQuery的实现</strong></h3><p>jQuery的实现相比原生实现要简单得多。jQuery的<code>$</code>下还定义了一个<code>getJSON()</code>函数。该函数接受两个参数：一个请求地址和一个回调函数。</p>
<p>前端代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里有两个 “?” 并且传了一个 callback 参数</span></span><br><span class="line"><span class="comment">// 这是 jQuery 的特殊写法，它会自动生成回调函数名并用其替换第二个 “?”</span></span><br><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&quot;http://127.0.0.1:8849/test?callback=?&quot;</span>, <span class="function">(<span class="params">Data</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>后端代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Server</span>.<span class="title function_">get</span>(<span class="string">&quot;/test&quot;</span>, <span class="function">(<span class="params">Request, Response</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="string">&quot;&#x27;测试&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取回调函数名</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Callback</span> = <span class="title class_">Request</span>.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回传执行回调函数的代码</span></span><br><span class="line">    <span class="title class_">Response</span>.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;Callback&#125;</span>(<span class="subst">$&#123;temp&#125;</span>);`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过将回调函数名传递给服务端的方式来动态调用前端的回调函数也是一种不错的设计，这种方式在原生JavaScript实现中也可以使用。</p>
<h3 id="3-服务端实现"><a href="#3-服务端实现" class="headerlink" title="(3) 服务端实现"></a><strong>(3) 服务端实现</strong></h3><p>现在的同源策略一般不是由本地的浏览器执行的，而是远程服务器执行的。当出现跨域请求时，浏览器会先向服务器以OPTIONS的方式发送一个请求以查看服务器是否允许跨域。如果服务器返回的报文头部中含有<code>Access-Control-Allow-Origin: *</code>（允许所有跨域，当然只允许部分也是可以的），那么浏览器才会发起跨域请求，否则将不发起请求。</p>
<p>报文头中的<code>Access-Control-Allow-Origin: *</code>，其值可以不为<code>*</code>，但应该是允许发起跨域请求的网页的地址（含http或https）。</p>
<p>另外，经常用到的响应头还有<code>Access-Control-Allow-Headers</code>、<code>Access-Control-Allow-Method</code>。它们分别是允许的自定义报文头部、允许的请求方式。</p>
<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">其实上述Ajax技术还只是冰山一角，只看完Axios的配置对象的参数都足够折腾一阵子了，更别提各种各样的报文头部。但这些终究是工具，对于一个使用这些工具的程序员来说，有没有必要学习如何使用它，还得看个人需求。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>JavaScript库</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络原理</title>
    <url>/2022/01/18/ConvolutionalNeuralNetworkPrinciple/</url>
    <content><![CDATA[<img src="/2022/01/18/ConvolutionalNeuralNetworkPrinciple/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有神经网络学习基础。</div>
</div>

<span id="more"></span>

<h2 id="卷积核（Kernel）"><a href="#卷积核（Kernel）" class="headerlink" title="卷积核（Kernel）"></a><strong>卷积核（Kernel）</strong></h2><p>卷积操作需要用到的玩意。如下图，阴影为卷积核，蓝色为原始图像，绿色为卷积后图像。卷积核常见大小有3×3或5×5。</p>
<p><img src="/2022/01/18/ConvolutionalNeuralNetworkPrinciple/Convolution.gif" alt="Convolution 卷积操作" title="卷积操作"></p>
<h2 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a><strong>卷积操作</strong></h2><p>上图所示即为卷积操作，其结果类似于降采样。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>降采样</strong></div>

<div style="color:royalblue;">简单来说就是降低图像的质量但是不会丢失图像的基本特征，图像糊了但是还是看得清画的是啥。（对于计算机而言的“看得清”，并且提取的特征可以多样化：颜色特征、线条几何特征等。）</div>
</div>

<p>具体操作为将卷积核“放在”原始图像上，并将每格重叠的像素点的值相乘后依次相加，最终的值填入处理后图像对应的像素点，再将卷积核向右或向下移动，最终处理完整个原始图像。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>神经网络中的卷积核</strong></div>

<div style="color:royalblue;">在CNN中，卷积核并不需要设计者自行设置。CNN将卷积核看作了神经网络的结点，将卷积核每个像素点的值看成了神经网络中的每个结点参数。因此只需要等算法自己执行反向传播，即可优化卷积核的像素值。</div>
</div>

<h2 id="填充（Padding）"><a href="#填充（Padding）" class="headerlink" title="填充（Padding）"></a><strong>填充（Padding）</strong></h2><p>若要维持原图像大小不变，需要在原图像周围填充一圈像素，即为上图的白色区域。填充可以是0也可以是255。</p>
<h2 id="步长（Stride）"><a href="#步长（Stride）" class="headerlink" title="步长（Stride）"></a><strong>步长（Stride）</strong></h2><p>卷积操作时，在进行完一次处理后的图像的像素点值的计算时，卷积核将会向右或向下移动，移动的像素格数量即为步长。步长越长，卷积后的图像就会越小。一般设置为1。</p>
<h2 id="池化（Pooling）"><a href="#池化（Pooling）" class="headerlink" title="池化（Pooling）"></a><strong>池化（Pooling）</strong></h2><p>与卷积操作类似，不过比卷积更简单。<br>池化一般有平均池化和最大池化。<br>选取一个类似于卷积核的池化核，若为平均池化则计算池化核内所有像素点的平均值，填入池化后图像。若为最大池化，则直接将池化核内最大的像素值填入池化后图像。</p>
<h2 id="卷积后的图像大小计算公式"><a href="#卷积后的图像大小计算公式" class="headerlink" title="卷积后的图像大小计算公式"></a><strong>卷积后的图像大小计算公式</strong></h2><p>$$<br>\frac{原始图像边长+2×填充宽度-卷积核边长}{步长}+1<br>$$</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>CNN</tag>
        <tag>机器学习</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>C#语法基础（一）</title>
    <url>/2022/01/18/CsharpGrammar01/</url>
    <content><![CDATA[<img src="/2022/01/18/CsharpGrammar01/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议先学习C++基础再进行C#的学习。</div>
</div>

<span id="more"></span>

<h2 id="一、C-简介"><a href="#一、C-简介" class="headerlink" title="一、C#简介"></a><strong>一、C#简介</strong></h2><p>C#有三大平台：</p>
<ul>
<li>.NET Framework</li>
<li>.NET Core</li>
<li>Xamarin</li>
</ul>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>各个平台的特性</strong></div>

<div style="color:royalblue;">.NET Framework是旧技术，仅适用于Windows平台，为了维持兼容性将不会有重大更新；.NET Core是新技术，跨平台，将是未来Microsoft主要的投入方向；Xamarin是第三方的，可以跨平台。主要应用于Unity。</div>
</div>

<p>未来Microsoft会将主要精力投入 .NET Core 而非 .NET Framework ，并且自 .NET Core 5.0 开始正式更名为 .NET 5.0 ，它相比 .NET Framework 更加灵活。目前，2022年， .NET 已经到了6.0版本。</p>
<h3 id="NET跨平台工作原理"><a href="#NET跨平台工作原理" class="headerlink" title=".NET跨平台工作原理"></a><strong>.NET跨平台工作原理</strong></h3><p>跨平台原理与Java类似，在程序与操作系统之间隔了一层虚拟机。</p>
<ol>
<li>编译时<br>.NET CLI工具使用的C#编译器名为Roslyn，它将C#的源代码转换为中间语言代码，并将之存放在.dll或者.exe文件中。</li>
<li>加载时<br>.NET Core的虚拟机CoreCLR从文件中加载代码，再由即时编译器将之编译为本机CPU指令。</li>
<li>运行时<br>运行时由本机CPU运行即时编译器编译后的CPU指令。</li>
</ol>
<p>.NET拥有CLR（公共语言运行库）和BCL（基类库），前者负责代码的执行，后者提供丰富的类以构建应用程序。</p>
<h2 id="二、C-基础语法"><a href="#二、C-基础语法" class="headerlink" title="二、C#基础语法"></a><strong>二、C#基础语法</strong></h2><h3 id="1-Hello-world！"><a href="#1-Hello-world！" class="headerlink" title="(1) Hello,world！"></a><strong>(1) Hello,world！</strong></h3><h4 id="Ⅰ-在vscode上配置好C-环境"><a href="#Ⅰ-在vscode上配置好C-环境" class="headerlink" title="Ⅰ. 在vscode上配置好C#环境"></a><strong>Ⅰ. 在vscode上配置好C#环境</strong></h4><p>关于如何配置环境，请参见网络上的方法，此处不再赘述。</p>
<h4 id="Ⅱ-在C-文件夹下新建一个文件夹，命名为Hello"><a href="#Ⅱ-在C-文件夹下新建一个文件夹，命名为Hello" class="headerlink" title="Ⅱ. 在C#文件夹下新建一个文件夹，命名为Hello"></a><strong>Ⅱ. 在C#文件夹下新建一个文件夹，命名为Hello</strong></h4><p><img src="/2022/01/18/CsharpGrammar01/1.png" alt="1 1" title="1"></p>
<h4 id="Ⅲ-在终端中打开这个文件夹"><a href="#Ⅲ-在终端中打开这个文件夹" class="headerlink" title="Ⅲ. 在终端中打开这个文件夹"></a><strong>Ⅲ. 在终端中打开这个文件夹</strong></h4><h4 id="Ⅳ-在终端中输入"><a href="#Ⅳ-在终端中输入" class="headerlink" title="Ⅳ. 在终端中输入"></a><strong>Ⅳ. 在终端中输入</strong></h4><figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet new console</span></span><br></pre></td></tr></table></figure>

<p>通过这个命令可以自动在该文件夹下创建C#工程。</p>
<h4 id="Ⅴ-设置-csproj文件"><a href="#Ⅴ-设置-csproj文件" class="headerlink" title="Ⅴ. 设置.csproj文件"></a><strong>Ⅴ. 设置.csproj文件</strong></h4><p>因为我的文件夹名为Hello，所以生成的C#配置文件默认为Hello.csproj。打开Hello.csproj。</p>
<p><img src="/2022/01/18/CsharpGrammar01/2.png" alt="2 2" title="2"></p>
<p>删除上图中高亮的代码部分，即</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImplicitUsings</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">ImplicitUsings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>隐式命名空间</strong></div>

<div style="color:royalblue;">这段代码是.NET 6.0的新特性之一：隐式命名空间引用。启用了这个选项以后，C#的语法就可以像脚本一样书写。但是为了更好地学习C#，我们需要关闭这个选项。</div>
</div>

<h4 id="Ⅵ-编写C-代码"><a href="#Ⅵ-编写C-代码" class="headerlink" title="Ⅵ. 编写C#代码"></a><strong>Ⅵ. 编写C#代码</strong></h4><p>按如下格式重构Program.cs文件中的内容。（此处我将Program.cs重命名为了Hello.cs）</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;  <span class="comment">//使用System命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MainProgram</span>  <span class="comment">//[1]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MainProcess</span>  <span class="comment">//[2]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()  <span class="comment">//[3]</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello,world!&quot;</span>);  <span class="comment">//[4]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note default"><div style="color:dimgray;font-size:1.5em;"><strong>代码的注释</strong></div>

<div style="color:dimgray;">
[1] 用户自定义的命名空间。只要不使用C#关键字，名字随便选。<br>
[2] 用户自定义的类。只要不使用C#关键字，名字随便选。<br>
[3] 和C/C++一样，主函数名称必须为Main()，要注意大小写，且必须为static类型。返回值可以为int，但记得写return 0;。<br>
[4] 控制台打印Hello,world并换行。
</div>
</div>

<p>为什么需要这么写，下文再详述。</p>
<h4 id="Ⅶ-编译并运行"><a href="#Ⅶ-编译并运行" class="headerlink" title="Ⅶ. 编译并运行"></a><strong>Ⅶ. 编译并运行</strong></h4><p>在终端中输入</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br></pre></td></tr></table></figure>

<p>C#编译器将会对源文件进行编译并生成可执行文件。</p>
<p>控制台的输出应该为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">Hello,world!</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<p>.exe文件的位置应该处于&#x2F;Hello&#x2F;bin&#x2F;Debug&#x2F;net6.0下。其全名应该为Hello.exe。</p>
<p>你可以尝试在Hello.exe所在的文件夹打开powershell，输入</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">.\Hello.exe</span></span><br></pre></td></tr></table></figure>

<p>其执行结果应该为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">.\Hello.exe</span></span><br><span class="line">Hello,world!</span><br></pre></td></tr></table></figure>

<h3 id="2-Hello，world-的原理概述"><a href="#2-Hello，world-的原理概述" class="headerlink" title="(2) Hello，world!的原理概述"></a><strong>(2) Hello，world!的原理概述</strong></h3><p>C#的名字源自于C++++。C++在C的基础上做了加法，增加了面向对象编程。 <del>而C#在C++的基础上做了“加法”（确信）。</del> C#按照C++的语法，以完全的面向对象思想构建了语法体系。因此学过C++的同学能看到一些很熟悉的东西。</p>
<h4 id="Ⅰ-命名空间"><a href="#Ⅰ-命名空间" class="headerlink" title="Ⅰ. 命名空间"></a><strong>Ⅰ. 命名空间</strong></h4><p>与C++的命名空间相似。不过C#没有了头文件，所有的类均在命名空间中定义。</p>
<p>要使用某一个类，要么采用</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间;</span><br><span class="line">······</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p>要么采用</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">命名空间.类</span><br></pre></td></tr></table></figure>

<p>的方式进行引用。</p>
<h4 id="Ⅱ-类"><a href="#Ⅱ-类" class="headerlink" title="Ⅱ. 类"></a><strong>Ⅱ. 类</strong></h4><p>与C++的类相似。不过C#做了静态与非静态的区分。这个之后再讲。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>暂时地理解</strong></div>

<div style="color:royalblue;">现在就先这么理解：static的类实际存在，其本身就是一个变量，可以直接使用；非static的类只是一个类型，不是变量，只能使用以这个类型创建的变量。</div>
</div>

<h4 id="Ⅲ-函数"><a href="#Ⅲ-函数" class="headerlink" title="Ⅲ. 函数"></a><strong>Ⅲ. 函数</strong></h4><p>与C++的成员函数类似。C#中没有存在于类之外的函数，所有的函数均存在类的内部。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>从C++的角度理解</strong></div>

<div style="color:royalblue;">按C++的定义，可以这么说：C#的所有函数都是成员函数。</div>
</div>

<p>并且函数也与类一样，存在静态与非静态之分。<br>所以主函数Main()需要写在类的内部，并且需要以static前缀声明。</p>
<p>和C&#x2F;C++一样，C#也只能有一个名称为Main()的函数。</p>
<p>可以做如下实验：</p>
<p>按如下方式修改你的.cs文件</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MainProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">M2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行中运行</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br></pre></td></tr></table></figure>

<p>我的报错信息为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">error CS0017: 程序定义了多个入口点。使用 /main (指定包含入口点的类型)进行编译。</span><br><span class="line"></span><br><span class="line">生成失败。请修复生成错误并重新运行。</span><br></pre></td></tr></table></figure>

<p>即：要么你指定一个Main()作为主函数，要么你换一个名字，要么编译失败。</p>
<p>并且可以有如下结论：</p>
<ol>
<li>命名空间不允许一致。</li>
<li>不同命名空间的类名允许一致</li>
<li>处于同一命名空间的类名不允许一致。</li>
<li>只要不指定主函数，Main()就只能有一个。</li>
</ol>
<h4 id="Ⅳ-Console-WriteLine"><a href="#Ⅳ-Console-WriteLine" class="headerlink" title="Ⅳ. Console.WriteLine()"></a><strong>Ⅳ. Console.WriteLine()</strong></h4><p>根据源代码与前面的解释不难推测出，Console.WriteLine()函数控制了在控制台打印”Hello,world!”。<br>其中Console为一个static类，定义在System命名空间中。因此你可以按如下方式重构源代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MainProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.Console.WriteLine(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依然可以编译成功并正确运行。</p>
<p>Console类为代表控制台的static类。使用它可以对控制台进行操作。Console类下面定义了成员函数WriteLine()。与C的printf()、C++的std::cout类似，它用于在控制台下执行打印功能并在打印结束后进行换行。若不想换行可以使用另一个成员函数Write()。</p>
<p>至此，配合C&#x2F;C++的语法知识，使用C#写出一般简单程序已经不在话下。你可以试着将你写的一些偏重于算法的简单C++代码按照C#的格式重构。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>C#语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#语法基础（二）</title>
    <url>/2022/01/18/CsharpGrammar02/</url>
    <content><![CDATA[<img src="/2022/01/18/CsharpGrammar02/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议先学习C++基础再进行C#的学习。</div>
</div>

<span id="more"></span>

<h2 id="三、C-中的变量类型"><a href="#三、C-中的变量类型" class="headerlink" title="三、C#中的变量类型"></a><strong>三、C#中的变量类型</strong></h2><h3 id="1-object"><a href="#1-object" class="headerlink" title="(1) object"></a><strong>(1) object</strong></h3><p>object是一种特殊的类型，它能够存储任何数据。但是它也存在很多局限，例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> Name=<span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> RealName=<span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> a=Name.Length;  <span class="comment">//错误：object没有Length成员</span></span><br><span class="line"><span class="built_in">int</span> b=RealName.Length;  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>由于其值的不确定性，object类也缺少了很多成员和能调用的成员函数。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>最好不要用object</strong></div>

<div style="color:goldenrod;">相比object，C#提供了另一种更好的东西——泛型。这个之后再讲。</div>
</div>

<h3 id="2-dynamic"><a href="#2-dynamic" class="headerlink" title="(2) dynamic"></a><strong>(2) dynamic</strong></h3><p>dynamic与object类似，不过dynamic能调用的要比object更多：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> Name=<span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> a=Name.Length;  <span class="comment">//正确赋值为5</span></span><br></pre></td></tr></table></figure>

<p>但是dynamic也存在局限性：</p>
<ol>
<li>dynamic型变量的自动补全往往不准确。</li>
<li>dynamic型变量调用当前值对应的类型不存在的成员时，编译器也不会报错，只会在运行时出现错误。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;Hello,world!&quot;</span>);  <span class="comment">//正确打印</span></span><br><span class="line"><span class="built_in">dynamic</span> Name=<span class="number">114514</span>;</span><br><span class="line"><span class="built_in">int</span> a=Name.Length;  <span class="comment">//正确生成.exe，但运行到此处时程序异常</span></span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">Hello,world!</span><br><span class="line">Unhandled exception. Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: &#x27;int&#x27; does not contain a definition for &#x27;Length&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="3-var"><a href="#3-var" class="headerlink" title="(3) var"></a><strong>(3) var</strong></h3><p>与C++的auto类似，var型变量是根据其初始化或者第一次赋值时值的类型来推断其类型。</p>
<h3 id="4-值类型与引用类型"><a href="#4-值类型与引用类型" class="headerlink" title="(4) 值类型与引用类型"></a><strong>(4) 值类型与引用类型</strong></h3><p>以C&#x2F;C++的方式来看，值类型就是变量，引用类型就是分配了空间的指针。函数内定义的变量在函数执行完之后，值类型会自动释放，而引用类型则需要等待垃圾回收器进行释放。</p>
<p>与C&#x2F;C++不同，C#取消了指针，这意味着它不像C++一样能够通过delete来决定什么时候释放引用类型占据的空间。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>在C#中使用指针</strong></div>

<div style="color:royalblue;">在C#中，指针可以在标记了unsafe的代码块中使用。但是仍不推荐这么做。</div>
</div>

<p>常见的引用类型有string和数组。其余的类型一般为值类型。</p>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="(5) 数组"></a><strong>(5) 数组</strong></h3><p>与C&#x2F;C++不同，C#声明数组需要用如下方式声明：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a;</span><br><span class="line"><span class="built_in">char</span>[] b;</span><br></pre></td></tr></table></figure>

<p>并且声明的变量不能直接使用，它们类似于C&#x2F;C++的指针，需要分配空间才能使用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">a=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line">b=<span class="keyword">new</span> <span class="built_in">char</span>[<span class="number">7</span>];</span><br></pre></td></tr></table></figure>

<p>因为C#中所有的数组都是引用类型，在使用数组之前必须确定其大小，不能动态改变它的大小。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>集合</strong></div>

<div style="color:royalblue;">如果想动态插入与删除，不妨试试集合。这将在之后讲到。</div>
</div>

<h2 id="四、格式化字符串"><a href="#四、格式化字符串" class="headerlink" title="四、格式化字符串"></a><strong>四、格式化字符串</strong></h2><p>编写程序时，输出是很重要的一环。C&#x2F;C++都提供了printf()函数，以格式化字符串来控制参数的打印。</p>
<p>C#中也存在格式化字符串，并且可以用于控制Console.WriteLine()和Console.Write()的打印格式。</p>
<h3 id="1-内插式字符串"><a href="#1-内插式字符串" class="headerlink" title="(1) 内插式字符串"></a><strong>(1) 内插式字符串</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> Name = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> Age = <span class="number">17</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Name&#125;</span> is <span class="subst">&#123;Age&#125;</span> years old.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在字符串前加上“$”，编译器会自动讲大括号内的字符识别为变量名，并以其真实值在字符串中替换之。</p>
<h3 id="2-完整的格式化字符串"><a href="#2-完整的格式化字符串" class="headerlink" title="(2) 完整的格式化字符串"></a><strong>(2) 完整的格式化字符串</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> Name = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> Age = <span class="number">17</span>;</span><br><span class="line">Console.WriteLine(</span><br><span class="line">    format: <span class="string">&quot;&#123;0&#125; is &#123;1&#125; years old.&quot;</span>,</span><br><span class="line">    arg0: Name,</span><br><span class="line">    arg1: Age);</span><br></pre></td></tr></table></figure>

<p>与内插式相比，完整的格式化字符串更详细。</p>
<h3 id="3-字符串控制符号"><a href="#3-字符串控制符号" class="headerlink" title="(3) 字符串控制符号"></a><strong>(3) 字符串控制符号</strong></h3><p>格式化字符串完整的控制格式应该如下:</p>
<ul>
<li>内插式：{变量名，对齐：格式}</li>
<li>完整式：{编号，对齐：格式}</li>
</ul>
<p>其中，对齐处需要填入一个整数，代表你希望这个参数在输出时占多少个字符。若整数为负数，则采取左对齐，为整数则采取右对齐。</p>
<p>格式代表了你希望以什么格式输出。N0表示输出没有小数且每3位以逗号分隔的数字；C表示输出的数字是货币，将在数字前自动加上当前电脑的货币标志。</p>
<p>{0,-8:C}代表第0个参数占8个字符宽，左对齐，在它之前加上货币标志。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> Name0 = <span class="string">&quot;Apple iPhone&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> Name1 = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> cost0 = <span class="number">6000</span>;</span><br><span class="line"><span class="built_in">int</span> cost1 = <span class="number">3</span>;</span><br><span class="line">Console.WriteLine(</span><br><span class="line">    format: <span class="string">&quot;&#123;0,-15&#125; costs &#123;1:C&#125;.&quot;</span>,</span><br><span class="line">    arg0: Name0,</span><br><span class="line">    arg1: cost0);</span><br><span class="line">Console.WriteLine(</span><br><span class="line">    format: <span class="string">&quot;&#123;0,-15&#125; costs &#123;1:C&#125;.&quot;</span>,</span><br><span class="line">    arg0: Name1,</span><br><span class="line">    arg1: cost1);</span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">Apple iPhone    costs ¥6,000.00.</span><br><span class="line">Banana          costs ¥3.00.</span><br></pre></td></tr></table></figure>

<h2 id="五、输入"><a href="#五、输入" class="headerlink" title="五、输入"></a><strong>五、输入</strong></h2><p>与WriteLine()和Write()函数相似，Console类下有ReadLine()和Read()函数，用于从控制台读取用户的输入。</p>
<p>不过与C&#x2F;C++的scanf()相比，Read()和ReadLine()实在是差远了——它们没有格式化字符串作为参数。Read()每次以字符的形式读取一个字符，ReadLine()则是直接读取除了换行符以外的一整行输入。这也就意味着，要想读入int类型的数据，必须将输入从sting或者char类型转换为int类型。</p>
<p>还有一种读取输入的方法。这种方法只要按下一个键，不需要按回车就能立即生效。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ConsoleKeyInfo input = Console.ReadKey();</span><br><span class="line">Console.WriteLine(</span><br><span class="line">    <span class="string">$&quot;<span class="subst">&#123;input.Key&#125;</span>,<span class="subst">&#123;input.KeyChar&#125;</span>,<span class="subst">&#123;input.Modifiers&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>ConsoleKeyInfo类还有其他成员变量，此处不深入探究。这种方式读取无需输入回车，按下键盘即可生效，但一次还是只能以单个字符的形式读取输入。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>C#语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#语法基础（三）</title>
    <url>/2022/01/19/CsharpGrammar03/</url>
    <content><![CDATA[<img src="/2022/01/19/CsharpGrammar03/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议先学习C++基础再进行C#的学习。</div>
</div>

<span id="more"></span>

<h2 id="六、控制流"><a href="#六、控制流" class="headerlink" title="六、控制流"></a><strong>六、控制流</strong></h2><p>C#的语法与C++基本一致。你完全可以用C&#x2F;C++的控制流来控制C#的程序运行而不会产生任何报错。因为C#是在C&#x2F;C++的控制流基础之上新增了一些语法。</p>
<h3 id="1-模式匹配"><a href="#1-模式匹配" class="headerlink" title="(1) 模式匹配"></a><strong>(1) 模式匹配</strong></h3><p>先看例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> Name = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(Name <span class="keyword">is</span> <span class="built_in">string</span> temp)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Hello, <span class="subst">&#123;temp&#125;</span>!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的if语句的条件在C&#x2F;C++的语法规则下会显得很奇怪，这就是C#新增加的特性。</p>
<p>“is”关键字的用法是</p>
<div style="color:red;">已定义的变量名 is 类型 未定义的变量名</div>

<p>它的含义是，如果已定义的变量名的值是属于这个类型的，那么就将它的值赋给未定义的变量名，未定义的变量名会作为这个类型的局部变量在if块内生效，然后执行if内的语句。</p>
<p>运行上述代码，if语句检测Name的值是否属于string类型。因为Name的值是字符串，符合属于string类型的条件，所以将Name的值“Lacia”赋给temp，并使temp在if块内生效。</p>
<p>如果尝试在if块外部使用temp，编译器将会报错：</p>
<p><img src="/2022/01/19/CsharpGrammar03/1.png" alt="1 &quot;1&quot;" title="1"></p>
<p>可以看到if块外的temp被划了红色横线，表明出现了错误。</p>
<p>模式匹配也可以用于switch语句，并且可以更加精确地匹配：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (Name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">string</span> temp <span class="keyword">when</span> Name.Length == <span class="number">5</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Hello, <span class="subst">&#123;temp&#125;</span>!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在关键字when后面追加条件以实现对多个条件测检测。</p>
<h3 id="2-switch"><a href="#2-switch" class="headerlink" title="(2) switch"></a><strong>(2) switch</strong></h3><p>在C#中你可以按照传统的C&#x2F;C++风格的使用switch，也可以使用C#新加的关于switch的语法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Name = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> ReturnValue = Name <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> temp <span class="keyword">when</span> Name.Length == <span class="number">5</span></span><br><span class="line">        =&gt; <span class="string">$&quot;She is <span class="subst">&#123;temp&#125;</span>.&quot;</span>,  <span class="comment">//此处为逗号</span></span><br><span class="line">    _  <span class="comment">//以下划线代表默认值，即原来的default</span></span><br><span class="line">        =&gt; <span class="string">&quot;A stranger.&quot;</span></span><br><span class="line">&#125;;  <span class="comment">//注意这里有个分号</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;ReturnValue&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>新的switch去掉了case以及条件之后的冒号，“&#x3D;&gt;”代表的是将后面的值作为返回值，赋值给ReturnValue。</p>
<p>程序的打印结果应该为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">She is Lacia.</span><br></pre></td></tr></table></figure>

<h3 id="3-foreach"><a href="#3-foreach" class="headerlink" title="(3) foreach"></a><strong>(3) foreach</strong></h3><p>虽然C&#x2F;C++也有类似的循环语法，不过C#的foreach给我的感觉却更接近Python。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> Name0 = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line">List&lt;<span class="built_in">char</span>&gt; Name1 = <span class="keyword">new</span> List&lt;<span class="built_in">char</span>&gt;(<span class="string">&quot;Kouka&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">char</span> temp <span class="keyword">in</span> Name0)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123;temp&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.Write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">char</span> temp <span class="keyword">in</span> Name1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123;temp&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach循环就是新定义一个变量，这个变量会按顺序遍历“in”关键字之后的可迭代容器内的所有变量。实际上编译器在翻译foreach时会将它转换成下面的伪代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IEnumerator&lt;<span class="built_in">char</span>&gt; temp = Name.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span>(temp.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123;temp.Current&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也就意味着，你在foreach内对temp的值的修改会报错。因为temp.Current是只读不可写的。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>关于IEnumerator</strong></div>

<div style="color:royalblue;">上述代码的运行过程非常类似于C++的链表的遍历。这意味着要想使用foreach，容器的类必须定义了GetEnumerator()成员函数，并且返回的IEnumerator变量也必须拥有MoveNext()成员函数与Current成员变量。</div>
</div>

<p>上述代码的运行结果应该为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">Lacia</span><br><span class="line">Kouka</span><br></pre></td></tr></table></figure>

<p>或许你的代码会显示如下警告</p>
<p><img src="/2022/01/19/CsharpGrammar03/2.png" alt="2 &quot;2&quot;" title="2"></p>
<p>这是因为C# 9.0以上的语法规则允许使用下面的更简化的new表达式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">char</span>&gt; Name1 = <span class="keyword">new</span>(<span class="string">&quot;Kouka&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译与运行同样正常。</p>
<h2 id="六、类型转换"><a href="#六、类型转换" class="headerlink" title="六、类型转换"></a><strong>六、类型转换</strong></h2><h3 id="1-数值的转换"><a href="#1-数值的转换" class="headerlink" title="(1) 数值的转换"></a><strong>(1) 数值的转换</strong></h3><p>在C&#x2F;C++中，直接将double型变量的值赋给int型变量是不会报错的（虽然很大程度上这是取决于你的编译器的）。而C#则对此做了更严格的规范。</p>
<p><img src="/2022/01/19/CsharpGrammar03/3.png" alt="3 &quot;3&quot;" title="3"></p>
<p>C#不允许这种可能会丢失信息的隐式类型转换。我们必须显式地告诉编译器我们能接受这种信息丢失：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> a = <span class="number">114.514</span>;</span><br><span class="line"><span class="built_in">int</span> b = (<span class="built_in">int</span>)a;</span><br></pre></td></tr></table></figure>

<p>通过显式地标记强制类型转换，才能使代码编译通过。</p>
<p>C#还提供了另一种类型转换的方式：定义在System命名空间下的Convert静态类。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> a = <span class="number">114.514</span>;</span><br><span class="line"><span class="built_in">int</span> b = Convert.ToInt32(a);</span><br></pre></td></tr></table></figure>

<p>可以尝试分别运行上述两种类型转换的代码。</p>
<p>你可以发现使用(int)强制类型转换的结果是114，而使用Convert类提供的ToInt32()函数的转换结果是115。这是因为，前者省略了小数而后者采取了四舍五入取整。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>ToInt32()的取整规则</strong></div>

<div style="color:royalblue;">Convert.ToInt32()函数取整规则是小于0.5则舍弃，大于0.5则进位，等于0.5就取决于整数部分。整数部分为奇数就进位，整数部分为偶数就舍弃。</div>
</div>

<h3 id="2-字符串的转换"><a href="#2-字符串的转换" class="headerlink" title="(2) 字符串的转换"></a><strong>(2) 字符串的转换</strong></h3><div class="tabs" id="converttostring"><ul class="nav-tabs"><li class="tab active"><a href="#converttostring-1">从数字到字符串</a></li><li class="tab"><a href="#converttostring-2">BASE64</a></li><li class="tab"><a href="#converttostring-3">从字符串到数字</a></li></ul><div class="tab-content"><div class="tab-pane active" id="converttostring-1"><p>C#在C++的面向对象思想上更进了一步。C#中常见的变量类型都继承自System命名空间下的Object类。因此它们都可以调用Object中定义好的成员函数ToString()。</p></div><div class="tab-pane" id="converttostring-2"><p>当然，Convert类也贴心地定义了ToBase64String()与FromBase64String()函数。它们能够执行将字符串以BASE64编码和从BASE64解码的功能。</p></div><div class="tab-pane" id="converttostring-3"><p>部分类型提供了Parse()函数，例如</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="built_in">int</span>.Parse(<span class="string">&quot;114514&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但Parse()函数是危险的，因为如果提供的字符串不是纯数字组成的字符串，虽然编译能够通过，但运行时程序就会崩溃。</p>
<p>解决方式有两种，一种是将Parse()放在try块内，另一种就是使用TryParse：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> a = Console.ReadLine();  <span class="comment">//[1]此处或许会出现警告</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">int</span>.TryParse(a,<span class="keyword">out</span> <span class="built_in">int</span> b))   <span class="comment">//[2]</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;b&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note default"><div style="color:dimgray;font-size:1.5em;"><strong>代码的注释</strong></div>

<div style="color:dimgray;">
[1] 出现警告的原因是因为在.csproj文件里声明了Nullable属性是enable的。即使用了可空引用类型，而变量a并未显式声明为空类型。解决方法有两种：1. 将a的类型修改为“string?”；2. 将Nullable属性设置为disable。<br>
[2] out关键字是代表了传入函数的这个参数也是输出的一部分。类似的关键字还有ref，ref更接近C++中的引用符号“&”。而out允许在其后定义新的变量以接收返回值，ref则不允许，因为ref关键字的参数很有可能要参与运算。
</div>
</div>

<p>TryParse()函数返回值是bool型变量。如果转换成功则返回true，并将结果赋给out关键字后的变量；如果失败则返回false。</p>
<p>Convert类下也提供了丰富的关于string类型转换的函数，但是它们很多都和Parse一样，存在编译正常而运行出错的可能性。一定要检查你的输入，或设置异常解决方案。</p></div></div></div>

<h2 id="七、try-catch与checked"><a href="#七、try-catch与checked" class="headerlink" title="七、try catch与checked"></a><strong>七、try catch与checked</strong></h2><h3 id="1-try-catch"><a href="#1-try-catch" class="headerlink" title="(1) try catch"></a><strong>(1) try catch</strong></h3><p>在C#中，异常也具有类型。所有的异常类型均继承自System命名空间下的Exception类。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> NumberString = Console.ReadLine();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Number = <span class="built_in">int</span>.Parse(NumberString);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Number&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception temp)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;temp.GetType()&#125;</span>,<span class="subst">&#123;temp.Message&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码至少存在两种潜在异常。一种是NumberString不可被转换为int，另一种则是NumberString转换为数字以后的值大于了int能表示的最大数值，造成了溢出。</p>
<p>try块在出现异常以后将由catch块进行处理。由于Exception类是所有异常类型的父类，所以所有的异常都能进入catch块内。其中temp.GetType()能够查看异常的所属类，而temp.Message则查看具体的出错信息。</p>
<p>分别测试上述两种异常，报错如下：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">Lacia</span><br><span class="line">System.FormatException,Input string was not in a correct format.</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">1145141919810</span><br><span class="line">System.OverflowException,Value was either too large or too small for an Int32.</span><br></pre></td></tr></table></figure>

<p>可以看到前者的异常属于FormatException类，而后者的异常属于OverflowException类。因此可以对异常进行进一步的处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Number = <span class="built_in">int</span>.Parse(NumberString);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Number&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (OverflowException)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;在？数字为什么这么大？&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FormatException)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;在？为什么输入字符？&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception temp)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;temp.GetType()&#125;</span>,<span class="subst">&#123;temp.Message&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处可以交换OverflowException与FormatException的位置，但这并不代表所有的异常类型都能够交换位置。具体的顺序与异常类型的继承顺序有关。关于这点之后再讲。</p>
<h3 id="2-checked与uncheckd"><a href="#2-checked与uncheckd" class="headerlink" title="(2) checked与uncheckd"></a><strong>(2) checked与uncheckd</strong></h3><p>运行下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="built_in">int</span>.MaxValue - <span class="number">1</span>;</span><br><span class="line">a++;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;a&#125;</span>&quot;</span>);</span><br><span class="line">a++;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;a&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以发现你的输出突然变为了负值。这说明发生了溢出现象。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>溢出</strong></div>

<div style="color:royalblue;">造成这种现象的原因网上已经有很多说明，C#的这种现象与C/C+等编程语言的溢出现象如出一辙，此处不再赘述。</div>
</div>

<p>运行代码时你会发现编译器既没有在编译时提出警告，运行时程序也未抛出异常。这是因为C#默认忽略了你的溢出错误。要想检查溢出，可以采用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">checked</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="built_in">int</span>.MaxValue - <span class="number">1</span>;</span><br><span class="line">    a++;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;a&#125;</span>&quot;</span>);</span><br><span class="line">    a++;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;a&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次执行dotnet run命令。你会发现编译成功，并且实现了第一次自加。但在第二次自加的时候，程序抛出了异常信息并退出。</p>
<p>checked块内的溢出会被视为错误。因此若要显式地检查溢出，不妨试试checked块。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>checked无法处理异常</strong></div>

<div style="color:goldenrod;">要处理溢出异常还是得靠try catch。但是记得要把checked块放在try块内，显式地检查溢出，因为try块会忽略这种自加型的异常。</div>
</div>

<p>要想完全忽略溢出，可以使用unchecked。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> b = <span class="built_in">int</span>.MaxValue + <span class="number">1</span>;  <span class="comment">//编译器报错</span></span><br><span class="line"><span class="keyword">unchecked</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="built_in">int</span>.MaxValue + <span class="number">1</span>;  <span class="comment">//编译器忽略了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在uncheck块内的代码，不仅运行时不会有溢出提示，就连编译器都不检查你赋值的时候有没有溢出了。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>C#语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#语法基础（四）</title>
    <url>/2022/01/19/CsharpGrammar04/</url>
    <content><![CDATA[<img src="/2022/01/19/CsharpGrammar04/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议先学习C++基础再进行C#的学习。</div>
</div>

<span id="more"></span>

<h2 id="八、语法杂项"><a href="#八、语法杂项" class="headerlink" title="八、语法杂项"></a><strong>八、语法杂项</strong></h2><h3 id="1-成员函数与构造-x2F-析构函数"><a href="#1-成员函数与构造-x2F-析构函数" class="headerlink" title="(1) 成员函数与构造&#x2F;析构函数"></a><strong>(1) 成员函数与构造&#x2F;析构函数</strong></h3><p>语法与C&#x2F;C++基本一致，但更像C++，因为所有的函数必须为成员函数。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>自定义函数</strong></div>

<div style="color:goldenrod;">若你想像C/C++一样在Main()函数里直接调用自定义的函数，请务必在定义函数时加上static前缀，否则编译器会报错。关于为什么会报错，之后再讲。</div>
</div>

<p>并且，之前的笔记也已经提到了。C#中不允许使用指针，除非你使用了unsafe关键字。同时C#也不存在像C++的引用符“&amp;”。要想通过引用的方式传递参数，需要在函数声明以及使用的时候显式地在参数前标记“ref”关键字。</p>
<p>关于ref与out关键字的区别之前的笔记已经叙述过了此处不再赘述。</p>
<p>同样，C#中的类也存在构造函数和析构函数。不过只有非static的类才能有构造函数与析构函数。被static修饰的类则不允许构造函数与析构函数存在。</p>
<p>C#的函数自然也有类似与C++的重载、多态等。</p>
<h3 id="2-访问修饰符"><a href="#2-访问修饰符" class="headerlink" title="(2) 访问修饰符"></a><strong>(2) 访问修饰符</strong></h3><p>C++中存在三种访问修饰符：public、protect、private。访问限制等级依次增加。而C#新增加了一种访问修饰符，总共四种：public、internal、protected、private。同样，访问限制等级也是依次增加的。</p>
<p>与C++相同，在你未显式声明成员变量或成员函数的访问修饰符的时候，C#会默认应用private（C++里如果是struct则会默认为public）。</p>
<p>不同之一：C#的类本身也可以被访问修饰符修饰。C#的类只能被显式声明为internal或者public，未声明时默认为internal。</p>
<p>不同之二：internal。internal修饰的成员变量或者成员函数代表了只有处于同一程序集中的类与函数才有资格访问它。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>程序集</strong></div>

<div style="color:royalblue;">由.Net生成的.dll或者.exe文件就是程序集。你可以认为只有处于同一个project的代码才能访问internal修饰的类与函数。</div>
</div>

<p>你可以试试下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MainProgram</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            A.B.C();  <span class="comment">//使用A命名空间下的B类里的C函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span>  <span class="comment">//未显式声明修饰符，默认为internal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">C</span>()  <span class="comment">//internal修饰的函数</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以C#的访问权大致能分4个等级：</p>
<ol>
<li>private：仅有本类的成员能访问</li>
<li>protected：仅有本类及其子类能访问</li>
<li>internal：仅本程序集或本类成员能访问</li>
<li>public：都能访问</li>
</ol>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>访问修饰符叠叠乐</strong></div>

<div style="color:royalblue;">C#中还存在叠加的访问修饰方式，比如private protected、protected internal等。详细参见 <a class="btn" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/private-protected ">Microsoft官方文档</a> ，此处不再赘述。</div>
</div>

<h3 id="3-非static类中的static成员"><a href="#3-非static类中的static成员" class="headerlink" title="(3) 非static类中的static成员"></a><strong>(3) 非static类中的static成员</strong></h3><p>在C#内static既可以用于修饰类，也可以用于修饰类的成员。static的类的成员必须全都显式声明为static，否则编译器会报错。</p>
<p>而对于非static的类，则其成员既可以使用static修饰，也可以不使用。其区别在于，用static修饰的成员可以直接以“类.成员”的形式访问，未显式声明的成员则必须以“变量.成员”的形式访问。其中变量是属于该类型的。</p>
<p>可以做以下实验：</p>
<p>在代码中添加如下命名空间</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">int</span> B = <span class="number">114514</span>;</span><br><span class="line">        <span class="built_in">int</span> C = <span class="number">1919810</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">D</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;D executed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">E</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;E executed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改Main()函数为</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">A.A test0 = <span class="keyword">new</span>(), test1 = <span class="keyword">new</span>();</span><br><span class="line">test0.D();  <span class="comment">//报错，实例不允许访问static成员</span></span><br><span class="line">A.A.D();</span><br><span class="line"></span><br><span class="line">test0.E();</span><br><span class="line">A.A.E();  <span class="comment">//报错，不能使用类来访问非static成员，需要属于该类型的变量</span></span><br><span class="line"></span><br><span class="line">test0.B = <span class="number">1</span>;  <span class="comment">//报错，实例不允许访问static成员</span></span><br><span class="line">A.A.B = <span class="number">114</span>;</span><br><span class="line"></span><br><span class="line">test0.C = <span class="number">514</span>;</span><br><span class="line">test1.C = <span class="number">1919</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;A.A.B:<span class="subst">&#123;A.A.B&#125;</span>,test0:<span class="subst">&#123;test0.C&#125;</span>,test1:<span class="subst">&#123;test1.C&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在注释掉报错的行以后，在终端内执行dotnet run命令，其输出应该为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">D executed.</span><br><span class="line">E executed.</span><br><span class="line">A.A.B:114,test0:514,test1:1919</span><br></pre></td></tr></table></figure>

<p>不难发现规律：直接使用类名只能调用static成员；使用属于该类的变量只能调用非static成员，且每个变量的成员的值互不干扰。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>static成员</strong></div>

<div style="color:royalblue;">与C#不同，C++不仅类名可以直接访问static成员，且每个属于这个类的变量都能访问且共享static成员的值。C++的static成员需要在类外初始化而C#不需要，或者说C#不能在类外初始化。</div>
</div>

<h3 id="4-readonly"><a href="#4-readonly" class="headerlink" title="(4) readonly"></a><strong>(4) readonly</strong></h3><p>C#新增了用于修饰成员变量的关键字readonly。被readonly修饰的变量在初始化或者在构造函数内初始化后就不能再次被赋值。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>readonly与const</strong></div>

<div style="color:royalblue;">与const不同，readonly变量在声明的时候并不需要初始化，并且它能够在构造函数内进行初始化。</div>
</div>

<h3 id="4-元组"><a href="#4-元组" class="headerlink" title="(4) 元组"></a><strong>(4) 元组</strong></h3><p>C#中也存在语法上与Python相似的元组。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">double</span> price) temp;</span><br><span class="line">    temp = Lacia();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span>,<span class="subst">&#123;age&#125;</span>,<span class="subst">&#123;price&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> (<span class="built_in">string</span> Name,<span class="built_in">int</span>,<span class="built_in">double</span>) Lacia()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;Lacia&quot;</span>, <span class="number">17</span>, <span class="number">114.514</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述代码，你会发现“Lacia”，17，114.514分别对应地返回给了name，age和price。</p>
<p>当然你也可以直接定义一个元组类型的变量：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">double</span> price) temp;</span><br><span class="line">temp = Lacia();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;temp.name&#125;</span>,<span class="subst">&#123;temp.age&#125;</span>,<span class="subst">&#123;temp.price&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>元组内的默认变量名</strong></div>

<div style="color:royalblue;">你也可以选择在函数返回值声明处写明返回值的默认变量名而无需在元组定义处声明。如果都声明了，以元组定义时的名称为准；如果都没有声明，那么元组内.的变量默认名称将会是Item1、Item2、······。</div>
</div>

<h3 id="5-partial"><a href="#5-partial" class="headerlink" title="(5) partial"></a><strong>(5) partial</strong></h3><p>C#中新增了partial关键字。被这个关键字修饰的类代表了这个类是不完全的，在其他文件中还有其剩余的定义。在编译时会将被partial修饰的处于同一命名空间下的多个同名类合并为一个，这些都将被视为一个类。</p>
<h3 id="6-属性"><a href="#6-属性" class="headerlink" title="(6) 属性"></a><strong>(6) 属性</strong></h3><p>C#提供了一种新的访问与修改成员变量的成员函数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Lacia hIE = <span class="keyword">new</span>();</span><br><span class="line">        hIE.Type = <span class="string">&quot;Type-002&quot;</span>;  <span class="comment">//注意此处没有括号</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;hIE.Type&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Lacia</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> type = <span class="string">&quot;Type-005&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Type  <span class="comment">//注意此处没有括号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            type = <span class="keyword">value</span> <span class="keyword">switch</span>  <span class="comment">//value为传入的参数，或者说是对Type赋值的值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type-001&quot;</span> =&gt; <span class="string">&quot;Type-001&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Type-002&quot;</span> =&gt; <span class="string">&quot;Type-002&quot;</span>,</span><br><span class="line">                _ =&gt; <span class="string">&quot;Type-005&quot;</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，type为变量，Type为函数。Type函数中的get关键字，代表了当调用Lacia.Type时，如果是需要访问它的值，则执行get块内的语句；而set关键字则代表如果是要对某个成员变量进行赋值，则执行set块中的语句。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>命名规则</strong></div>

<div style="color:royalblue;">请注意这里的变量名与函数名不一致。一般为了区分，变量名会以类似于republicEngineeringStudent的方式命名，首字母小写；而对这个成员变量进行访问与操作的函数则是以类似于RepublicEngineeringStudent的方式命名，首字母大写。这只是一种约定，你也可以不按照约定书写你的代码，不过你在维护你的代码的时候可能要费一番功夫。</div>
</div>

<p>应用属性这一特点，我们可以写一个索引器：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HIE hIEs = <span class="keyword">new</span>();</span><br><span class="line">        hIEs[<span class="number">1</span>] = <span class="string">&quot;Type-002&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;hIEs[<span class="number">1</span>]&#125;</span>,<span class="subst">&#123;hIEs[<span class="number">2</span>]&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span>[] Types = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>] &#123; <span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Lacia&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//请注意此处用了readonly字段声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> i]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Types[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            Types[i] = <span class="keyword">value</span>.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码。你的输出应该是：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">Type-002,Lacia</span><br></pre></td></tr></table></figure>

<p>首先我先解释一下代码中的“this”。与C++一样，C#中也存在this，但它不是指针，而是指向当前类的一个引用值。自定义索引器的方法具体还得看代码，文字并不好描述。</p>
<div style="color:red;">接下来是重点：为什么以“readonly”关键字声明的Types的值被修改了，并且从编译到执行的整个过程没有任何警告。<br>
之前也提到过，C#中存在两种类型——值类型与引用类型，而引用类型与C/C++中的指针很相似。string与数组都是引用类型。这意味着，string与数组的变量其实保存的都不是值，而是一个指针，在需要用到值的时候才会从保存的地址中去寻找所需的值。<br>
所以，只要不是修改Types数组指向的地址，而是对这个数组中保存的值进行修改，就不会触发任何异常与警告。</div>

<p>可以试着运行下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        HIE hIEs = <span class="keyword">new</span>();</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;hIEs.Types[<span class="number">1</span>]&#125;</span>&quot;</span>);</span><br><span class="line">        hIEs.Types[<span class="number">1</span>] = <span class="number">114514</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;hIEs.Types[<span class="number">1</span>]&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span>[] Types = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果应该为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">1</span><br><span class="line">114514</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>只读的索引器</strong></div>

<div style="color:royalblue;">但是上面的实验对同为引用类型的string类型却失败了。原因可能在于string被定义为readonly时，其索引器也会被定义为只读的。报错信息为：</div><br>
<div style="color:red;">无法为属性或索引器“string.this[int]”赋值 - 它是只读的 [Hello]</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>C#语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#语法基础（五）</title>
    <url>/2022/01/21/CsharpGrammar05/</url>
    <content><![CDATA[<img src="/2022/01/21/CsharpGrammar05/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议先学习C++基础再进行C#的学习。</div>
</div>

<span id="more"></span>

<h2 id="九、委托相关"><a href="#九、委托相关" class="headerlink" title="九、委托相关"></a><strong>九、委托相关</strong></h2><h3 id="1-C-学习者能理解的委托"><a href="#1-C-学习者能理解的委托" class="headerlink" title="(1) C++学习者能理解的委托"></a><strong>(1) C++学习者能理解的委托</strong></h3><p>类似于C&#x2F;C++指向函数的指针，C#中委托可以用于调用函数，并且也需要与待调用的函数的类型相符，比如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">A</span>(<span class="params"><span class="built_in">double</span> B, <span class="built_in">string</span> C</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个委托A就只能指向返回值为int，参数为double与string的函数。具体用法如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TestExampple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Function</span>(<span class="params"><span class="built_in">double</span> a,<span class="built_in">string</span> b</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//这个成员函数为非static函数，必须以实例调用</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;double = <span class="subst">&#123;a&#125;</span>, string = <span class="subst">&#123;b&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestExampple temp = <span class="keyword">new</span>();</span><br><span class="line">        A DelegateFunction = <span class="keyword">new</span>(temp.Function);  <span class="comment">//委托也需要新建实例</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DelegateFunction(<span class="number">19.19</span>, <span class="string">&quot;Lacia&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">A</span>(<span class="params"><span class="built_in">double</span> B, <span class="built_in">string</span> C</span>)</span>;</span><br><span class="line">    <span class="comment">//定义的委托。委托可以看成是一个变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的运行结果应该为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">double = 19.19, string = Lacia</span><br><span class="line">114514</span><br></pre></td></tr></table></figure>

<p>可以看见新建的委托实例DelegateFunction确实调用了指定的函数并正确执行了它的功能。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>委托的定义</strong></div>

<div style="color:goldenrod;">请注意，1. 委托的声明最好是在namespace和class内。在函数内的定义较为复杂。具体请自行搜索。2. 再次强调，委托需要新建实例以调用。下面我们将看到与上述代码不一样的定义委托实例的方式。</div>
</div>

<h3 id="2-委托的“加法”与事件"><a href="#2-委托的“加法”与事件" class="headerlink" title="(2) 委托的“加法”与事件"></a><strong>(2) 委托的“加法”与事件</strong></h3><p>术语应该叫“委托的多播”。与C&#x2F;C++的指针不同，C#的一个委托实例可以指向多个函数。调用委托实例时，会调用所有它引用的函数。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前提不变</strong></div>

<div style="color:goldenrod;">这里同样需要满足函数与委托的返回值与参数类型完全一致这个条件，并且调用顺序与添加顺序一致。</div>
</div>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        TestExampple temp = <span class="keyword">new</span>();</span><br><span class="line">        A DelegateFunction = temp.Function;  <span class="comment">//&lt;=====这里不一样</span></span><br><span class="line">        DelegateFunction += temp.Function2;  <span class="comment">//&lt;=====这里不一样</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DelegateFunction(<span class="number">19.19</span>, <span class="string">&quot;Lacia&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">A</span>(<span class="params"><span class="built_in">double</span> B, <span class="built_in">string</span> C</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">TestExampple</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Function</span>(<span class="params"><span class="built_in">double</span> a,<span class="built_in">string</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;double = <span class="subst">&#123;a&#125;</span>, string = <span class="subst">&#123;b&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Function2</span>(<span class="params"><span class="built_in">double</span> a,<span class="built_in">string</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Function2.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1919810</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例指向了多个函数时，调用委托实例会调用所有它引用的函数，并且的返回值将是最后一个被引用且未被删除的函数的返回值。</p>
<p>定义委托实例时，可以使用event关键字。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">A</span>(<span class="params"><span class="built_in">double</span> B, <span class="built_in">string</span> C</span>)</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">event</span> A DelegateFunction;   <span class="comment">//&lt;===委托实例的一种：事件</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>请注意</strong></div>

<div style="color:goldenrod;">1. 以上述代码声明委托时，代码只能放在命名空间或者类中，而不能放在函数中。2. 委托实例也可以用static前缀修饰。</div>
</div>

<p>以event修饰的委托实例不能在函数中定义，不需要使用new来创建引用对象，并且定义时不能有初始值（或者说是默认引用的函数）所有的委托都能通过：</p>
<ol>
<li>“&#x3D;”来删除原有引用，指向新的引用；</li>
<li>“+&#x3D;”来添加引用；</li>
<li>“-&#x3D;”来删除引用。</li>
</ol>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>其它的调用方式</strong></div>

<div style="color:royalblue;">此外，委托与事件还可以使用DelegateFunction.Invoke(参数)的方式来调用。</div>
</div>

<h2 id="十、接口"><a href="#十、接口" class="headerlink" title="十、接口"></a><strong>十、接口</strong></h2><p>类似于C++中从继承父类的子类一样，如果父类有虚函数，那么子类可以以不同的方式实现这个函数。C#中有与此类似的公共接口。但这些接口不是父类中的虚函数。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>暂时地理解</strong></div>

<div style="color:royalblue;">以C++的方式来理解的话，就是Object里写了很多虚函数，其子类可以实现这些虚函数。实际上C#则是将“虚函数”分离出来，单独写“虚函数”，每个类都可声明我实现了哪些“虚函数”。</div>
</div>

<p>而C#的类需要显式地声明它实现了哪种接口。若该类中没有实现它所声明的接口，编译器将会报错。在自动纠错中将会有“实现接口”选项，以快捷地套用接口模板。</p>
<p>比较常见的接口有：</p>
<ol>
<li>IComparable&lt;Class&gt;，用于该类与Class类进行比较大小。</li>
<li>IComparer&lt;Class&gt;，用于定义一个单独的类以排序Class类。</li>
<li>IDisposable，用于释放非托管资源。</li>
<li>IFormattable，用于将类转换为字符串。</li>
<li>IFormatter&lt;Class&gt;，用于将Class类与字节流互换。</li>
</ol>
<p>下面是一个实现接口的例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HIE</span> : <span class="title">IComparable</span>&lt;<span class="title">HIE</span>&gt;  <span class="comment">//&lt;====声明要实现能和HIE类进行比大小的接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Type;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HIE</span>(<span class="params"><span class="built_in">string</span> type,<span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = type;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">HIE other</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//这个函数就是接口的实现</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Type.CompareTo(other.Type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以在命名空间中自定义接口。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Talk</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReceiveOrder</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C# 8.0以上添加了接口的默认实现这个特性。即在定义接口的时候写上接口的默认实现。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">Talk</span>()</span></span><br><span class="line"><span class="function">        <span class="comment">//这个接口拥有默认实现</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello,world!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ReceiveOrder</span>()</span>;</span><br><span class="line">        <span class="comment">//这个接口没有默认实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一、泛型"><a href="#十一、泛型" class="headerlink" title="十一、泛型"></a><strong>十一、泛型</strong></h2><p>已经学过C++的同学或许已经能看明白下面的C#泛型示例代码了。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HIE</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>: <span class="title">IComparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T data = <span class="literal">default</span>;</span><br><span class="line">    <span class="comment">//C#的关键字default</span></span><br><span class="line">    <span class="comment">//其功能为将变量设置为该类型的默认值</span></span><br><span class="line">    <span class="comment">//对于没有默认值的变量，它将会报错</span></span><br><span class="line">    <span class="keyword">public</span> T Data</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; data = (T)<span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>where关键字</strong></div>

<div style="color:royalblue;">此处where关键字是用于限制T的类型必须实现了IComparable接口。关于更多where的用法，详见 <a class="btn" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/where-clause ">Microsoft官方文档</a> 。</div>
</div>

<p>这与C++的模板类高度类似。当然C#也存在模板函数，模板函数甚至也能在非模板类中使用。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>专业术语</strong></div>

<div style="color:royalblue;">在C#中，模板类应该叫泛型方法，模板函数应该叫泛型类型。</div>
</div>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HIE</span>  <span class="comment">//&lt;====没有使用泛型声明</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Method</span>&lt;<span class="title">T</span>&gt;(<span class="params">T First, T Second</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T : IComparable</span></span><br><span class="line"><span class="function">    <span class="comment">//声明了泛型函数，其功能是返回较大值</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(First.CompareTo(Second)!=<span class="number">1</span>) <span class="keyword">return</span> Second;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> First;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述代码进行测试：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;HIE.Method(<span class="number">114</span>, <span class="number">514</span>)&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="comment">//由于传入的参数类型明显，此处编译器提示我可以省略&lt;int&gt;声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dotnet run</span></span><br><span class="line">514</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>泛型的限制</strong></div>

<div style="color:goldenrod;">请注意，在C++中，编写模板类或模板函数时，两个T类型的变量是可以相加的，而C#却禁止这么做——因为作为参数传入的T类型很有可能不支持加法。同样地，四则运算、比大小之类的都是不被允许的。</div>
</div>

<h2 id="十二、class与struct"><a href="#十二、class与struct" class="headerlink" title="十二、class与struct"></a><strong>十二、class与struct</strong></h2><div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>快去学操作系统</strong></div>

<div style="color:royalblue;">学过操作系统或者计算机组成原理的看这一段会比较亲切。</div>
</div>

<p>class类型的变量为引用类型，其值存放在堆内。struct类型的变量为值类型，其值存放在栈内。</p>
<p>class类型的变量占用的内存空间需要等待垃圾回收器释放。struct类型的变量占用的内存空间在退出函数时就会被释放。</p>
<p>常见的struct类型有bool、int、float、double、char、byte等。string为class类型。</p>
<p>如果你的成员变量只有struct类型，那么建议使用struct，其他情况都建议使用class，即便class相对于struct更慢（因为class只存储了地址，需要访问两次内存才能找到值）。</p>
<h2 id="十三、主动回收分配的资源"><a href="#十三、主动回收分配的资源" class="headerlink" title="十三、主动回收分配的资源"></a><strong>十三、主动回收分配的资源</strong></h2><p>前面提到过的常见接口中，有一个名为IDisposable的接口。实现这个接口就能显式地释放资源。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">HIE</span>: <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> DisposeFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HIE</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ······  <span class="comment">//&lt;===分配资源的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~HIE()  <span class="comment">//析构函数，由系统来调用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(DisposeFlag==<span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果已经释放了就不再次释放</span></span><br><span class="line"></span><br><span class="line">        Dispose(<span class="literal">false</span>);  <span class="comment">//只释放非托管资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()  <span class="comment">//&lt;===显示调用以释放资源</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispose(<span class="literal">true</span>);  <span class="comment">//释放所有资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);  <span class="comment">//指示垃圾回收器回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="built_in">bool</span> Flag</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(DisposeFlag==<span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//释放过了就不再次释放</span></span><br><span class="line"></span><br><span class="line">        ······  <span class="comment">//&lt;===释放非托管资源的代码</span></span><br><span class="line">        <span class="keyword">if</span>(Flag==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ······  <span class="comment">//&lt;===释放托管资源的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        DisposeFlag = <span class="literal">true</span>;  <span class="comment">//已释放标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你的类实现了IDisposable接口的时候，为了即使是发生异常也应该释放资源，应当使用using语句。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span>(HIE temp=<span class="keyword">new</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ······  <span class="comment">//&lt;===你的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会将using语句转换为</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">HIE temp=<span class="keyword">new</span>()</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ······  <span class="comment">//&lt;===你的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp!=<span class="literal">null</span>) temp.Dispose();</span><br><span class="line">    <span class="comment">//即使发生错误也会调用Dispose()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>C#语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C#语法基础（六）</title>
    <url>/2022/01/22/CsharpGrammar06/</url>
    <content><![CDATA[<img src="/2022/01/22/CsharpGrammar06/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议先学习C++基础再进行C#的学习。</div>
</div>

<span id="more"></span>

<h2 id="十四、多态相关"><a href="#十四、多态相关" class="headerlink" title="十四、多态相关"></a><strong>十四、多态相关</strong></h2><p>C#中存在如下的关键字：</p>
<ol>
<li>new，子类同名函数覆盖父类函数，仅在子类中生效。</li>
<li>virtual，父类函数声明可以被重写。</li>
<li>override，子类重写父类函数，在父类中也生效。</li>
<li>sealed，被此修饰的函数或类将不会被继承。</li>
<li>abstract，声明类或函数为抽象的。抽象函数只能存在于抽象类中。</li>
</ol>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>new与override的区别</strong></div>

<div style="color:goldenrod;">

<ul>
<li>以new关键字覆盖父类函数时，不需要父类声明了函数为virtual。相应地，父类调用这个函数时不会调用子类的new函数。</li>
<li>要使用override关键字则要求父类要么是抽象类，要么声明了virtual。父类在调用函数时，会调用子类的override函数。</li>
</ul>
</div>
</div>

<p>对于以sealed声明了的类，虽然不能继承这个类，不过有方法能够扩展它。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MainProcess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> temp = <span class="string">&quot;Beatless&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;temp.LengthCount()&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="comment">//此处直接以string类型调用Lacia类中定义的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Lacia</span>  <span class="comment">//&lt;===static类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">LengthCount</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> Input</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">//函数声明中参数加了this</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Input.Length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this关键字，用于指明参数中的哪个类是可以通过“.”来直接调用函数的。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>扩展类的条件</strong></div>

<div style="color:goldenrod;">使用这种方法扩展sealed类，必须要将扩展类声明为static。</div>
</div>

<h2 id="十五、反编译"><a href="#十五、反编译" class="headerlink" title="十五、反编译"></a><strong>十五、反编译</strong></h2><ol>
<li>在Visual Studio Code中，选择扩展，搜索ilspy，安装下图所示的扩展。<br><img src="/2022/01/22/CsharpGrammar06/1.png" alt="1 &quot;1&quot;" title="2"><br>这个扩展是反编译用的扩展。它可以将已经编译完的.exe或者.dll反编译成C#代码或者中间语言（IL）代码。</li>
<li>安装完以后，按Shift+Ctrl+P，输入ilspy。<br><img src="/2022/01/22/CsharpGrammar06/2.png" alt="2 &quot;2&quot;" title="2"><br>选择Pick assembly from file system。</li>
<li>选定你想要反编译的.exe或者.dll文件，打开后在此处查看它。<br><img src="/2022/01/22/CsharpGrammar06/3.png" alt="3 &quot;3&quot;" title="3"><br>在右上角三角播放标志右侧，你可以切换是反编译为C#还是中间语言。</li>
</ol>
<h2 id="十六、常见的函数与类"><a href="#十六、常见的函数与类" class="headerlink" title="十六、常见的函数与类"></a><strong>十六、常见的函数与类</strong></h2><h3 id="1-大数处理"><a href="#1-大数处理" class="headerlink" title="(1) 大数处理"></a><strong>(1) 大数处理</strong></h3><h4 id="Ⅰ-整数"><a href="#Ⅰ-整数" class="headerlink" title="Ⅰ. 整数"></a><strong>Ⅰ. 整数</strong></h4><p>可以使用定义在System.Numerics下的类BigInteger。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">BigInteger temp = BigInteger.Parse(<span class="string">&quot;114514191981081363573948724834236811766972113571366712425316373543202&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;temp&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>BigInteger类能够存储任意的大整数而不会发生溢出，并且内置了加减乘除等运算。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>BigInteger的局限</strong></div>

<div style="color:goldenrod;">BigInteger只能存储整数而不能存储小数与复数。</div>
</div>

<h4 id="Ⅱ-复数"><a href="#Ⅱ-复数" class="headerlink" title="Ⅱ. 复数"></a><strong>Ⅱ. 复数</strong></h4><p>可以使用定义在System.Numerics下的类Complex。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Complex a = <span class="keyword">new</span>(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">Complex b = <span class="keyword">new</span>(<span class="number">1919</span>, <span class="number">810</span>);</span><br><span class="line">Complex c = a * b;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;c&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同样，Complex也能存储任意大小的复数。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>Complex的局限</strong></div>

<div style="color:goldenrod;">Complex可以存储小数，但是它的小数精度并不高</div>
</div>

<h3 id="2-字符串处理"><a href="#2-字符串处理" class="headerlink" title="(2) 字符串处理"></a><strong>(2) 字符串处理</strong></h3><h4 id="Ⅰ-Split"><a href="#Ⅰ-Split" class="headerlink" title="Ⅰ. Split()"></a><strong>Ⅰ. Split()</strong></h4><p>与Python相似，C#的string类定义了一个成员函数Split，用于分割字符串。其返回值是一个string数组。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> HIE = <span class="string">&quot;Kouka,Lacia,Method,Teresa&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] HIES = HIE.Split(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">//以逗号为界分割字符串</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> temp <span class="keyword">in</span> HIES)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;temp&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ-IndexOf函数"><a href="#Ⅱ-IndexOf函数" class="headerlink" title="Ⅱ. IndexOf函数"></a><strong>Ⅱ. IndexOf函数</strong></h4><p>此函数用于寻找string中的字串的索引值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> HIE = <span class="string">&quot;Kouka,Lacia,Method,Teresa&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> HIES = HIE.IndexOf(<span class="string">&quot;,L&quot;</span>);</span><br><span class="line">Console.WriteLine(HIES);</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>关于IndexOf</strong></div>

<div style="color:royalblue;">IndexOf有很多重载函数，其功能就不一一介绍了。</div>
</div>

<h4 id="Ⅲ-Substring"><a href="#Ⅲ-Substring" class="headerlink" title="Ⅲ. Substring()"></a><strong>Ⅲ. Substring()</strong></h4><p>这个函数有两个重载函数。</p>
<ol>
<li>Substring(int i,int n)，返回从第i个字符（包含）开始的长度为n的字符串。</li>
<li>Substring(int i)，返回从第i个字符（包含）开始到结束的字符串。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> HIE = <span class="string">&quot;Kouka,Lacia,Method,Teresa&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> HIES = HIE.Substring(<span class="number">6</span>,<span class="number">5</span>);</span><br><span class="line">Console.WriteLine(HIES);</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>处理字符串的其他函数</strong></div>

<div style="color:royalblue;">关于处理字符串的函数还有许多，此处省略了其中的大部分。关于详细信息，可以查询 <a class="btn" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0 ">Microsoft官方文档</a> 。</div>
</div>

<h3 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="(3) 正则表达式"></a><strong>(3) 正则表达式</strong></h3><p>想要检查输入的字符串是否符合需求？那就使用正则表达式吧。定义在System.Text.RegularExpress下的类Regex就是可以用正则表达式检测字符串规范的一个类。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Regex checker = <span class="keyword">new</span>(<span class="string">@&quot;^\d+$&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(checker.IsMatch(Console.ReadLine())==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;不输入数字是吧，那就别想出去.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>禁用转义字符</strong></div>

<div style="color:royalblue;">之前提到过，以$修饰的字符串，其中的“{}”中的内容将被视为变量，字符串将会把它替换为变量的值。与此相似，以@修饰的字符串，将会禁用其中所有的转义字符。书写Windows路径的时候你可以使用@字符，非常方便。</div>
</div>

<p>禁用转移字符以后，就可以用正则表达式的方式去解释“\”。</p>
<p>以下是常见的正则表达式的符号：</p>
<ol>
<li>“^”，指示输入的开始</li>
<li>“\d”，表示单个数字</li>
<li>“\w”，表示空白</li>
<li>“[A-Z]”，表示这个字符的取值范围</li>
<li>“[（任意的字符）]”，表示这个字符能取的值</li>
<li>“.”，表示任意单个字符</li>
<li>“$”，表示输入的结束</li>
<li>“\D”，表示不是数字的任意字符</li>
<li>“\W”，表示非空白的任意字符</li>
<li>“[^（任意的字符）]”，这个字符不能取的值</li>
<li>“.”，表示“.”字符</li>
<li>“^”，表示“^”字符</li>
<li>“+”，表示一个或者多个</li>
<li>“{i}”，表示正好i个字符</li>
<li>“{i,}”，不少于i个字符</li>
<li>“{,i}”，不多于i个字符</li>
<li>“{i,j}”，字符数应在i~j之间</li>
<li>“?”，有一个字符或者没有字符</li>
<li>“|”，对两个条件取或。</li>
</ol>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>没看明白？</strong></div>

<div style="color:royalblue;">关于正则表达式的详细语法，请参见 <a class="btn" href="https://www.runoob.com/regexp/regexp-syntax.html ">菜鸟教程</a> 。</div>
</div>

<h3 id="3-集合"><a href="#3-集合" class="headerlink" title="(3) 集合"></a><strong>(3) 集合</strong></h3><p>类似C++有STL一样，C#中也有很多好用的模板类，它们被称为集合。此处就只讲其常见函数。</p>
<h4 id="Ⅰ-List-lt-T-gt"><a href="#Ⅰ-List-lt-T-gt" class="headerlink" title="Ⅰ. List&lt;T&gt;"></a><strong>Ⅰ. List&lt;T&gt;</strong></h4><p>其实就是C++的线性表</p>
<ol>
<li>Add(T)，添加元素</li>
<li>Insert(int i,T)，在第i个位置插入元素</li>
<li>RemoveAt(int i)，删除第i个元素</li>
<li>Remove(T)，删除与参数值相同的第一个元素</li>
</ol>
<h4 id="Ⅱ-Dictionary-lt-A-B-gt"><a href="#Ⅱ-Dictionary-lt-A-B-gt" class="headerlink" title="Ⅱ. Dictionary&lt;A,B&gt;"></a><strong>Ⅱ. Dictionary&lt;A,B&gt;</strong></h4><p>其实就是C++的map</p>
<ol>
<li>Add(A,B)，添加键-值对</li>
<li>Remove(A)，删除键-值对</li>
<li>Remove(A,out B)，删除键-值对并返回值</li>
</ol>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>其它的数据结构</strong></div>

<div style="color:royalblue;">当然C#也有自带的堆、队列等类，它们的函数都较为接近，且学过数据结构的同学应该不会对它们感到疑惑。此处不再赘述</div>
</div>

<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">至此C#的基础笔记就到此为止了。这些确实是C#的“基础”，基础得不能再基础了——因为C#还有诸如图形化编程、网络通信、编码、网站设计等高级应用方式。而这个系列的笔记对高级应用几乎只字未提。如果要学习更高级的C#应用方式，那么你应该提前下载Visual Studio，而不是使用VS Code。这个系列的笔记只是个抛砖引玉，还望各位读者指正。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>C#语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（一）</title>
    <url>/2022/01/17/DasKapital01/</url>
    <content><![CDATA[<img src="/2022/01/17/DasKapital01/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h1 style="text-align:center;"><strong>第一卷</strong></h1>

<h2 id="一、商品与货币"><a href="#一、商品与货币" class="headerlink" title="一、商品与货币"></a><strong>一、商品与货币</strong></h2><h3 id="商品"><a href="#商品" class="headerlink" title="商品"></a><strong>商品</strong></h3><p>①商品是为了进行交换而生产出来的劳动产品。<br>②商品必须对社会或者他人有用。<br>③商品的价值与使用价值，并非商品本身的属性而是其社会性质。</p>
<h3 id="使用价值"><a href="#使用价值" class="headerlink" title="使用价值"></a><strong>使用价值</strong></h3><p>①物体能被用于满足人类的某种需要，物体就具有使用价值。<br>②物可以有使用价值而没有价值。</p>
<div class="note info"><div style="color:royalblue;">例如空气。空气具有使用价值，因为是个人都要呼吸，需要使用空气；但是空气却没有价值，因为空气普遍存在于我们身边，不需要任何劳动就能获取。</div>
</div>

<p>③商品的使用价值来源于人类的具体劳动。<br>④商品的使用价值是商品的交换价值的物质载体。</p>
<h3 id="价值"><a href="#价值" class="headerlink" title="价值"></a><strong>价值</strong></h3><p>只有人类的抽象劳动 <em>（不是某一具体的劳动）</em> 才会产生价值。</p>
<h3 id="交换价值"><a href="#交换价值" class="headerlink" title="交换价值"></a><strong>交换价值</strong></h3><p>①交换价值为一种价值与另一种价值交换的比例。</p>
<div class="note info"><div style="color:royalblue;">例如1把镰刀可以换1把斧头，此时1把镰刀的交换价值为1把斧头。</div>
</div>

<p>②本质是一种社会关系。</p>
<h3 id="具体劳动"><a href="#具体劳动" class="headerlink" title="具体劳动"></a><strong>具体劳动</strong></h3><div class="note info"><div style="color:royalblue;">例如写代码、搬砖等具体的劳动。</div>
</div>

<p>①它产生了商品的使用价值。<br>②它与抽象劳动伴生，有具体劳动就有抽象劳动，二者对立统一。</p>
<h3 id="抽象劳动"><a href="#抽象劳动" class="headerlink" title="抽象劳动"></a><strong>抽象劳动</strong></h3><p>①与“具体”相对，它是人类的劳动总和，不论形式。<br>②它产生了商品的价值。<br>③它与具体劳动伴生，有抽象劳动就有具体劳动，二者对立统一。</p>
<h3 id="社会必要劳动时间"><a href="#社会必要劳动时间" class="headerlink" title="社会必要劳动时间"></a><strong>社会必要劳动时间</strong></h3><p>①整个社会为了生产一个单位的某种商品，而耗费的劳动时间的平均数。<br>②它的大小决定了商品的交换价值。</p>
<div class="note info"><div style="color:royalblue;">即：单位时间内生产越多的商品，越不值钱，越难生产的商品，越值钱。</div>
</div>

<h3 id="简单的价值形式"><a href="#简单的价值形式" class="headerlink" title="简单的价值形式"></a><strong>简单的价值形式</strong></h3><p>一种商品只能交换一种商品，这就是简单的价值形式。</p>
<div class="note info"><div style="color:royalblue;">1把镰刀只能换到1把斧头而换不到其它商品。</div>
</div>

<h3 id="相对价值形式"><a href="#相对价值形式" class="headerlink" title="相对价值形式"></a><strong>相对价值形式</strong></h3><p>价值被表现的商品，处于相对价值形式。</p>
<div class="note info"><div style="color:royalblue;">例如：1把镰刀值1把斧头（单向交换），此时镰刀处于相对价值形式，其价值表现在了斧头上。通俗点讲，1把镰刀10元，10元展现了镰刀的价值。</div>
</div>

<h3 id="等价价值形式"><a href="#等价价值形式" class="headerlink" title="等价价值形式"></a><strong>等价价值形式</strong></h3><p>表现的价值的商品，处于等价价值形式。</p>
<div class="note info"><div style="color:royalblue;">例如：1把镰刀值1把斧头（单向交换），此时斧头处于等价价值形式，其使用价值表现在了镰刀上。通俗点讲，1把镰刀10元，镰刀展现了10元的使用价值（即能拿去买10元的东西），而不是用于收割的使用价值。</div>
</div>

<h3 id="扩大的价值形式"><a href="#扩大的价值形式" class="headerlink" title="扩大的价值形式"></a><strong>扩大的价值形式</strong></h3><p>一种商品可以交换多种商品，但是反过来则不行，这就是扩大的价值形式。</p>
<div class="note info"><div style="color:royalblue;">随着生产力的进步与商品生产的扩大，用于交换的商品越来越多，此时1把镰刀不仅能交换1把斧头，还能交换0.5kg的Fe、2kg的Cu、或1只鸡。此时镰刀的价值展现在了多种商品上，而镰刀本身展现出了多种商品的使用价值。这种价值形式存在缺陷。通俗点讲，1把镰刀值10元，也值1.6美元、1.4欧元、1.2英镑。但是我想要1.6美元，可是我没有镰刀，由于不能多种商品交换一种商品，即1.6美元只能由镰刀交换，所以我还得想法设法去换镰刀。</div>
</div>

<h3 id="一般的价值形式"><a href="#一般的价值形式" class="headerlink" title="一般的价值形式"></a><strong>一般的价值形式</strong></h3><p>①多种商品可以交换一种商品，这就是一般的价值形式。<br>②由于扩大的价值形式存在缺陷，便注定了扩大的价值形式必然要过渡到一般的价值形式（或者扩大的价值形式就不曾存在过）。</p>
<div class="note info"><div style="color:royalblue;">此时1把斧头，还能交换0.5kg的Fe、2kg的Cu、或1只鸡都能交换1把镰刀。此时镰刀展现了多种商品的价值，而多种商品的使用价值表现为镰刀的使用价值。但请注意交换的方向反了。此时镰刀成为了上述商品的一般等价物，可以用于衡量上述商品之间的价值。</div>
</div>

<h3 id="货币形式"><a href="#货币形式" class="headerlink" title="货币形式"></a><strong>货币形式</strong></h3><p>①商品的价值与使用价值统一而又矛盾——即商品不能同时表现价值与使用价值，为了缓和这种矛盾，便产生了货币。<br>②货币被其他商品排挤出来成为一般等价物，同时又能表现其它商品的价值。即其它商品能换货币，货币也能换其它商品。货币形式与一般价值形式没有本质区别，只不过货币形式中一般等价物固定为了金和银。<br>③金（此处我没用货币，因为谈到货币我们一般会想到纸币，也就是信用货币）的价值源自于在一定时间内生产一定量的金需要消耗一定量的劳动。金和其他商品一样，遵循上述的“单位时间内生产越多的商品，越不值钱，越难生产的商品，越值钱”的定律。即——金生产效率越高，金的价值就会变低，当其他商品价值不变（生产效率不变）时，相对的商品价格抬高。当金的生产效率和商品生产效率以相同比例同时增加或降低，商品的价格就会相对不变。</p>
<div class="note info"><div style="color:royalblue;">不难联想到现代信用货币的通货膨胀——印钞速度太快，货币贬值；印钞速度太慢，通货紧缩。不过现代信用货币的通货膨胀和通货紧缩还有些其他的因素。</div>
</div>

<h3 id="商品的交换"><a href="#商品的交换" class="headerlink" title="商品的交换"></a><strong>商品的交换</strong></h3><p>①商品在其发挥使用价值之前，必须先以价值实现交换。</p>
<div class="note info"><div style="color:royalblue;">通俗地讲，1把镰刀值10块，这把镰刀在发挥其收割的使用价值之前必须先与10元交换。</div>
</div>

<p>②不与其他商品交换的劳动产品，不能算作商品。商品对于其所有者具有价值，但是不具有直接的使用价值。<br>③商品的交换是一般社会的过程。</p>
<h3 id="货币的价值尺度"><a href="#货币的价值尺度" class="headerlink" title="货币的价值尺度"></a><strong>货币的价值尺度</strong></h3><p>货币可以衡量商品的价值。</p>
<div class="note info"><div style="color:royalblue;">通俗点讲，假定，只是假定，1吨黄金值1亿元，但是我怎么可能有1个亿，所以拿不出1亿元的现金，但是我们却知道1吨黄金值1亿元，这里的1亿元并不实际存在，是想象的货币。此时货币执行了其价值尺度。</div>
</div>

<h3 id="货币的流通手段"><a href="#货币的流通手段" class="headerlink" title="货币的流通手段"></a><strong>货币的流通手段</strong></h3><p>①W-G-W，W指商品，G指货币。商品交换为货币，再用货币买到需要的商品，为买而卖，买卖对立统一。<br>②商品的直接交换，买卖处于同一行为；而货币化的商品交换，买卖之间分离了。<br>③货币流通速度表现了商品形式变换的速度。</p>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（二）</title>
    <url>/2022/01/21/DasKapital02/</url>
    <content><![CDATA[<img src="/2022/01/21/DasKapital02/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="一、商品与货币（续）"><a href="#一、商品与货币（续）" class="headerlink" title="一、商品与货币（续）"></a><strong>一、商品与货币（续）</strong></h2><h3 id="货币的贮藏手段"><a href="#货币的贮藏手段" class="headerlink" title="货币的贮藏手段"></a><strong>货币的贮藏手段</strong></h3><p>①由于货币可以换取所有的商品，也就意味着所有商品的使用价值都可以通过货币表现出来，而使用价值能够满足人的直接需求，因此出现了人们出售商品换取货币，执行W-G过程但却暂时不执行G-W，即用货币购买商品的过程。此时货币成为了贮藏货币，执行其贮藏功能。</p>
<div class="note info"><div style="color:royalblue;">通俗地讲，货币能买到所有商品，所以贮藏货币就相当于贮藏了所有种类的商品，在需要时直接拿货币换取商品即可。在这个阶段，货币成为了财富的社会表现，拥有的货币越多，阶级地位就越高，权力就越大。</div>
</div>

<p>②货币作为财富的一般代表，货币能直接转化为任何商品，在质上是无限的；而现实的货币额度是有限的，只是一种作用有限的购买手段。货币的这种质的无限性和量的有限性的内在矛盾迫使货币贮藏者不断地累积货币、贮藏货币。<br>③如果银行准备库内的货币贮藏量大大超过平均水平，则说明商品流通停滞，或商品形态变化的流通已经中断。</p>
<h3 id="货币的支付手段"><a href="#货币的支付手段" class="headerlink" title="货币的支付手段"></a><strong>货币的支付手段</strong></h3><p>①金不需要以实体形式出现即可用于购买商品，即赊账，或称之为欠债、债券。在这个过程中，商品的流通（货到手了）和商品价值的实现（钱到手了）分离。</p>
<div class="note info"><div style="color:royalblue;">在上述过程中：

<ol>
<li>卖者（债权人，放债者）把商品变为货币，是为了通过贮藏货币来满足某种需要，并以货币形式保存商品。</li>
<li>买者（债务人，欠债者）把商品变为货币，是为了支付欠款。</li>
</ol>
</div>
</div>

<p>②由于流通过程中本身的关系产生的社会必要性，商品的价值形式（即货币）就成了卖的目的本身。<br>③货币荒：即金融危机的一种。执行支付手段的货币，在各种支付互相抵消的时候只需要在观念上执行计算货币，但是到了实际支付的时候却不再是商品流通的媒介，而是成为了社会劳动的化身，是绝对的商品。这种内在的矛盾会在危机爆发时迅速蔓延开。</p>
<div class="note info"><div style="color:royalblue;">通俗点讲，欠债的时候不需要真的拿出欠的钱，而是可以之后再支付。此时的“观念上的钱”，或者叫债务仍然是商品流通的媒介。但是当债务人必须实际支付所欠的债时，这笔钱代表了债权人所有的“价值”，是实际存在的商品。这种既是“传播媒介”又是商品本体的内在矛盾，导致了金融危机。2008年金融危机（次贷危机）即为债务人无力偿还债务，债权人同时又是大量欠债的债务人，债务无力偿还的链锁导致了大规模的货币荒，大家都成了穷人。而如果将这些债务锁链互相抵消，不会有如此大规模的贫穷现象出现。</div>
</div>

<p>④债券的不断演化，最终将会形成信用货币，取代金的地位。</p>
<div class="note info"><div style="color:royalblue;">现代信用货币的价值锚定标准曾是黄金，后来是石油，而现在则是政府信用。</div>
</div>

<p>⑤在商品生产达到一定水平和规模时，货币作为支付手段将超出商品流通领域。原本需要以实物缴纳的各种租金与赋税，则由缴纳货币代替了。<br>⑥必须贮藏货币，才能够按期偿还债务。随着资产阶级社会的发展，货币的贮藏作为独立的致富形式渐渐转变为用于作为支付手段的准备金。</p>
<h3 id="世界货币"><a href="#世界货币" class="headerlink" title="世界货币"></a><strong>世界货币</strong></h3><p>世界货币的主要职能是平衡国际贸易差额。当两国的贸易货物的价值不对等时，世界货币以商品的形式为顺差国补足差值。</p>
<h3 id="资本"><a href="#资本" class="headerlink" title="资本"></a><strong>资本</strong></h3><p>①作为货币的货币与作为资本的货币，两者的流动形式不同。前者是W-G-W，为买而卖，最终目的是换得所需商品；后者是G-W-G，为卖而买，最终目的是换得更多货币。<br>②用货币购买商品再换回等价的货币是毫无意义的，人把货币投入这个循环是为了获取更多的货币，即G-W-(G+$\Delta$ G)。其中的$\Delta$ G即为剩余价值。能够带来剩余价值的货币即为资本，其所有者即为资本家。</p>
<h3 id="剩余价值"><a href="#剩余价值" class="headerlink" title="剩余价值"></a><strong>剩余价值</strong></h3><p>①在自然流通中，以等价交换交易的双方，商品的价值应该是相等的，即G-W，再W-G以后，G的值应该是不变的。即便是非等价交换，一方的价值增加意味着一方的价值减少。流通中没有劳动，即总的价值是不变的。所以，剩余价值不会在商品的流通中产生。<br>②剩余价值的产生离不开商品流通，因为G-W-G的过程需要流通。<br>③商品本身的价值，即为包含着的商品生产者的劳动量。生产者可以创造价值，但是不能创造出超出商品本身价值的剩余价值。</p>
<div class="note info"><div style="color:royalblue;">即：劳动者能够创造价值，但是不能创造增殖的价值。</div>
</div>

<p>④货币所有者要想将货币转化为资本，取得剩余价值，就必须在流通中找到一种特殊的商品，这种商品的使用价值本身就是价值的源泉，可以不断创造价值，并且能创造的价值比它本身的价值更大。这种特殊商品就是劳动力。</p>
<div class="note info"><div style="color:royalblue;">货币转化为资本就是以劳动力变成商品为基础的。劳动者有权支配自己的劳动力并把它作为商品出卖，但劳动者除了自己的劳动力以外一无所有，所以劳动者只能贩卖自己的劳动力。</div>
</div>

<h3 id="劳动力（商品）"><a href="#劳动力（商品）" class="headerlink" title="劳动力（商品）"></a><strong>劳动力（商品）</strong></h3><p>①作为商品的劳动力，与其它一切商品相同，都具有价值与使用价值。<br>②劳动力只能作为活的个体存在，因此劳动力的价值将由产生劳动力与维持劳动力的社会必要劳动时间决定。</p>
<div class="note info"><div style="color:royalblue;">产生劳动力与维持劳动力，即劳动力的再生产。说的通俗一点，就是人要吃饭，不吃饭没力气；还要生儿育女，不然劳动力死了就没有新的劳动力补充了。</div>
</div>

<p>③劳动力的价值包括：</p>
<ol>
<li>劳动者本人生产与再生产劳动力所必需的生活资料的价值。</li>
<li>劳动者养育后代所必需的生活资料的价值。</li>
<li>劳动者为了适应生产而必须学习一定的技能，由此产生的学习费用。</li>
</ol>
<div class="note info"><div style="color:royalblue;">即，劳动力的价值就是让劳动者吃饱饭，养活孩子和读书学习所消耗的价值。学历越高工资越高其实也符合这个规律，因为这是劳动力本身所蕴含的价值。</div>
</div>

<p>④作为商品，劳动力是特殊的。因为劳动力在使用过程中能创造出比自身价值更高的价值。这部分价值本应属于劳动者，而资本家却将其据为己有，这部分价值也就成了剩余价值。<br>⑤在流通中，资本家与劳动者分别以劳动力的买者与卖者身份发生关系。从表面上看这种关系是自由且平等的，因为劳动力愿意卖而资本家愿意买，双方也是平等地进行交易。但当双方离开流通领域，这种自由与平等的假象就暴露无遗。</p>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（三）</title>
    <url>/2022/01/22/DasKapital03/</url>
    <content><![CDATA[<img src="/2022/01/22/DasKapital03/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="二、绝对剩余价值"><a href="#二、绝对剩余价值" class="headerlink" title="二、绝对剩余价值"></a><strong>二、绝对剩余价值</strong></h2><div class="note info"><div style="color:royalblue;">通过延长工作日的长度而生产的剩余价值，是绝对剩余价值。</div>
</div>

<h3 id="劳动三要素"><a href="#劳动三要素" class="headerlink" title="劳动三要素"></a><strong>劳动三要素</strong></h3><p>任何劳动过程都包含三点要素：</p>
<ol>
<li>劳动本身（有目的性的活动）</li>
<li>劳动对象</li>
<li>劳动资料</li>
</ol>
<h3 id="原料"><a href="#原料" class="headerlink" title="原料"></a><strong>原料</strong></h3><p>曾被加工过的劳动对象，叫作原料。</p>
<div class="note info"><div style="color:royalblue;">例如，天然矿石不是原料，因为它本就存在于自然之中，没有经过人的加工。而已经开采出来的原矿，则属于原料，因为它经过了人的加工。</div>
</div>

<p>一切原料都属于劳动对象，而劳动对象不一定是原料。</p>
<h3 id="劳动资料"><a href="#劳动资料" class="headerlink" title="劳动资料"></a><strong>劳动资料</strong></h3><p>劳动资料是劳动者与劳动对象之间的物，它将劳动者的劳动传递到劳动对象上。</p>
<div class="note info"><div style="color:royalblue;">例如，工人的锤子、农民的镰刀、土地就属于劳动资料。请注意，生产资料与劳动资料不是同一概念。劳动资料属于生产资料。</div>
</div>

<p>广义上的劳动资料，包含了在劳动过程中所需的一切物质条件。</p>
<div class="note info"><div style="color:royalblue;">例如，办公室也是广义上的劳动资料，因为程序员不可能露天工作。</div>
</div>

<h3 id="劳动过程的不变性"><a href="#劳动过程的不变性" class="headerlink" title="劳动过程的不变性"></a><strong>劳动过程的不变性</strong></h3><p>①劳动是产生使用价值的有目的性的活动。<br>②劳动是人类为了需要而占有自然物，从而与自然发生物质交换的条件。<br>③劳动是人类正常生活的永恒条件。</p>
<p>因此，劳动是一切社会形式都必需的，不论在什么生产方式之下。</p>
<h3 id="资本主义下的劳动"><a href="#资本主义下的劳动" class="headerlink" title="资本主义下的劳动"></a><strong>资本主义下的劳动</strong></h3><p>①在资本主义条件下，劳动力是一种商品，资本家是买家，需要消费这种商品。劳动过程就是资本家消费劳动力的过程。<br>②工人的劳动属于资本家。因为资本家已经购买了劳动力。在劳动中，工人只能按资本家的要求去做。</p>
<div class="note info"><div style="color:royalblue;">被资本家消费的劳动力，就成为了工人。</div>
</div>

<p>③工人的劳动产品属于资本家，而不属于工人。资本家将工人的劳动看作是和生产资料一样的生产要素，而资本主义的劳动过程就是生产要素的结合过程。因此这个过程的产品将归资本家所有。</p>
<div class="note info"><div style="color:royalblue;">资本家将劳动力看成是和生产资料相同的商品，在购买它们之后就成为了商品的所有者。将商品结合之后的产物，自然全都属于资本家。</div>
</div>

<h3 id="资本家的目的是交换价值"><a href="#资本家的目的是交换价值" class="headerlink" title="资本家的目的是交换价值"></a><strong>资本家的目的是交换价值</strong></h3><p>资本家生产产品，不是为了得到产品本身。产品的使用价值对资本家毫无吸引力，资本家之所以要生产使用价值，是因为使用价值是交换价值的物质基础与物质承担者。</p>
<div class="note info"><div style="color:royalblue;">富士康生产手机，并不是因为富士康的老板想要手机，而是因为富士康的老板想要用手机换钱。</div>
</div>

<h3 id="一般的价值形成过程"><a href="#一般的价值形成过程" class="headerlink" title="一般的价值形成过程"></a><strong>一般的价值形成过程</strong></h3><p>①在价值形成的过程中，资本家只关心如下两点：</p>
<ol>
<li>生产的产品必须具有交换价值，因为产品是用来出售的物品，即商品。</li>
<li>生产的产品价值应该大于生产资料价值与劳动力价值的总和。资本家不仅要生产使用价值，还要生产价值和剩余价值。</li>
</ol>
<p>②商品是使用价值与价值的统一体；商品生产过程是劳动过程与价值形成过程的统一过程。</p>
<div class="note info"><div style="color:royalblue;">举个例子。假设：一个工人的一日劳动力价值，也就是日工资是50元。工人一天劳动6小时，他能在6小时的工作时间内创造出与50元等价的价值。机器等工具因磨损折价5元，原材料成本25元，那么产品的总价值就是50+5+25=80（元）。但是资本家卖出这些产品得到的80元，等于他所支付的成本。资本家没有赚到钱。</div>
</div>

<h3 id="价值增殖过程"><a href="#价值增殖过程" class="headerlink" title="价值增殖过程"></a><strong>价值增殖过程</strong></h3><p>①由于劳动力的价值小于劳动力创造的价值，因此资本家只需支付劳动力一天的价值，就能够占有劳动力一天创造出来的价值。因此资本家会让工人尽可能的延长工作时间。</p>
<div class="note info"><div style="color:royalblue;">之前的笔记已经详细叙述过了，劳动力的价值等于劳动力再生产所需的消费品的价值。而劳动力能创造出来的价值，远比这高。</div>
</div>

<p>②还是上面的例子，工人的日工资同样是他的一日劳动力价值50元。只不过，这次工人需要工资12小时。工人工作12小时，创造的价值为100元，机器等工具磨损折价10元（因为工作时间翻倍了），原材料成本50元。产品总价值为100+10+50&#x3D;160（元），而成本为50+10+50&#x3D;110（元）。这多出来的50元，就是剩余价值。</p>
<div class="note info"><div style="color:royalblue;">剩余价值统统进了资本家的腰包。而这本来应该属于工人所有。</div>
</div>

<p>③工人的劳动形式与价值的增殖过程没有关系。不论是什么形式的工作，在用于补偿自身的劳动力价值的劳动与创造剩余价值的劳动这两者上，都没有本质上的区别。</p>
<div class="note info"><div style="color:royalblue;">不论你是公司高管、高级程序员或者码农，还是搬砖的农民工，抑或在富士康流水线上的工人，你们的劳动都可以分为上述两段劳动。</div>
</div>

<p>④创造剩余价值的这一段劳动，称为剩余劳动。</p>
<h3 id="工人劳动的二重性"><a href="#工人劳动的二重性" class="headerlink" title="工人劳动的二重性"></a><strong>工人劳动的二重性</strong></h3><p>①劳动过程中，工人将自己的劳动消耗到劳动对象上，同时被消耗的生产资料的使用价值转移到了产品的使用价值中。这两个过程是同一时间在同一劳动中发生的。<br>②具体劳动将生产资料的使用价值转移到产品的使用价值中，而抽象劳动则创造新的价值。具体劳动与抽象劳动是同一个劳动过程的两面。</p>
<div class="note info"><div style="color:royalblue;">铁匠的具体劳动就是锻造铁，消耗了生铁，磨损了锻造台与锤子。消耗的生铁、折旧的生产工具的使用价值，被转移到了熟铁的使用价值中，这是由锻造这个具体动作完成的。而铁匠劳动了，所以熟铁中蕴含了新的、更多的价值。</div>
</div>

<p>③生产过程中，生产资料的使用价值损失导致其相应的价值丧失，这个丧失量绝不会小于生产资料转移给产品的价值。</p>
<p>④如果生产资料本身不是人类劳动的产品，那么它就不会有任何价值转移到产品中去。它只能充当使用价值的形成要素而不能充当交换价值的形成要素。</p>
<p>⑤生产资料的使用价值被消耗而价值保留了下来。因为生产资料的使用价值被改造为产品的使用价值，而使用价值是价值的物质载体，所以价值本身被保存下来，体现在产品的价值中。</p>
<h3 id="不变资本"><a href="#不变资本" class="headerlink" title="不变资本"></a><strong>不变资本</strong></h3><p>用于购买原材料、辅助材料、劳动资料等生产资料的资本，由于其本身的价值量在生产过程中并没有改变，只会发生转移，是不变资本。</p>
<h3 id="可变资本"><a href="#可变资本" class="headerlink" title="可变资本"></a><strong>可变资本</strong></h3><p>用于雇佣劳动力的资本，在生产过程中，它的价值量增加了，是可变资本。可变资本再生产超出自身价值而形成的余额，即为剩余价值。</p>
<h3 id="剩余价值率"><a href="#剩余价值率" class="headerlink" title="剩余价值率"></a><strong>剩余价值率</strong></h3><p>$$剩余价值率&#x3D;\frac{剩余价值}{可变资本}&#x3D;1-\frac{工人工资}{工人创造的价值}$$</p>
<p>剩余价值率体现了工人被剥削的程度。越高工人被剥削得越惨。</p>
<h3 id="必要劳动与必要劳动时间"><a href="#必要劳动与必要劳动时间" class="headerlink" title="必要劳动与必要劳动时间"></a><strong>必要劳动与必要劳动时间</strong></h3><p>在工人一天的劳动中，其中一部分劳动是工人生产自己的劳动力的价值的劳动，或者说是生产他必要生活资料价值的劳动。这部分劳动的价值与其日工资的价值相等，称为必要劳动，所耗费的时间称为必要劳动时间。</p>
<h3 id="剩余劳动与剩余劳动时间"><a href="#剩余劳动与剩余劳动时间" class="headerlink" title="剩余劳动与剩余劳动时间"></a><strong>剩余劳动与剩余劳动时间</strong></h3><p>工作日中超出必要劳动的时间的劳动，不会为工人形成任何价值，只会为资本家形成价值。这一部分劳动称为剩余劳动，所耗费的时间称为剩余劳动时间。</p>
<div class="note info"><div style="color:royalblue;">剥削阶级对直接生产者的剥削内容亘古不变，即榨取剩余劳动，它们的区别只在于榨取剩余劳动的形式不同。奴隶制社会通过强迫奴隶劳动以榨取剩余劳动；封建社会地主向农民收租金以榨取剩余劳动；而资本主义则是通过让工人创造剩余价值以榨取剩余劳动。</div>
</div>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（四）</title>
    <url>/2022/01/23/DasKapital04/</url>
    <content><![CDATA[<img src="/2022/01/23/DasKapital04/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="二、绝对剩余价值（续）"><a href="#二、绝对剩余价值（续）" class="headerlink" title="二、绝对剩余价值（续）"></a><strong>二、绝对剩余价值（续）</strong></h2><h3 id="工作日"><a href="#工作日" class="headerlink" title="工作日"></a><strong>工作日</strong></h3><p>①在资本主义生产方式下，必要劳动始终只能是工人工作日的一部分。</p>
<div class="note info"><div style="color:royalblue;">如果工作日长度与必要劳动的时间相等，那么资本家就无从榨取剩余劳动。</div>
</div>

<p>②工作日的最低界限为必要劳动的时间，最高界限为工人的身体界限与社会界限。因为工人也需要吃饭睡觉，需要娱乐、消费与社交活动。</p>
<div class="note info"><div style="color:royalblue;">社会界限具有很大的弹性，而身体界限的弹性相对较低。</div>
</div>

<p>③资本家是人格化的资本，他的灵魂就是资本的灵魂。所有的资本就只有一种本能，那就是价值的增殖。对资本家来说劳动力意味着增殖，而对劳动者来说，劳动力意味着体力的过多支出。<br>④资本主义生产方式的内在要求是资本家占有劳动者一昼夜，即24小时的劳动。但这在生理上是不可能的。为了不让生产资料闲置而造成折旧，资本家会采取轮班制，让劳动24小时不间断地进行。</p>
<div class="note info"><div style="color:royalblue;">24小时轮班制，名义上让资本家打破了生理限制。</div>
</div>

<h3 id="资本主义生产方式的矛盾性"><a href="#资本主义生产方式的矛盾性" class="headerlink" title="资本主义生产方式的矛盾性"></a><strong>资本主义生产方式的矛盾性</strong></h3><p>①就商品交换的本质而言，商品的购买者有权任意处置商品。因此劳动力被作为商品出售给了资本家后，资本家有权对劳动力做任何行为。<br>②从商品交换者的权利来看，买卖双方缔结的契约表明双方是平等的，买卖双方都可以自由支配自己。然而在成交以后，劳动力却发现自己成为了奴隶。<br>③上述两种权利都是被商品交换规律所承认的。这就是资本主义生产关系的矛盾。</p>
<h3 id="剩余价值量"><a href="#剩余价值量" class="headerlink" title="剩余价值量"></a><strong>剩余价值量</strong></h3><p>剩余价值量由可变资本和剩余价值率决定。因为</p>
<p>$$剩余价值量＝可变资本×剩余价值率$$</p>
<p>①规律一：在生产一定量的剩余价值时，一个因素的减少可以由另一种因素的增加来补偿。即，调低剩余价值率，再调高可变资本，也能生产相同的剩余价值。</p>
<div class="note info"><div style="color:royalblue;">即，减少对单个工人的剥削程度，但是同时剥削更多工人，也能产生相同的剩余价值。但是资本家要多付更多的成本，即可变资本与不变资本的总和增加了。</div>
</div>

<p>②规律二：可变资本的减少可以由剩余价值率的提高来补偿。即：减少雇佣的工人，增加每个工人的受剥削程度，一样能产生同样的剩余价值量。<br>③规律三：在剩余价值率与劳动力价值已定的情况下，所生产的剩余价值量与投入的可变资本量成正比。</p>
<div class="note info"><div style="color:royalblue;">在生产过程中，资本逐渐演变为一种对劳动，即工人本身的指挥权。资本在精力、贪婪和效率方面，远胜过去所有的以强制劳动为基础的生产制度。</div>
</div>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（五）</title>
    <url>/2022/01/23/DasKapital05/</url>
    <content><![CDATA[<img src="/2022/01/23/DasKapital05/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="三、相对剩余价值"><a href="#三、相对剩余价值" class="headerlink" title="三、相对剩余价值"></a><strong>三、相对剩余价值</strong></h2><div class="note info"><div style="color:royalblue;">通过缩短必要劳动时间来相对延长剩余劳动时间而生产的剩余价值，是相对剩余价值。</div>
</div>

<h3 id="缩短必要劳动时间"><a href="#缩短必要劳动时间" class="headerlink" title="缩短必要劳动时间"></a><strong>缩短必要劳动时间</strong></h3><p>必要劳动时间由劳动力价值决定。劳动力价值由劳动力每天所需的生活资料价值决定。降低生活资料的价值，则必要劳动时间就会减少；而工作日长度不变，那么剩余劳动时间就增加了。</p>
<h3 id="降低生活资料的价值"><a href="#降低生活资料的价值" class="headerlink" title="降低生活资料的价值"></a><strong>降低生活资料的价值</strong></h3><p>商品的价值取决于最终形成商品的劳动量与形成商品时使用的生产资料所包含的劳动量。提高这些产业部门的生产劳动力，降低相关产品的价格，劳动力的价值也就随之降低。</p>
<div class="note info"><div style="color:royalblue;">通俗点讲，商品的价值取决与生产商品的时候付出的劳动量，还有因为生产这个商品而折旧的机械、使用的原材料等的价值。而机械与原材料原本也是商品，其中也蕴含着劳动。因此通过生产技术进步，降低其中所需的劳动量，即可降低商品的价值。例如，原本织布需要工人手工编织，现在可能只需要工人按一下按钮机械就能生产出来。此时生产等量商品的劳动量大幅降低。</div>
</div>

<h3 id="超额剩余价值"><a href="#超额剩余价值" class="headerlink" title="超额剩余价值"></a><strong>超额剩余价值</strong></h3><p>①当个别资本家通过采用新的生产技术来提高劳动生产力时，生产商品所需的劳动时间减少，所生产的商品的个别价值将低于其它商品。<br>②商品的现实价值取决于其社会价值而非个别价值。即，商品的价值取决于社会必要劳动时间，而非生产这个商品所耗费的时间。<br>③采用新的生产技术的个别资本家在出售商品时，不仅获得了剩余价值，还因为其商品所需的劳动时间低于社会必要劳动时间，获得了额外的价值。这个价值就是超额剩余价值。<br>④超额剩余价值属于相对剩余价值。<br>⑤当新的生产技术被普遍采用的时候，生产出来的产品的个别价值将与其社会价值相等，超额剩余价值也随之消失。但随着社会生产力的普遍提高，劳动力的价值必然下降，整个资产阶级将获得更多相对剩余价值。</p>
<h3 id="劳动生产力"><a href="#劳动生产力" class="headerlink" title="劳动生产力"></a><strong>劳动生产力</strong></h3><p>①商品的价值与劳动生产力成反比；劳动力的价值与劳动生产力成反比；相对剩余价值与劳动生产力成正比。<br>②通过提高劳动生产力来降低商品价格，从而降低劳动力价格，是资本的内在冲动与普遍趋势。<br>③劳动生产力的提高，一方面降低了商品的价值，另一方面增加了相对剩余价值。</p>
<div class="note info"><div style="color:royalblue;">即：生产技术的进步，使得商品更便宜，同时其中的相对剩余价值更多。</div>
</div>

<p>④资本家提高劳动生产力的目的是为了缩短生产商品的必要劳动时间，从而延长剩余劳动，榨取更多剩余价值。</p>
<h3 id="平均劳动"><a href="#平均劳动" class="headerlink" title="平均劳动"></a><strong>平均劳动</strong></h3><p>由于个体之间存在差异，导致在所有的产业部门中，工人之间的劳动力都与平均劳动力有所偏差。然而，只要把众多的工人聚集起来，这种偏差就会因为互相抵消而消失。</p>
<div class="note info"><div style="color:royalblue;">类似于社会必要劳动时间。有的人心灵手巧老练娴熟，而有的人手脚笨拙刚刚起步，他们生产同一种劳动产品所花费的时间将大不相同。</div>
</div>

<h3 id="协作劳动"><a href="#协作劳动" class="headerlink" title="协作劳动"></a><strong>协作劳动</strong></h3><p>①为了降低个体差异造成的劳动效率低下，资本家会大量招募工人进行劳动。同时，相应的生产资料也会发生变化，如大规模的车间。<br>②大量的、聚集起来共同使用的生产资料的价值，往往比等量的、分散的生产资料的价值总和要低。</p>
<div class="note info"><div style="color:royalblue;">比如，建造10座车间所消耗的劳动，要大于只建造一座能容纳等量工人的大型车间所耗费的劳动。</div>
</div>

<p>③在大规模生产下，生产资料的总价值虽然增加，但是平均到每一件商品上的平均价值更低，生产资料的利用率更高。因此不变资本的相对比例就降低了，商品的总价值也随着这部分价值量的减少而降低。<br>④生产资料的利用率高，仅仅是因为众多工人在劳动过程中共同消费它们。并且生产资料的价值，不会因为有多少工人在使用它而变化。<br>⑤协作劳动不仅提高了个人的劳动生产力，而且创造了一种新的生产力——集体力，或者叫凝聚力。<br>⑥协作劳动扩大了劳动的空间范围。例如修筑水坝等不通过协作就无法完成的大型工程。<br>⑦协作劳动可以相对地缩小生产空间 <em>（指平均占用的空间）</em> ，节约非生产费用。</p>
<h3 id="劳动的社会生产力"><a href="#劳动的社会生产力" class="headerlink" title="劳动的社会生产力"></a><strong>劳动的社会生产力</strong></h3><p>①结合工作日的特殊生产力都是劳动的社会生产力。</p>
<div class="note info"><div style="color:royalblue;">通俗地讲，通过分工合作发挥出来的超出个体的生产力总和的这一部分生产力，就是劳动的社会生产力。这部分生产力自然也包括轮班制带来的生产力。</div>
</div>

<p>②只要把工人置于一定的条件之下，劳动的社会生产力就能无需支付报酬而发挥出来。资本正是将工人置于这种条件之下，并且因为工人在他的劳动本身属于资本之前并不能发挥这种生产力，所以造成了一种“劳动的社会生产力好像是资本天然具有的、内在的生产力”的错觉。</p>
<h3 id="资本主义生产过程的二重性"><a href="#资本主义生产过程的二重性" class="headerlink" title="资本主义生产过程的二重性"></a><strong>资本主义生产过程的二重性</strong></h3><p>①一方面，它是制造新产品的社会劳动过程；另一方面，它是资本的价值增殖过程。也因此导致了资本主义的管理也具有二重性，其形式上具有专制性。<br>②随着生产规模的扩大，就如同资本家在开始资本主义生产时，就不必再从事体力劳动一样，如今资本家把监督工人的职责交给了特别的雇佣工人，他们以资本的名义进行指挥，而监督工人则成为了它们的专职。</p>
<div class="note info"><div style="color:royalblue;">说的就是公司管理层和HR。</div>
</div>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（六）</title>
    <url>/2022/02/02/DasKapital06/</url>
    <content><![CDATA[<img src="/2022/02/02/DasKapital06/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="三、相对剩余价值（续）"><a href="#三、相对剩余价值（续）" class="headerlink" title="三、相对剩余价值（续）"></a><strong>三、相对剩余价值（续）</strong></h2><h3 id="工厂手工业"><a href="#工厂手工业" class="headerlink" title="工厂手工业"></a><strong>工厂手工业</strong></h3><h4 id="1-起源"><a href="#1-起源" class="headerlink" title="1. 起源"></a><strong>1. 起源</strong></h4><p>工厂手工业有两种起源。</p>
<ul>
<li>资本家雇佣同一种工人，生产同一种产品</li>
<li>资本家雇佣不同种的工人，这些工人们分别进行不同种类的劳动，最终他们的劳动将形成一个产品</li>
</ul>
<div class="note info"><div style="color:royalblue;">举个例子，前者就是资本家雇佣了一批打铁工，生产锤子；后者是资本家雇佣了砌墙工、水泥工、搬运工，建造房子。本质上并没有区别，都是资本家将工人聚集起来进行分工协作。</div>
</div>

<h4 id="2-劳动生产率"><a href="#2-劳动生产率" class="headerlink" title="2. 劳动生产率"></a><strong>2. 劳动生产率</strong></h4><p>工厂手工业中也存在分工，并且一般会将原来复杂的一项操作分成若干简单的操作。由于工人只需要从事其中一种简单的操作，因此他们对于这种劳动的熟练度会迅速增加。</p>
<p>一方面，专业化的工人长期重复一种操作，这就使得经验的积累相对容易，与能完整执行整个流程的工人相比，专业工人在这种操作上会更高效；另一方面，同一个部门的工人一般都从事同一种操作，使得经验的推广相比独立个体户更加容易。</p>
<p>独立的个体户在进行整个生产流程时，往往会因为工序的需要而改变生产工具、移动位置等，这会造成劳动生产率的降低。而资本家的专业工人则由于专门从事一种操作而减少了这种时间浪费。</p>
<h4 id="3-工人的等级制"><a href="#3-工人的等级制" class="headerlink" title="3. 工人的等级制"></a><strong>3. 工人的等级制</strong></h4><p>分工的出现，使得工人能够按特长分类。操作也有复杂与简单之分，因此专业工人需要的教育程度也不相同，教育程度不同就导致了劳动力价值不同，因此也就出现了工人的等级制度以及与此相适应的工资等级制度。</p>
<div class="note info"><div style="color:royalblue;">举个例子，码农只要会写代码就行，算法工程师不仅要会写代码，还需要会图论、数据结构与算法设计。劳动力从事劳动所需要的教育的开销也属于劳动力的价值，因此就造成了算法工程师与码农的劳动力价值差异，形成了工人之间的等级制度。但是应当清楚，这种等级制度的根源是资本主义生产关系。</div>
</div>

<h4 id="4-相对剩余价值"><a href="#4-相对剩余价值" class="headerlink" title="4. 相对剩余价值"></a><strong>4. 相对剩余价值</strong></h4><p>由于不再需要能做完整个流程的工人，因此对劳动力的受教育要求降低，劳动力的价值也相应降低。这种因为学习费用的减少而造成的劳动力的相对贬值，就是相对剩余价值的增加，是资本的增殖。</p>
<h4 id="5-特点"><a href="#5-特点" class="headerlink" title="5. 特点"></a><strong>5. 特点</strong></h4><ul>
<li>专业工人不生产产品，他们生产的都是下一个流程的原材料。变成产品的是所有流程的专业工人生产的共同产品。</li>
<li>工人因为没有生产产品的物质资料，因此只能将自身的劳动力出卖给资本家。工场手工业的工人没有能力做一件独立的工作，只能作为资本家的“财产”进行生产活动。</li>
<li>工厂手工业依然存在局限——依靠分工协作提高的劳动生产率相对而言并不明显，因此工场手工业还不能掌握全部的社会生产，独立个体户或者行会依然得以存在。</li>
</ul>
<h3 id="机器和大工业"><a href="#机器和大工业" class="headerlink" title="机器和大工业"></a><strong>机器和大工业</strong></h3><h4 id="1-机器"><a href="#1-机器" class="headerlink" title="1. 机器"></a><strong>1. 机器</strong></h4><p>机器能分为三个部分：动力部分、传动部分、工具部分。它们分别为机械提供动力、将力传导到工具部分、代替工人做工。</p>
<p>机器能代替单独使用工具的工人，且不止一个，因为机器的工具部分能同时装备很多工具，但相应地需要更强劲的动力部分，并适当扩大传动部分。</p>
<h4 id="2-价值"><a href="#2-价值" class="headerlink" title="2. 价值"></a><strong>2. 价值</strong></h4><p>生产资料的价值不会消失，而是从其本身转移到产品上，作为生产资料的机器也不例外。机器的价值，就是生产这个机器所耗费的人类劳动量。</p>
<p>作为生产资料，机器本身并不创造价值。价值的来源只能是人类劳动。</p>
<p>协作劳动的将工人集中起来共同使用某些生产条件，要比分散时更节约。与此类似，机器大规模生产时，许多工具部分可以共享一个动力部分，甚至能共享一部分的传动部分。</p>
<p>生产机器与操纵机器所耗费的劳动量之和，是远远低于直接生产产品的劳动量的。因此虽然机器的价格相对昂贵，但是机器转移到每一件产品中的价值降低。</p>
<h4 id="3-对工人的影响"><a href="#3-对工人的影响" class="headerlink" title="3. 对工人的影响"></a><strong>3. 对工人的影响</strong></h4><ul>
<li>机器的出现使得资本家不再需要纯粹的体力，雇佣妇女儿童成为了可能。原来一个家庭中只有男性能工作，因此一个劳动力的价值可能是要养活一个家庭所需要消耗的生活必需品的价值。而当妇女与儿童也能参与工作以后，资本家的剥削面扩大到家庭中的每一位成员，因此劳动力的价值便降低到养活劳动力自身所需的价值。在采用机器之前，相同的钱只能雇佣一个男性劳动力；而现在相同的钱能雇佣一家三口，劳动力严重贬值。</li>
<li>机器的直接使用让劳动力贬值，同时机器生产的产品价格降低，工人所需要的生活消费品价格也降低，这又造成了劳动力的贬值，相对剩余价值增加。</li>
<li>采用新的机器生产之后的一段时间内，一方面不知道新的能让机器更便宜的生产技术何时出现，导致机器贬值，进而造成产品的贬值；另一方面新的生产技术还未普遍使用，资本家能获取超额剩余价值，因此资本家希望尽快从工人身上榨取剩余价值。当资本家不能再延长工作日时，他们就会想方设法提高劳动强度以步长由此带来的“剩余价值损失”。</li>
<li>机器属于生产资料，不能产生剩余价值。使用机器生产虽然提高了生产效率，延长了工人的剩余劳动时间，但是所需要的工人减少了。即：机器要提高剩余价值率，必须要减少雇佣的工人，或者扩大产能。</li>
<li>机器排挤工人造成大量工人失业，从而迫使工人不得不接受资本家强加给他们的法则。</li>
</ul>
<h4 id="4-国际分工与经济危机"><a href="#4-国际分工与经济危机" class="headerlink" title="4. 国际分工与经济危机"></a><strong>4. 国际分工与经济危机</strong></h4><p>当交通运输业发生技术革命、与机器大工业相适应的生产条件形成后，机器大工业的扩展就只会受原材料与市场的制约。因此一方面此时的资本主义国家会寻求原材料产地与倾销市场，也就是殖民地；另一方面机器大工业使得产品更加便宜，方便夺取外国市场。</p>
<p>机器大工业相比工厂手工业的生产与扩张能力有了跳跃式的提升。这种提升造成了它对世界市场的依赖，也必然造成生产过剩与经济危机。</p>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（七）</title>
    <url>/2022/02/03/DasKapital07/</url>
    <content><![CDATA[<img src="/2022/02/03/DasKapital07/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="四、绝对剩余价值和相对剩余价值的生产"><a href="#四、绝对剩余价值和相对剩余价值的生产" class="headerlink" title="四、绝对剩余价值和相对剩余价值的生产"></a><strong>四、绝对剩余价值和相对剩余价值的生产</strong></h2><p>这一章主要是对此前的论述做一个总结。</p>
<h3 id="绝对剩余价值"><a href="#绝对剩余价值" class="headerlink" title="绝对剩余价值"></a><strong>绝对剩余价值</strong></h3><p>工人一天的劳动，可以划分为两段。一段是生产与他的劳动力价值相等的产品的必要劳动，另一段则是作为资本家利润的剩余劳动。工人的劳动量必须超过必要劳动量，不然资本家无利可图。增加劳动量，使得剩余劳动量也随之增加，从而产生的剩余价值，即为绝对剩余价值。</p>
<h3 id="相对剩余价值"><a href="#相对剩余价值" class="headerlink" title="相对剩余价值"></a><strong>相对剩余价值</strong></h3><p>不增加劳动量，但是减少必要劳动量，造成的剩余劳动量的相对增加，从而产生的剩余价值，即为相对剩余价值。必要劳动量由工人的劳动力价值决定，劳动力价值由工人所需的生活消费品价值决定。随着资本主义大机器工业发展，商品价格普遍降低，包括工人所需的生活消费品，此时工人的劳动力贬值，绝对剩余价值增加。</p>
<div class="note info"><div style="color:royalblue;">绝对剩余价值的增加与相对剩余价值的增加本质上都是剩余劳动量的增加。资本家不仅用延长工作时间来榨取绝对剩余价值，还想方设法缩短必要劳动时间来榨取相对剩余价值。</div>
</div>

<h3 id="剩余价值率计算公式"><a href="#剩余价值率计算公式" class="headerlink" title="剩余价值率计算公式"></a><strong>剩余价值率计算公式</strong></h3><p>剩余价值率有两种计算公式。</p>
<p>公式Ⅰ：</p>
<p>$$<br>\frac{剩余价值}{可变资本}&#x3D;\frac{剩余价值}{劳动力价值}&#x3D;\frac{剩余劳动}{必要劳动}<br>$$</p>
<p>公式Ⅱ：</p>
<p>$$<br>\frac{剩余价值}{产品价值}&#x3D;\frac{剩余产品}{总产品}&#x3D;\frac{剩余劳动}{工作日}<br>$$</p>
<p>请注意公式Ⅱ掩盖了剥削程度。因为公式Ⅱ计算的是剩余劳动与（剩余劳动+必要劳动）的比值。这个比值永远无法到达100%，除非必要劳动时间为0，而这是不可能的。而公式Ⅰ则直接计算剩余劳动与必要劳动的比值，这个比值不仅能达到100%，还有可能远高于100%。</p>
<h2 id="五、工资"><a href="#五、工资" class="headerlink" title="五、工资"></a><strong>五、工资</strong></h2><h3 id="工资的本质"><a href="#工资的本质" class="headerlink" title="工资的本质"></a><strong>工资的本质</strong></h3><p>不论是小时制、按日支付、按月支付的工资，都掩盖了资本主义生产关系剥削本质。不论是哪一种工资形式，工人都会为资本家创造剩余价值，因为剩余价值是资本主义生产关系的基础，没有它就没有资本主义。工人所创造的价值，是远远高于他所获得的工资的。</p>
<div class="note info"><div style="color:royalblue;">在封建社会中，农民不仅要种自己的地，还要种地主的地。种自己的地，就相当于工人的必要劳动，是为了劳动力的再生产；而种地主的地，则相当于工人的剩余劳动，这一部分劳动的价值完全被剥削者无偿地占有。</div>
</div>

<p>从商品交换的领域来看，资本家是买家，工人是劳动力的卖家。买家支付劳动力的价值，也就是工资，是劳动力再生产的价值；而劳动力的使用价值则为资本家所有。劳动力的使用价值就是有用的劳动，它能创造远比它本身价值更多的价值。因此低价购买高价卖出这一说法完全是资本家的欺诈。</p>
<h3 id="计时工资"><a href="#计时工资" class="headerlink" title="计时工资"></a><strong>计时工资</strong></h3><p>不论是按日、按周还是按月支付的工资，都可以转化为按小时支付的工资。延长每日工作时间，但是周工资或者月工资不变，小时工资就会降低，剥削程度增加。</p>
<p>在按小时支付工资的情况下，工人每小时的劳动也能划分为必要劳动与剩余劳动。此时必要劳动量等于小时工资的价值，而剩余劳动量则是这一个小时内非必要劳动量以外的劳动量。剥削依然存在。</p>
<h3 id="计件工资"><a href="#计件工资" class="headerlink" title="计件工资"></a><strong>计件工资</strong></h3><p>计件工资与计时工资在本质上没有差异。只不过，计件工资容易造成一种“工人出卖给资本家的不是劳动力，而是劳动成果”的假象。工人依然是将劳动力出卖给资本家，并且也一样会被榨取剩余价值。</p>
<p>计件工资是计算劳动生产率和劳动含量的尺度。计件工资十分适合用于资本家剥削工人，因为：</p>
<ul>
<li>在计件工资下，资本家可以借口产品质量不达标克扣工资。</li>
<li>计件工资为资本家提供了一种计算劳动强度的确切方式。劳动强度不达标的工人，将被克扣工资或解雇。</li>
<li>计件工资下不再需要监督劳动，资本家只需要监督产品数量与质量。这样即便不监督劳动，工人也会拼命工作。资本家很容易延长劳动时间、增加劳动强度，榨取绝对与相对剩余价值。</li>
</ul>
<h3 id="工资的地区差异"><a href="#工资的地区差异" class="headerlink" title="工资的地区差异"></a><strong>工资的地区差异</strong></h3><p>工资其实就是以货币来衡量劳动力的价值。劳动力的价值取决于蕴含在劳动力这种“商品”中的劳动量，即劳动力再生产所需的生活消费品的劳动量，也包含工人为了适应工作而需要学习一定技能所造成的开销。因此，在不同时期、不同的地区，劳动力的价值不同。</p>
<p>在资本主义发达的国家，劳动强度与劳动生产率都相对较高，因此工资也就相对更多。但是，资本家占有的剩余价值也就越多，工人受剥削的程度，即剩余劳动与必要劳动的比值不一定比不发达国家低。</p>
<h2 id="六、资本的积累过程"><a href="#六、资本的积累过程" class="headerlink" title="六、资本的积累过程"></a><strong>六、资本的积累过程</strong></h2><h3 id="资本的流通"><a href="#资本的流通" class="headerlink" title="资本的流通"></a><strong>资本的流通</strong></h3><p>在实体产业中，货币要执行资本的功能必须经历三个阶段：</p>
<ol>
<li>在流通领域内，货币用于购买劳动力与生产资料。</li>
<li>劳动力与生产资料投入生产过程，产出商品。</li>
<li>将商品投入流通领域，也就是卖出。</li>
</ol>
<p>由此可以将资本分为三种形式：货币资本、生产资本、商品资本。货币资本为资本主义生产做准备；生产资本生产剩余价值；商品资本实现剩余价值，也就是将剩余价值转化为货币。</p>
<h3 id="资本的积累条件"><a href="#资本的积累条件" class="headerlink" title="资本的积累条件"></a><strong>资本的积累条件</strong></h3><ul>
<li>资本家能完成上述三个阶段。</li>
<li>直接雇佣工人的资本家能最终占有剩余价值。</li>
</ul>
<div class="note info"><div style="color:royalblue;">剩余价值是由许多资本家共同占有的，例如出租土地的资本家、雇佣工人的资本家、提供贷款的资本家等。如果雇佣工人的资本家不能瓜分到一定程度的剩余价值，那么他的资本就不会积累。</div>
</div>

<h3 id="简单再生产"><a href="#简单再生产" class="headerlink" title="简单再生产"></a><strong>简单再生产</strong></h3><p>社会总是充满需求，因为人要活下去就需要吃饭，就需要消费。因此社会生产不会完全停止，除非社会完全没有需求。而要进行社会生产，就必须要有生产资料。生产资料是会被消耗的，而生产资料本身也可以由社会生产产生。因此可以将社会生产过程划分为两段，第一段是为了下一次生产准备原材料，第二段则是创造新的价值。</p>
<div class="note info"><div style="color:royalblue;">与必要劳动和剩余劳动比较相似，不过这里是在讲述生产而非剥削。</div>
</div>

<h4 id="1-可变资本再生产"><a href="#1-可变资本再生产" class="headerlink" title="1. 可变资本再生产"></a><strong>1. 可变资本再生产</strong></h4><p>资本家购买的劳动力是一段时间内的劳动力，时间结束以后资本家需要再次购买。而工人获得工资，往往是他们为资本家生产完产品之后。也就是说，工人在不断地“生产”着自己的工资和资本家的利润，即：工人所得的劳动报酬是用他以前的劳动来支付的。</p>
<h4 id="2-全部资本的再生产"><a href="#2-全部资本的再生产" class="headerlink" title="2. 全部资本的再生产"></a><strong>2. 全部资本的再生产</strong></h4><p>书中有一个很形象的例子。一个资本家，他有1000元。暂且先不论这1000元从何而来。他通过使用这1000元的资本，每月能从工人身上榨取200元的剩余价值，也就是利润。这个资本家也是人也要吃饭，每个月吃饭花了他200元。5个月后，工人为他产出了1000元的剩余价值。这其实也等价于，资本家把自己原来的1000元用于吃饭，而直接从工人身上榨取了1000元。因此，在资本主义再生产过程中，工人不仅创造了剩余价值和可变资本，还创造了全部资本。</p>
<h4 id="3-资本主义生产关系的再生产"><a href="#3-资本主义生产关系的再生产" class="headerlink" title="3. 资本主义生产关系的再生产"></a><strong>3. 资本主义生产关系的再生产</strong></h4><p>生产资料与劳动者的分离，是资本主义生产关系的七点。在资本主义生产过程中，生产资料转化为商品，再转化为货币，又变回生产资料；而劳动者在劳动之前是一无所有的无产者，劳动之后还是一无所有的无产者，等待着被资本家雇佣。</p>
<p>资产阶级将劳动力当作商品，劳动力与生产资料的结合为资产阶级创造剩余价值。生产资料可以通过不变资本不断补充，而劳动力则需要通过吃饭、养育后代来不断维持。在资本主义生产关系下，无产阶级与生产资料一样是资本的附属物，无产阶级消费生活必需品也成了资本再生产的一环，就如同发动机需要加油一样。</p>
<p>资本主义的再生产，就是资本主义生产关系的再生产；资本主义生产关系的再生产，就是资产阶级与无产阶级的不断相互对立。</p>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（八）</title>
    <url>/2022/02/10/DasKapital08/</url>
    <content><![CDATA[<img src="/2022/02/10/DasKapital08/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="六、资本的积累过程（续）"><a href="#六、资本的积累过程（续）" class="headerlink" title="六、资本的积累过程（续）"></a><strong>六、资本的积累过程（续）</strong></h2><h3 id="资本主义扩大再生产"><a href="#资本主义扩大再生产" class="headerlink" title="资本主义扩大再生产"></a><strong>资本主义扩大再生产</strong></h3><p>在生产中，一年所消耗的生产资料必须由这一年的生产来弥补。并且往往年生产可以产生新的价值。在资本主义生产关系下，这个新产生的价值就是剩余价值。资本家只需要将这些剩余价值投入生产，即可完成剩余价值向资本转化的过程。</p>
<div class="note info"><div style="color:royalblue;">在劳动中，原材料会被消耗，生产工具会被磨损。而这些消耗与磨损必须得到补充，否则劳动将无法继续进行，而这些消耗与磨损的生产资料都必须以生产的方式来弥补。但是人能生产出来的价值不仅能弥补这些损耗的价值，还能新增价值，否则人类社会早就停滞不前了，资本主义生产关系的生产过剩危机也不存在了。</div>
</div>

<p>要扩大再生产，就必须追加投入，即购买更多生产资料、雇佣更多工人。在扩大再生产中用来购买劳动力的那一部分资本，不仅本身就是通过不等价交换而占有的工人的劳动产品的一部分，而且它还要让工人产生新的剩余价值——因为用于雇佣工人的资本是可变资本。</p>
<p>所有的预付资本，不论它的来源如何，都转化为了积累资本或者资本化的剩余价值。在生产的洪流中，所有的预付资本与重新转化为资本的剩余价值相比，是一个无限小的量。</p>
<p>资本家是资本的人格化，资本家的致富欲望表现为资本主义的共性。资本主义生产的发展，使得投入工业企业的资本会不断增长，而竞争会让资本主义生产方式的经济规律支配每一个资本家，逼迫资本家扩大自己的资本。但，扩大资本的方式只能依靠不断地积累。积累是对社会财富的不断征服，它不仅扩大了被资本家剥削的人数，同时还扩大了资本家对劳动者的间接统治。</p>
<h3 id="决定剩余价值积累量的因素"><a href="#决定剩余价值积累量的因素" class="headerlink" title="决定剩余价值积累量的因素"></a><strong>决定剩余价值积累量的因素</strong></h3><p>在不变资本不增加的前提下，提高劳动的紧张程度可以增加剩余价值。</p>
<div class="note info"><div style="color:royalblue;">这一点在农业、矿业等直接开发自然资源的行业比较明显。增加劳动强度，生产资料只会磨损得比较快，但是能产出更多的剩余价值。</div>
</div>

<p>只要剩余价值率下降的速率低于劳动生产力提高的速率，剩余价值就会增加。在剩余价值不变的情况下，资本家可以减少个人消费所消耗的剩余价值量，来增加转化为资本的剩余价值量。但资本家所享受到的物质资料可能不会减少反而会增加，因为劳动生产力的提高让产品变得更便宜了。这和减少工人的劳动力价值是一样的逻辑。也因此更少的资本也能购买更多的生产资料和劳动力，即便追加资本不变甚至减少，资本的积累速率仍能提高。</p>
<h3 id="资本的价值构成"><a href="#资本的价值构成" class="headerlink" title="资本的价值构成"></a><strong>资本的价值构成</strong></h3><p>从价值方面看，资本可以被分为不变资本和可变资本，即购买生产资料的资本和雇佣劳动力的资本。这种分法叫做资本的价值构成。</p>
<h3 id="资本的技术构成"><a href="#资本的技术构成" class="headerlink" title="资本的技术构成"></a><strong>资本的技术构成</strong></h3><p>从资本在生产中发挥作用的物质方面来看，资本可以被分为生产资料的数量和为了消耗这些生产资料所需的劳动量。这种分法叫做资本的技术构成。</p>
<div class="note info"><div style="color:royalblue;">不是只有货币才是资本。生产资料也是资本的一种存在形式。</div>
</div>

<h3 id="资本的有机构成"><a href="#资本的有机构成" class="headerlink" title="资本的有机构成"></a><strong>资本的有机构成</strong></h3><p>由资本的技术构成决定，反应其技术构成变化的资本的价值构成，叫做资本的有机构成。</p>
<h3 id="资本主义积累的一般规律"><a href="#资本主义积累的一般规律" class="headerlink" title="资本主义积累的一般规律"></a><strong>资本主义积累的一般规律</strong></h3><p>简单再生产不断地生产出资本主义生产关系本身，即规定了一方是资本一方是工人；扩大再生产则不断扩大资本主义生产关系，即一方是更多的资本，另一方是更多的工人。</p>
<h4 id="1-资本的构成不变时"><a href="#1-资本的构成不变时" class="headerlink" title="1. 资本的构成不变时"></a><strong>1. 资本的构成不变时</strong></h4><p>资本的价值构成不变，也就意味着使用一定量的生产资料必须要雇佣一定量的劳动力。它们的比例不变。</p>
<p>随着资本的积累越来越快，新增加的生产资料就越来越多，对劳动力的需求就越来越大，对工人的需求就会超过工人的供给，工人的工资就会提高，生活质量也相对提高。但这无法消除雇佣工人的从属关系和资本家对工人的剥削。工资的提高只是减少了工人提供的无酬劳动量，但并不会消灭无酬劳动，也就是剩余劳动。</p>
<p>一方面，劳动力价格的提高并不会妨碍资本的积累进度，即剩余劳动的减少不会妨碍资本统治的扩大；另一方面，积累由于劳动力价格的提高而削弱，随着积累的减少，资本与可供剥削的劳动力的不平衡也逐渐消失，劳动力价格重新回到适合资本增殖需要的水平。前者是资本增长引起的可供剥削的劳动力不足的现象；后者是资本的减少引起的可供剥削的劳动力过剩的现象。</p>
<div class="note info"><div style="color:royalblue;">简单来说就是为了扩大再生产，生产资料越来越多，也因此就需要成比例地增加劳动力。但是劳动力供应不足，工人工资上涨；但上涨会造成资本积累变慢，反过来遏制工人工资继续上涨。<del>怎么一股供给和需求的味儿。</del></div>
</div>

<p>资本主义积累的本质不允许剥削劳动力程度的降低或劳动力价格的提高危及到资本主义生产关系的再生产和扩大再生产。在资本主义生产关系下，物质财富不是为了工人而存在，而是工人为了让物质财富增殖而存在。</p>
<h4 id="2-资本的可变部分相对减少"><a href="#2-资本的可变部分相对减少" class="headerlink" title="2. 资本的可变部分相对减少"></a><strong>2. 资本的可变部分相对减少</strong></h4><p>资本的可变部分相对减少是相对于不变资本的比例减少，但它的绝对值可以增加。</p>
<p>随着生产力的发展，一方面劳动力价值逐渐降低，另一方面生产等量的商品所需的劳动量也逐渐减少。这使得资本的技术构成发生变化，即减少可变资本量，以增加不变资本量；或者说是消耗一定量的生产资料所需的劳动量减少了。</p>
<p>资本积累的来源与基础是剩余价值。提高劳动生产力可以产出更多剩余价值，更多的剩余价值将会促进资本的积累与生产规模的扩大，生产规模的扩大是出现提高生产力的方法与加速榨取剩余价值方法的基础。由于这种互相推动的关系，资本的技术构成随着发展不断变化，不变资本相对于可变资本的占比越来越高。</p>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>资本论笔记（九）</title>
    <url>/2022/02/10/DasKapital09/</url>
    <content><![CDATA[<img src="/2022/02/10/DasKapital09/Title.png" alt="标题" style="width:100%;height:auto;">

<span id="more"></span>

<h2 id="六、资本的积累过程（续）"><a href="#六、资本的积累过程（续）" class="headerlink" title="六、资本的积累过程（续）"></a><strong>六、资本的积累过程（续）</strong></h2><h3 id="相对过剩人口"><a href="#相对过剩人口" class="headerlink" title="相对过剩人口"></a><strong>相对过剩人口</strong></h3><p>在资本主义生产关系下，随着劳动生产力的发展，资本的有机构成不断变化。可变资本相对于不变资本的占比逐渐降低，而对劳动力的需求是由可变资本决定的。随着资本的积累，可变资本的总量将会增加，但增加的比例越来越小。这意味着对劳动力的需求虽然在上升，但是上升得越来越慢。因此将会出现工人的人口增长总是快于工人就业手段的增长，这就是相对过剩人口出现的原因。</p>
<p>工人在生产出资本积累的同时，还在以逐渐扩大的规模生产出使自己成为相对过剩人口的手段。相对过剩人口形成了一支可供支配的产业后备军，一方面他们会对现有的在业工人造成巨大压力，让在业工人不得不遵从资本家的摆布而过度劳动；另一方面，在业工人的过度劳动又会导致一部分工人无事可做，沦为产业后备军。</p>
<div class="note info"><div style="color:royalblue;">如果工人阶级真正地自由了，那么资产阶级也就无从榨取剩余价值了。因此资产阶级必定不会让工人阶级挣脱束缚，并且会让工人阶级不得不依附于资产阶级。工人的自由只能在打破资本主义生产关系之后才能实现。</div>
</div>

<h3 id="相对过剩人口的存在形式"><a href="#相对过剩人口的存在形式" class="headerlink" title="相对过剩人口的存在形式"></a><strong>相对过剩人口的存在形式</strong></h3><p>半失业、全失业工人全都属于相对过剩人口。</p>
<ul>
<li>流动形式：<br>不符合条件的工人将不会被雇佣；经济繁荣时资本家将会雇佣更多工人，而经济萧条时将会解雇工人。虽然工人就业人数整体上再增加，但新增的就业岗位与生产规模的扩大程度相比却在减少。</li>
<li>潜在形式：<br>农业一旦被资本主义生产方式占领，随着资本的积累和可变资本的相对减少，对劳动力的需求就会减少，大批农业工人将被排挤。他们只能进入城市，并且只能在工业需要工人时才能进入城市，因此他们的工资总是被压到最低。</li>
<li>停滞形式：<br>“灵活就业”人口。他们是现役劳动大军的一部分，但就业极不规则。他们通常是大工业和农业的失业者、倒闭工厂的工人。他们的生活状况在工人阶级的平均水平以下，劳动时间最长，并且工资最低。</li>
</ul>
<p>社会积累的资本越多，它的增长规模就越大，它所造成的产业后备军——也就是无产阶级——的数量也就越来越多。</p>
<p>劳动生产力的不断提高，使得只需花费极少的人力就能使用越来越多的生产资料成为可能。而在资本主义生产关系下却反了过来——不是工人在使用生产资料，而是生产资料在使用工人。劳动生产力越高，工人就业压力就越大。生产资料和劳动生产力增加得比人口增长更快，在资本主义生产关系下变成了工人人口总是比资本的增殖需求增长得快。</p>
<h3 id="资本的原始积累"><a href="#资本的原始积累" class="headerlink" title="资本的原始积累"></a><strong>资本的原始积累</strong></h3><p>资本主义生产关系的建立过程，就是劳动者与生产资料分离的过程，这就是原始积累的实质，它发生在资本主义生产方式完全确立之前。</p>
<p>资本主义生产方式需要能“自由”出卖劳动力的劳动者。但是封建的行会、农奴制度限制了劳动者的人身自由。资产阶级们必须摧毁封建制度，并且将被剥夺了生产资料的劳动者们抛向市场，才能确立资本主义生产方式。</p>
<p>（在英国）资产阶级掠夺教会地产、盗窃国有土地与公共用地，以残暴的手段将封建财产变为现代私有财产，这些都属于资本主义原始积累的方法。由于土地被资产阶级占有，大量的农民沦为无产阶级涌向城市，为工业资产阶级提供了大量的劳动力。</p>
<div class="note info"><div style="color:royalblue;">马克思在写《资本论》时，考察的对象是资本主义相对而言最发达的英国。此处论述的主要是英国的资本主义生产关系建立的历史。其它各国虽然历史客观环境不同，但一定会有资本原始积累的过程。</div>
</div>

<h3 id="资本主义积累的历史趋势"><a href="#资本主义积累的历史趋势" class="headerlink" title="资本主义积累的历史趋势"></a><strong>资本主义积累的历史趋势</strong></h3><p>资本主义生产方式建立于对私有者的剥夺，即剥夺农民、手工业者，让他们沦为无产阶级。以个人或者家庭为单位的封建经济排斥生产资料的聚集、排斥协作劳动、排斥内部分工、限制社会生产力的自由发展。随着资本主义生产关系的确立，农民、手工业者渐渐破产，财富流向资产阶级。而在资本主义生产方式完全确立之后，剥夺将转为资产阶级之间的互相剥夺，即大资产阶级剥夺小资产阶级。资本主义私有制必将衰亡，剥夺者将被剥夺。</p>
<p>资本的垄断成为了在这种垄断之下成长起来的生产方式的枷锁，无产阶级的反抗力量不断增长，生产资料不断集中，劳动逐渐社会化。资本主义私有制是对以个人劳动为基础的私有制的否定，而资本主义的内在矛盾又是对资本主义私有制的否定。否定之否定，不是要重新回到私有制，而是建立新的社会公有制。</p>
<div class="note info"><div style="color:royalblue;">织者无衣，耕者无田，这是所有剥削制度最直观的特征，而资本主义生产方式也不例外。</div>
</div>
]]></content>
      <categories>
        <category>社会科学</category>
        <category>政治经济学</category>
        <category>资本论</category>
      </categories>
      <tags>
        <tag>社会科学</tag>
        <tag>政治经济学</tag>
        <tag>资本论</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript ES6~ES11</title>
    <url>/2022/04/30/ES6-ES11/</url>
    <content><![CDATA[<img src="/2022/04/30/ES6-ES11/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要JavaScript基础。</div>
</div>

<span id="more"></span>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p>JavaScript最初设计出来的时候并没有像现在这样强大的功能。随着互联网的发展，JavaScript渐渐追加更多更强大的功能。目前JavaScript使用最广泛的标准是ES5，但每年JavaScript都会发布新的标准，截至本文开始编写时，已经到了ES13标准。因此有必要学习一下新的JavaScript标准。</p>
<p>所有的标准都是向前兼容的，因此不必担心已学的JavaScript语法在新版本下会失效。</p>
<h2 id="二、ES6标准"><a href="#二、ES6标准" class="headerlink" title="二、ES6标准"></a><strong>二、ES6标准</strong></h2><p>ES6标准的改动相对较多。</p>
<h3 id="1-let"><a href="#1-let" class="headerlink" title="(1) let"></a><strong>(1) <code>let</code></strong></h3><p>在ES6标准下，声明变量推荐使用<code>let</code>而不要使用<code>var</code> 。</p>
<h4 id="1-禁止二次声明"><a href="#1-禁止二次声明" class="headerlink" title="1. 禁止二次声明"></a><strong>1. 禁止二次声明</strong></h4><p>使用<code>var</code>声明的变量，允许被重复声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;114514&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114514</span><br></pre></td></tr></table></figure>

<p>使用<code>var</code>声明同名变量时，后者会覆盖前者。这可能会导致令人疑惑的错误。而当使用<code>let</code>声明变量时，支持ES6的解释器将直接抛出异常：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">D:\Files\Documents\Visual Studio Code\JavaScript\Hello.js:2</span><br><span class="line">let a = &quot;114514&quot;</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">SyntaxError: Identifier &#x27;a&#x27; has already been declared</span><br></pre></td></tr></table></figure>

<p>解释器不仅会直接抛出异常，还会指明引发错误的原因。不妨想想一下，使用<code>var</code>声明的变量，在绑定了一堆事件后，却因为命名空间污染导致被覆盖，因而无法实现程序员想要的网页效果，程序员打开控制台却一个异常也没有抛出的这种绝望感。如果不想体验这种绝望，请使用<code>let</code>或<code>const</code>来声明变量。</p>
<h4 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2. 块级作用域"></a><strong>2. 块级作用域</strong></h4><p>使用<code>let</code>声明的变量，只会在其所在的<code>&#123;&#125;</code>内生效，而使用<code>var</code>声明的变量，则将在<code>&#123;&#125;</code>外部也能生效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不止 for，只要有 &#123;&#125; 就会出现下述情况</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">b = 114514</span><br></pre></td></tr></table></figure>

<p>上述代码的变量若使用<code>let</code>进行声明，将会抛出异常，因为在<code>&#123;&#125;</code>内的变量<code>b</code>将不会被外部获取到，因此将会抛出<code>b</code>未定义的异常。</p>
<p>请注意，块级作用域的限制只限制了不能向<code>&#123;&#125;</code>内寻找变量，它并不影响向<code>&#123;&#125;</code>的外部寻找变量。即，不影响作用域链，“全局变量可以在函数内生效” 。</p>
<h4 id="3-无变量提升"><a href="#3-无变量提升" class="headerlink" title="3. 无变量提升"></a><strong>3. 无变量提升</strong></h4><p>使用<code>var</code>定义变量时，解释器会预先定义所有变量，等执行到真实的初始化位置时再进行赋值。因此可以在该变量真实声明处之前获取到该变量，虽然其值是<code>undefined</code> 。</p>
<p>而使用<code>let</code>声明的变量，则不允许在其被声明之前使用该变量，否则将抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);     <span class="comment">// 将会抛出异常</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1919810</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);     <span class="comment">// 将会输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">114514</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-const"><a href="#2-const" class="headerlink" title="(2) const"></a><strong>(2) <code>const</code></strong></h3><p><code>const</code>与<code>let</code>有相似之处，它们都是符合块级作用域的。但<code>const</code>声明的变量必须在其声明处被初始化，并且不允许修改其在栈中的值。</p>
<p>对象在栈中的值都是一个指向堆的地址，因此可以使用<code>const</code>来声明对象，这样既可以修改对象的内容，又可以避免错误赋值导致指向的对象改变。</p>
<h3 id="3-解构"><a href="#3-解构" class="headerlink" title="(3) 解构"></a><strong>(3) 解构</strong></h3><p>类似于Python和C#的拆包。ES6标准允许JavaScript进行 “拆包” 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构数组</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Lacia&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = list</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构对象</span></span><br><span class="line"><span class="keyword">let</span> object = &#123; <span class="title class_">Kouka</span>: <span class="number">14</span>, <span class="title class_">Method</span>: <span class="number">16</span>, <span class="title class_">Lacia</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="title class_">Lacia</span> &#125; = object;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lacia =&quot;</span>, <span class="title class_">Lacia</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; node Hello.js</span><br><span class="line">a = Kouka</span><br><span class="line">b = Method</span><br><span class="line">c = Lacia</span><br><span class="line">Lacia = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>对象的解构可以按需取出，而数组则只能根据下标顺序依次取出。并且，函数在书写形参的时候，也可以使用解构。</p>
<h3 id="4-模板字符串"><a href="#4-模板字符串" class="headerlink" title="(4) 模板字符串"></a><strong>(4) 模板字符串</strong></h3><p>模板字符串与一般字符串不同，一般字符串是使用<code>""</code>或<code>''</code>括住，而模板字符串使用<code>``</code>（反引号）。</p>
<p>在一般的字符串不允许出现换行符，要想加入换行符必须使用转义字符<code>\n</code> ，而模板字符串中允许直接输入换行符。另外，模板字符串允许使用插值语法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Name</span> = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Age</span> = <span class="number">17</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;Name&#125;</span> is <span class="subst">$&#123;Age&#125;</span> years old.`</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Lacia is 17 years old.</span><br></pre></td></tr></table></figure>

<p>使用模板字符串就可以直接将变量插入字符串中，类似于其他语言的格式化字符串。它的好处在于不用再担心隐式类型转换与字符串拼接的问题了。</p>
<h3 id="5-lambda表达式"><a href="#5-lambda表达式" class="headerlink" title="(5) lambda表达式"></a><strong>(5) lambda表达式</strong></h3><p>使用<code>=></code>可以定义一个lambda表达式，即快速定义函数。这种函数没有<code>arguments</code>变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params">a, b</span>) =&gt; &#123; <span class="keyword">return</span> a ** b; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">test</span>(<span class="number">2</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">16</span><br></pre></td></tr></table></figure>

<p>lambda表达式定义的函数与一般的函数的区别在于<code>this</code>指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 lambda 表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">Lambda</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lambda this =&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Traditional</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Traditional this =&quot;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Lambda</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Traditional</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与当前环境的 this 进行对比</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Lambda :&quot;</span>, a === <span class="variable language_">this</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Traditional :&quot;</span>, b === <span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">node Hello.js &#125;</span><br><span class="line">Lambda this = &#123;&#125;</span><br><span class="line">Traditional this = &lt;ref *1&gt; Object [global] &#123;</span><br><span class="line">    /* 太过冗长此处省略 */</span><br><span class="line">&#125;</span><br><span class="line">Lambda : true</span><br><span class="line">Traditional : false</span><br></pre></td></tr></table></figure>

<p>可以看到通过lambda表达式定义的函数的<code>this</code>指针与定义它的环境下的<code>this</code>相同。另外，<code>lambda</code>表达式的<code>this</code>指针是静态的，不论是谁调用该函数，<code>this</code>指针均不变，而在一般函数中<code>this</code>将会指向调用它的对象。也因此，使用lambda表达式定义的函数不允许被用于构造函数。</p>
<h3 id="6-可变长度参数"><a href="#6-可变长度参数" class="headerlink" title="(6) 可变长度参数"></a><strong>(6) 可变长度参数</strong></h3><p>虽然一般函数中存在<code>arguments</code>变量以获取所有的参数，但<code>arguments</code>变量本身是一个伪数组。ES6标准定义了新的可变长度参数的书写方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lambda 表达式不含 arguments，但可以使用可变长度参数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params">...args</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args =&quot;</span>, args);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;args instanceof Array =&quot;</span>, args <span class="keyword">instanceof</span> <span class="title class_">Array</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="number">114</span>, <span class="string">&quot;514&quot;</span>, &#123; <span class="string">&quot;1919&quot;</span>: <span class="number">810</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">args = [ 114, &#x27;514&#x27;, &#123; &#x27;1919&#x27;: 810 &#125; ]</span><br><span class="line">args instanceof Array = true</span><br></pre></td></tr></table></figure>

<p>可变长度参数只能放在参数列表的末尾，并且需要在参数名前加上 <code>...</code> 以标识它是一个可变长度参数。在函数中，可变长度参数本身是一个数组对象。</p>
<h3 id="7-扩展运算符"><a href="#7-扩展运算符" class="headerlink" title="(7) 扩展运算符"></a><strong>(7) 扩展运算符</strong></h3><p>与可变长度参数的标识符一致，扩展运算符就是<code>...</code> ，但区别在于前者用于形参列表，后者用于实参列表且仅能作用于可迭代对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处没有使用可变长度参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;arguments =&quot;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实参列表处使用扩展运算符</span></span><br><span class="line"><span class="title function_">test</span>(...[<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">arguments = [Arguments] &#123; &#x27;0&#x27;: 114, &#x27;1&#x27;: 514, &#x27;2&#x27;: 1919, &#x27;3&#x27;: 810 &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到扩展运算符的作用大致相当于将数组解构，并将每一个解构出来的元素作为参数，按照顺序传入函数。</p>
<p>扩展运算符也可以用于创建数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>];</span><br><span class="line"><span class="keyword">let</span> b = [...a, <span class="number">1919</span>, <span class="number">810</span>];</span><br></pre></td></tr></table></figure>

<h3 id="8-Symbol类型"><a href="#8-Symbol类型" class="headerlink" title="(8) Symbol类型"></a><strong>(8) <code>Symbol</code>类型</strong></h3><p><code>Symbol</code>既是一个对象，也可以作为<code>Symbol()</code>构造函数创建全新的<code>Symbol</code>类型的变量。</p>
<h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a><strong>1. 特性</strong></h4><p><code>Symbol</code>是一个新的变量类型。在ES6标准下，JavaScript的变量类型有<code>undefined</code> 、<code>String</code> 、<code>Symbol</code> 、<code>Object</code> 、<code>Number</code>和<code>Boolean</code>类型。</p>
<p>新加入的<code>Symbol</code>类型的变量创建很容易：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>

<p><code>Symbol</code>类型的变量具有的特性是，不会出现相等的<code>Symbol</code>类型的变量，就像雪花都是雪花，但不会有同一形状的两片雪花。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a == b is&quot;</span>, a == b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a === b is&quot;</span>, a === b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a == b is false</span><br><span class="line">a === b is false</span><br></pre></td></tr></table></figure>

<p>因此可以使用它来定义对象的属性，保证不会重名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[<span class="title class_">Symbol</span>()] = <span class="string">&quot;114&quot;</span>;</span><br><span class="line">a[<span class="title class_">Symbol</span>()] = <span class="string">&quot;514&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = &#123; [Symbol()]: &#x27;114&#x27;, [Symbol()]: &#x27;514&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-for-方法"><a href="#2-for-方法" class="headerlink" title="2. for()方法"></a><strong>2. <code>for()</code>方法</strong></h4><p>在<code>Symbol</code>对象下有一个名为<code>for()</code>的方法。该方法与<code>Symbol()</code>类似，但可以生成 “相同的雪花” 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;114&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;114&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a == b is&quot;</span>, a == b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a === b is&quot;</span>, a === b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a == b is true</span><br><span class="line">a === b is true</span><br></pre></td></tr></table></figure>

<h4 id="3-iterator迭代器"><a href="#3-iterator迭代器" class="headerlink" title="3. iterator迭代器"></a><strong>3. <code>iterator</code>迭代器</strong></h4><h5 id="Ⅰ-默认的迭代器"><a href="#Ⅰ-默认的迭代器" class="headerlink" title="Ⅰ. 默认的迭代器"></a><strong>Ⅰ. 默认的迭代器</strong></h5><p>ES6标准在<code>Symbol</code>对象下，定义了一个<code>iterator</code>（迭代器）属性。该属性一般用于可迭代容器（例如数组、映射、字符串等），并且在ES6标准下，<code>Symbol.iterator</code>这个属性被定义到了常见可迭代容器的原型对象下。一般实现了<code>iterator</code>接口就是指该对象含有<code>Symbol.iterator</code>属性。<code>for of</code>循环的底层实现就是使用了该属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会打印下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会打印值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">114</span><br><span class="line">514</span><br><span class="line">1919</span><br><span class="line">810</span><br></pre></td></tr></table></figure>

<p><code>Symbol.iterator</code>属性本身是一个函数，它的返回值是一个迭代器对象。该对象下有一个<code>next()</code>方法，该方法调用时将会返回当前的元素，并让 “指针” 后移。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器对象</span></span><br><span class="line"><span class="keyword">let</span> iterator = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">&#123; value: 114, done: false &#125;</span><br><span class="line">&#123; value: 514, done: false &#125;</span><br><span class="line">&#123; value: 1919, done: false &#125;</span><br><span class="line">&#123; value: 810, done: false &#125;</span><br><span class="line">&#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>next()</code>方法返回的值是一个对象，其<code>value</code>属性表明当前元素的值，而<code>done</code>属性则指示迭代是否完成。</p>
<h5 id="Ⅱ-自定义迭代器"><a href="#Ⅱ-自定义迭代器" class="headerlink" title="Ⅱ. 自定义迭代器"></a><strong>Ⅱ. 自定义迭代器</strong></h5><p>迭代器是允许自定义的。我们可以使用它来控制<code>for of</code>对自定义对象的遍历模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    <span class="comment">// 定义对象的属性</span></span><br><span class="line">    <span class="title class_">Kouka</span>: <span class="string">&quot;Type:001&quot;</span>,</span><br><span class="line">    <span class="title class_">Method</span>: <span class="string">&quot;Type-004&quot;</span>,</span><br><span class="line">    <span class="title class_">Lacia</span>: <span class="string">&quot;Type-005&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义迭代器属性，它应当返回一个迭代器对象</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取对象的属性名列表</span></span><br><span class="line">        <span class="keyword">const</span> list = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> <span class="variable language_">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            list.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回迭代器对象，该对象应当有一个 next() 方法</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 定义 next() 方法，定义为 lambda 表达式，其中的 this 将指向对象 a</span></span><br><span class="line">            <span class="attr">next</span>: <span class="function">() =&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Index</span> &lt; list.<span class="property">length</span>)</span><br><span class="line">                    a = &#123; <span class="attr">value</span>: <span class="variable language_">this</span>[list[<span class="title class_">Index</span>]], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    a = &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">                <span class="title class_">Index</span>++;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Type:001</span><br><span class="line">Type-004</span><br><span class="line">Type-005</span><br></pre></td></tr></table></figure>

<h3 id="9-生成器"><a href="#9-生成器" class="headerlink" title="(9) 生成器"></a><strong>(9) 生成器</strong></h3><div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>不推荐</strong></div>

<div style="color:goldenrod;">最新的JavaScript标准中，已经有比生成器更好的异步实现了。</div>
</div>

<p>生成器本质是一个函数，它在底层也是使用了迭代器。声明一个生成器函数很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请注意要加 * （星号）</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title class_">Generator</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成器的返回对象是一个迭代器，即便你没有写<code>return</code>也是如此。生成器一般用于避免回调地狱，即回调函数互相嵌套的场景。但最新的标准中已经有了更好的解决方案，此处就不做过多赘述，叙述生成器的一些一般特性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title class_">Generator</span>(<span class="title class_">First</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">First</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收下一次 next() 调用时的参数</span></span><br><span class="line">    <span class="comment">// 返回本次 next() 调用时的结果</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Second</span> = <span class="keyword">yield</span> <span class="title class_">First</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Second</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Third</span> = <span class="keyword">yield</span> <span class="title class_">Second</span> ** <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Third</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Third</span> ** <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Generator</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">3</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">4</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">5</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">next</span>(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">2</span><br><span class="line">&#123; value: 4, done: false &#125;</span><br><span class="line">4</span><br><span class="line">&#123; value: 64, done: false &#125;</span><br><span class="line">5</span><br><span class="line">&#123; value: 625, done: true &#125;</span><br><span class="line">&#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，生成器函数一开始是没有被调用的。直到返回的迭代器对象调用<code>next()</code>方法时，才第一次调用并执行生成器函数。</p>
<p>每一次调用<code>next()</code>方法时，生成器函数都会执行到下一个<code>yield</code>关键字处，并且返回值是<code>yield</code>关键字后的值（类似于一般的<code>return</code> ）。下一次调用<code>next()</code>函数时，参数将返回至上一次<code>yield</code>关键字处。当执行到<code>return</code>语句时，返回值对象中的<code>done</code>属性将为<code>true</code> ，并且会正常返回值。</p>
<h3 id="10-Promise"><a href="#10-Promise" class="headerlink" title="(10) Promise"></a><strong>(10) <code>Promise</code></strong></h3><p><code>Promise</code>是比生成器更适合用于解决回调地狱的新异步方案。<code>Promise()</code>实际上是一个构造函数，该构造函数接受1个参数，该参数应该为函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Promise 类的对象</span></span><br><span class="line"><span class="comment">// 参数函数的参数应当有两个，成功时调用的函数和失败时调用的函数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Success, Fail</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 省略部分代码，此处一般为 I/O</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="title class_">Success</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line">    <span class="comment">// Fail(&quot;Request Failed.&quot;);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当执行完时 then() 方法才会调用</span></span><br><span class="line"><span class="comment">// 根据执行状态，成功则执行第一个回调函数，失败则执行第二个</span></span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>请注意，上述代码中的<code>Success</code>与<code>Fail</code>并不是程序员所定义的函数，程序员也不需要定义它，更不需要传参数。</p>
<p>作为<code>Promise()</code>构造函数参数的函数，它在执行时的参数会由<code>Promise</code>类的对象自行传入，并在该对象生成后自行执行。若在该函数中调用了第一个回调函数<code>Success()</code> ，该对象的状态将被修改为成功，若调用了第二个则视为失败。其参数分别对应了读取成功的数据和执行失败的原因。</p>
<p>当构造函数参数的函数执行完毕时，<code>Promise</code>类的对象的<code>then()</code>方法开始执行，并且会根据该对象的状态来执行第一个或第二个回调函数。参数也分别是读取成功的数据和执行失败的原因。</p>
<p><code>then()</code>方法也会返回一个<code>Promise</code>类的对象，该对象的状态由<code>then()</code>方法的执行结果确定。成功执行回调，则为<code>resolved</code> ，否则为<code>rejected</code> 。因为<code>then()</code>方法的返回值也是一个<code>Promise</code>类的对象，因此可以使用链式的<code>then()</code>方法。</p>
<p>关于<code>Promise</code>对象，本文不会深究而只做浅述。深入学习的部分将会放在其他文章中。</p>
<h3 id="11-数据结构"><a href="#11-数据结构" class="headerlink" title="(11) 数据结构"></a><strong>(11) 数据结构</strong></h3><p>ES6标准下的JavaScript存在新的数据结构。</p>
<h4 id="1-Set（集合）"><a href="#1-Set（集合）" class="headerlink" title="1. Set（集合）"></a><strong>1. <code>Set</code>（集合）</strong></h4><p><code>Set</code>对象中的每一个元素都是唯一的。该数据结构实现了<code>iterator</code>接口。<code>Set</code>对象的常见属性与方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名 &#x2F; 属性名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Set()</code></td>
<td align="center">无或可迭代对象</td>
<td align="center">构造函数</td>
<td align="center"><code>Set</code>对象</td>
</tr>
<tr>
<td align="center"><code>size</code></td>
<td align="center">\</td>
<td align="center">返回元素个数</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>add()</code></td>
<td align="center">元素</td>
<td align="center">向<code>Set</code>对象中添加元素</td>
<td align="center">当前<code>Set</code>对象</td>
</tr>
<tr>
<td align="center"><code>delete()</code></td>
<td align="center">元素</td>
<td align="center">删除指定的元素</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>has()</code></td>
<td align="center">元素</td>
<td align="center">检测<code>Set</code>对象中是否含有指定元素</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>clear()</code></td>
<td align="center">无</td>
<td align="center">清空<code>Set</code>对象</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>由于<code>Set</code>对象是可迭代的，因此该对象可以使用扩展运算符以快速转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">114</span>, <span class="number">1919</span>, <span class="number">810</span>, <span class="number">1919</span>, <span class="number">514</span>, <span class="number">114</span>, <span class="number">810</span>];</span><br><span class="line">a = [...<span class="keyword">new</span> <span class="title class_">Set</span>(a)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = [ 114, 514, 1919, 810 ]</span><br></pre></td></tr></table></figure>

<p>上述代码实现了可迭代容器的快速去重。</p>
<h4 id="2-Map（映射）"><a href="#2-Map（映射）" class="headerlink" title="2. Map（映射）"></a><strong>2. <code>Map</code>（映射）</strong></h4><p><code>Map</code>对象中存在键值对，键是唯一的而值可以重复出现。该数据结构实现了<code>iterator</code>接口。<code>Map</code>对象的常见属性与方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名 &#x2F; 属性名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Map()</code></td>
<td align="center">无</td>
<td align="center">构造函数</td>
<td align="center"><code>Map</code>对象</td>
</tr>
<tr>
<td align="center"><code>set()</code></td>
<td align="center">键，值</td>
<td align="center">向<code>Map</code>对象中插入或更新键值对</td>
<td align="center">当前<code>Map</code>对象</td>
</tr>
<tr>
<td align="center"><code>size</code></td>
<td align="center">\</td>
<td align="center">返回键值对个数</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>delete()</code></td>
<td align="center">键</td>
<td align="center">删除指定的键值对</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>get()</code></td>
<td align="center">键</td>
<td align="center">获取键对应的值</td>
<td align="center">值或<code>undefined</code></td>
</tr>
</tbody></table>
<h3 id="12-class（类）"><a href="#12-class（类）" class="headerlink" title="(12) class（类）"></a><strong>(12) <code>class</code>（类）</strong></h3><p>在ES6标准下，定义类的语法本质上是语法糖，而不是新的语法规则，其底层实现依然是ES5的那一套。即：在ES6及其以上的标准中，依然可以使用ES5的语法。</p>
<h4 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1. 定义类"></a><strong>1. 定义类</strong></h4><p>虽然ES5中已经有构造函数与类了，但ES6的标准让类的写法更像C++，代码阅读起来更轻松。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 HIE 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 固定写法，定义构造函数</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写该类的方法</span></span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>);</span><br><span class="line"><span class="title class_">Lacia</span>.<span class="title class_">Info</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">HIE &#123; Name: &#x27;Lacia&#x27;, Type: &#x27;Type-005&#x27; &#125;</span><br><span class="line">My name is Lacia. Type is Type-005.</span><br></pre></td></tr></table></figure>

<p>上述代码的底层实现其实就是ES5定义类的那一套。</p>
<h4 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a><strong>2. 静态方法</strong></h4><p>与Java &#x2F; C#类似，JavaScript也允许在类中使用<code>static</code>关键字修饰成员变量或成员函数。被修饰的成员函数是静态的，只能通过类名调用而不能通过实例对象访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义静态成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Hello</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试通过实例对象来访问静态成员</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>.<span class="property">Hello</span>);</span><br><span class="line"><span class="variable constant_">HIE</span>.<span class="title class_">Hello</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">undefined</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>可以看到实例对象无法访问静态的成员，但类名可以。其底层实现仍然是基于ES5语法的。静态的成员实际上就是定义到了构造函数对象上，非静态的成员函数则是定义到了构造函数的原型对象上，而非静态的成员变量将会定义到实例化的对象上。</p>
<h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a><strong>3. 继承</strong></h4><p>在ES6标准下，一个类继承另一个类只需要使用<code>extends</code>关键字。JavaScript不允许多继承。<del>学Java的啥不好偏偏学了这个东西。</del></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title class_">Hello</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类，继承父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type, Age</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// super() 指父类的构造函数</span></span><br><span class="line">        <span class="variable language_">super</span>(<span class="title class_">Name</span>, <span class="title class_">Type</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Age</span> = <span class="title class_">Age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Speak</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.Age&#125;</span> years old.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Kouka</span> = <span class="keyword">new</span> <span class="title class_">Lacia</span>(<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Type-001&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Kouka</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Lacia &#123; Name: &#x27;Kouka&#x27;, Type: &#x27;Type-001&#x27;, Age: 17 &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码如果要用ES5的标准来写的话，应该是下述代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义父类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HIE</span>(<span class="params">Name, Type</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类成员方法</span></span><br><span class="line"><span class="variable constant_">HIE</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">Info</span> = <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义父类静态方法</span></span><br><span class="line"><span class="variable constant_">HIE</span>.<span class="property">Hello</span> = <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Lacia</span>(<span class="params">Name, Type, Age</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用父类构造函数</span></span><br><span class="line">    <span class="variable constant_">HIE</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="title class_">Name</span>, <span class="title class_">Type</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Age</span> = <span class="title class_">Age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承自父类，重设子类的原型对象为父类</span></span><br><span class="line"><span class="title class_">Lacia</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">HIE</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类方法</span></span><br><span class="line"><span class="title class_">Lacia</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">Speak</span> = <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.Age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Kouka</span> = <span class="keyword">new</span> <span class="title class_">Lacia</span>(<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Type-001&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Kouka</span>);</span><br></pre></td></tr></table></figure>

<p>想都不用想肯定是ES6的代码更清晰。要读懂并编写ES5的代码，要求读者对JavaScript的原型链有清楚的认知，而ES6标准下的代码像是对ES5的 “封装”，读者不必再了解其底层原理就能编写代码。</p>
<h4 id="4-重写父类方法"><a href="#4-重写父类方法" class="headerlink" title="4. 重写父类方法"></a><strong>4. 重写父类方法</strong></h4><p>ES6中允许子类存在与父类中同名的方法。子类在调用同名方法时，只会调用子类自身的方法，不会调用父类的方法。其底层实现是子类的原型对象（父类）上已经定义了子类自身的方法，在找到该方法后就不会再向原型对象的原型对象（父类的原型对象）上寻找该方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义父类同名方法</span></span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type, Age</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="title class_">Name</span>, <span class="title class_">Type</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Age</span> = <span class="title class_">Age</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义子类同名方法</span></span><br><span class="line">    <span class="title class_">Info</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;<span class="variable language_">this</span>.Name&#125;</span>. Type is <span class="subst">$&#123;<span class="variable language_">this</span>.Type&#125;</span>. Age is <span class="subst">$&#123;<span class="variable language_">this</span>.Age&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Kouka</span> = <span class="keyword">new</span> <span class="title class_">Lacia</span>(<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Type-001&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Kouka</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用子类方法</span></span><br><span class="line"><span class="title class_">Kouka</span>.<span class="title class_">Info</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试调用父类方法</span></span><br><span class="line"><span class="title class_">Kouka</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="title class_">Info</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Lacia &#123; Name: &#x27;Kouka&#x27;, Type: &#x27;Type-001&#x27;, Age: 17 &#125;</span><br><span class="line">My name is Kouka. Type is Type-001. Age is 17.</span><br><span class="line">My name is undefined. Type is undefined.</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>为什么是<code>undefined</code></strong></div>

<div style="color:royalblue;">可以看到虽然成功调用了父类方法，但输出却是<code>undefined</code> 。这是因为调用该方法的对象不是<code>Kouka</code> ，而是<code>Kouka</code>的原型对象的原型对象。子类实例的所有非静态属性是定义在子类实例对象上的，包括从父类继承的属性（理解这一点需要掌握ES5中继承的原理）。并且，调用者变为了原型对象的原型对象，因此<code>this</code>指针无法访问到对应的属性，就会输出<code>undefined</code>。</div>
</div>

<h4 id="5-getter与setter"><a href="#5-getter与setter" class="headerlink" title="5. getter与setter"></a><strong>5. <code>getter</code>与<code>setter</code></strong></h4><p>与Java &#x2F; C#类似，JavaScript的类中也存在<code>getter</code>与<code>setter</code> ，但其语法还是不如C#简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Capitalist</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Cashes</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Cashes</span> = <span class="title class_">Cashes</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">Capital</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getter 被调用了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">Cashes</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 setter</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">Capital</span>(<span class="params">Value</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Setter 被调用了&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Cashes</span> = <span class="title class_">Value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">JackMa</span> = <span class="keyword">new</span> <span class="title class_">Capitalist</span>(<span class="number">114514</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改与读取</span></span><br><span class="line"><span class="title class_">JackMa</span>.<span class="property">Capital</span> = <span class="number">1919810</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JackMa.Capital =&quot;</span>, <span class="title class_">JackMa</span>.<span class="property">Capital</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Setter 被调用了</span><br><span class="line">Getter 被调用了</span><br><span class="line">JackMa.Capital = 1919810</span><br></pre></td></tr></table></figure>

<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>不要让<code>getter()</code>或<code>setter()</code>与真实属性重名！</strong></div>

<div style="color:darkred;">如果出现了重名，尤其是与要读取 / 要修改的属性重名时，将会引发循环读取 / 循环写入。因为<code>getter()</code>和<code>setter()</code>的优先级比属性更高，使用时会优先使用它们。</div>
</div>

<h3 id="13-类的扩展"><a href="#13-类的扩展" class="headerlink" title="(13) 类的扩展"></a><strong>(13) 类的扩展</strong></h3><h4 id="1-数值与运算扩展"><a href="#1-数值与运算扩展" class="headerlink" title="1. 数值与运算扩展"></a><strong>1. 数值与运算扩展</strong></h4><p>ES6标准中定义了<code>Number</code>类的一些新的静态方法与静态属性。</p>
<table>
<thead>
<tr>
<th align="center">方法名 &#x2F; 属性名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>EPSILON</code></td>
<td align="center">\</td>
<td align="center">表示JavaScript中能表示的最小的数值</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>isFinite()</code></td>
<td align="center">任意值</td>
<td align="center">判断参数是否为有限的数</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>isNaN()</code></td>
<td align="center">任意值</td>
<td align="center">判断参数是否为<code>NaN</code></td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>parseInt()</code></td>
<td align="center">任意值</td>
<td align="center">将参数转换为整数</td>
<td align="center"><code>Number</code> ，转换失败时是<code>NaN</code></td>
</tr>
<tr>
<td align="center"><code>parseFloat()</code></td>
<td align="center">任意值</td>
<td align="center">将参数转换为浮点数</td>
<td align="center"><code>Number</code> ，转换失败时是<code>NaN</code></td>
</tr>
</tbody></table>
<p><code>Math</code>类中也新添了一些静态方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>trunc()</code></td>
<td align="center"><code>Number</code></td>
<td align="center">去掉该数字的小数部分</td>
<td align="center"><code>Number</code></td>
</tr>
<tr>
<td align="center"><code>sign()</code></td>
<td align="center"><code>Number</code></td>
<td align="center">判断一个数是正数负数还是0。</td>
<td align="center"><code>1</code> 、<code>0</code> 、<code>-1</code> ，判断失败时是<code>NaN</code></td>
</tr>
</tbody></table>
<p>此外，ES6标准允许像C一样书写二进制、八进制与十六进制的数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0b11</span>;   <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0o77</span>;   <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0xFF</span>;   <span class="comment">// 十六进制</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 3</span><br><span class="line">b = 63</span><br><span class="line">c = 255</span><br></pre></td></tr></table></figure>

<h4 id="2-对象的扩展"><a href="#2-对象的扩展" class="headerlink" title="2. 对象的扩展"></a><strong>2. 对象的扩展</strong></h4><p><code>Object</code>本身也是一个对象，该对象也扩展了一些静态方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>is()</code></td>
<td align="center">任意值，任意值</td>
<td align="center">判断两个参数是否完全相等</td>
<td align="center"><code>Boolean</code></td>
</tr>
<tr>
<td align="center"><code>assign()</code></td>
<td align="center"><code>Object</code> ，<code>Object</code></td>
<td align="center">合并两个对象，若有重名属性，则后者的属性值会覆盖前者</td>
<td align="center"><code>Object</code></td>
</tr>
<tr>
<td align="center"><code>setPrototypeOf()</code></td>
<td align="center"><code>Object</code> ，<code>Object</code></td>
<td align="center">将前者的原型对象设置为后者</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>getPrototypeOf()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">获取指定对象的原型对象</td>
<td align="center"><code>Object</code></td>
</tr>
</tbody></table>
<h3 id="14-模块化"><a href="#14-模块化" class="headerlink" title="(14) 模块化"></a><strong>(14) 模块化</strong></h3><p>JavaScript模块化，解决了JavaScript的命名空间污染、代码耦合度高、不便维护的问题。模块化的JavaScript文件，既可以被其他JavaScript文件引入，也可以被HTML文件中的<code>&lt;script&gt;</code>标签中的JavaScript代码引入。</p>
<p>要使用模块化，就需要指明这个模块对外暴露的变量或函数是什么。未被暴露的变量或方法，其他模块无权访问。可以使用<code>export</code>关键字修饰要暴露的变量或方法。</p>
<h4 id="1-直接暴露"><a href="#1-直接暴露" class="headerlink" title="1. 直接暴露"></a><strong>1. 直接暴露</strong></h4><p>直接暴露就是在声明变量或函数时就标注要暴露它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴露变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">114514</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1919810</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-统一暴露"><a href="#2-统一暴露" class="headerlink" title="2. 统一暴露"></a><strong>2. 统一暴露</strong></h4><p>统一暴露是指先把变量与函数都声明了，再在最后统一 “打包” 暴露。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">114514</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">1919810</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 a，b 打包并暴露</span></span><br><span class="line"><span class="keyword">export</span> &#123; a, b &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-默认暴露"><a href="#3-默认暴露" class="headerlink" title="3. 默认暴露"></a><strong>3. 默认暴露</strong></h4><p>使用默认暴露时，一般是暴露匿名对象，并且要在<code>export</code>关键字后追加<code>default</code>关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Vue&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义函数</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">114514</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用默认暴露的模块不能使用解构引入。</p>
<h4 id="4-通用引入"><a href="#4-通用引入" class="headerlink" title="4. 通用引入"></a><strong>4. 通用引入</strong></h4><p>引入模块时，需要指明引入模块的什么部分与模块的路径。可以选择为引入的对象用<code>as</code>关键字声明一个别名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Module</span> <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Module</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器的控制台中将会打印：</p>
<p><img src="/2022/04/30/ES6-ES11/1.png" alt="1" title="1"></p>
<p>可以看出<code>export</code>了的变量与函数是被<code>get()</code>和<code>set()</code>做了 “代理” 的。并且引入的变量与函数将被 “打包” 进一个变量。</p>
<p>不推荐以上述方式引入默认暴露的模块。因为当引入默认暴露的模块时，控制台的打印结果是：</p>
<p><img src="/2022/04/30/ES6-ES11/3.png" alt="3" title="3"></p>
<p>中间多夹了一层<code>default</code>对象。这也就意味着通过这种方式引入的模块，调用时要用形如<code>Module.default.a</code>的形式调用，很别扭。</p>
<h4 id="5-解构引入"><a href="#5-解构引入" class="headerlink" title="5. 解构引入"></a><strong>5. 解构引入</strong></h4><p>解构引入利用了ES6的解构特性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">b</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器的控制台中将会打印：</p>
<p><img src="/2022/04/30/ES6-ES11/2.png" alt="2" title="2"></p>
<p>解构引入同样可以声明别名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; a <span class="keyword">as</span> c, b &#125; <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在解构引入的情况下使用别名，一般是为了解决引入的不同模块之间的命名冲突问题。</p>
<h4 id="6-default引入"><a href="#6-default引入" class="headerlink" title="6. default引入"></a><strong>6. <code>default</code>引入</strong></h4><p>引入默认暴露的模块时，可以不需要<code>as</code>关键字，因为引入的就是一个对象，并且引入者可以用任意的变量名引入默认暴露的模块。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 引入 Hello.js 中默认暴露的模块</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> a <span class="comment">/* 此处可以填任意名字 */</span> <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 上述写法是简写形式，完整形式是</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> a &#125; <span class="keyword">from</span> <span class="string">&quot;./Hello.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意，上述代码中的第一种写法<span style="color:red;">只能</span>用于默认暴露的模块。</p>
<h2 id="三、ES7标准"><a href="#三、ES7标准" class="headerlink" title="三、ES7标准"></a><strong>三、ES7标准</strong></h2><p>ES6标准是改动最多的，学完ES6剩下的就相对简单多了。</p>
<h3 id="1-includes"><a href="#1-includes" class="headerlink" title="(1) includes()"></a><strong>(1) <code>includes()</code></strong></h3><p><code>includes()</code>方法定义在了<code>Array()</code>构造函数的原型对象下，也就是说该方法是数组的方法。该方法用于判断数组中是否含有某个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">includes</span>(<span class="number">114</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">includes</span>(<span class="string">&quot;114&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>需要注意的是，其底层判断原理是判断位于栈中的值与数组保存的数据（若为对象，则是其值是地址）是否相等，因此它不适合判断两个对象是否一致。除非是判断指向同一堆地址的对象，否则该方法都会返回<code>false</code> 。</p>
<h3 id="2-次方运算符"><a href="#2-次方运算符" class="headerlink" title="(2) 次方运算符"></a><strong>(2) 次方运算符</strong></h3><p>ES7标准增加了一种运算符<code>**</code> ，与其他语言类似，该运算符用于做次方运算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2 ** 8 =&quot;</span>, <span class="number">2</span> ** <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">2 ** 8 = 256</span><br></pre></td></tr></table></figure>

<p>本质上这是一个语法糖，其底层原理是<code>Math.pow()</code>方法。</p>
<h2 id="四、ES8标准"><a href="#四、ES8标准" class="headerlink" title="四、ES8标准"></a><strong>四、ES8标准</strong></h2><h3 id="1-async与await"><a href="#1-async与await" class="headerlink" title="(1) async与await"></a><strong>(1) <code>async</code>与<code>await</code></strong></h3><p><code>async</code>与<code>await</code>是关键字，它也可以用于解决回调地狱。它写起来像同步代码，但实际上其底层实现用到了<code>Promise</code> ， 即实际上还是异步。</p>
<p><code>async</code>用于修饰函数，被修饰的函数应当返回一个<code>Promise</code>对象或其他任意值。当返回值<span style="color:red;">不为</span> <code>Promise</code>对象时，真正返回的结果将是一个成功状态的<code>Promise</code>对象，并且其携带的值为返回值。即便是不写<code>return</code> ，也会返回一个<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回值为 undefined</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a() =&quot;</span>, <span class="title function_">a</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回一个失败状态的 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Succeed, Fail</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Fail</span>(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b() =&quot;</span>, <span class="title function_">b</span>());</span><br></pre></td></tr></table></figure>

<p>由于Node.js的打印并不会打印<code>Promise</code>对象的内部状态，此处就换为浏览器控制台来查看<code>Promise</code>对象：</p>
<p><img src="/2022/04/30/ES6-ES11/4.png" alt="4" title="4"></p>
<p><code>await</code>关键字只能出现在<code>async</code>关键字修饰的函数中，并且<code>await</code>后的值应当为一个<code>Promise</code>对象。<code>await</code>关键字有一个返回值，其值为<code>Promise</code>对象的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，其返回值是一个 Promise对象，但它不是 async 函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Succeed, Fail</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 成功返回值</span></span><br><span class="line">        <span class="title class_">Succeed</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Succeed, Fail</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将会抛出异常</span></span><br><span class="line">        <span class="title class_">Fail</span>(<span class="string">&quot;1919810&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为可能会抛出异常，因此需要进行错误处理</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 尝试获取成功结果</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">a</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功结果：&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="title class_">Error</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败信息：&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功结果：&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="title class_">Error</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败信息：&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="title function_">c</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">成功结果： 114514</span><br><span class="line">失败信息： 1919810</span><br></pre></td></tr></table></figure>

<p>上述写法很像同步语句，一方面完全规避了回调地狱，另一方面又规避了<code>Promise</code>的<code>then()</code>地狱（但又迎来了<code>try catch</code>地狱）。但至少上述写法阅读起来起来清爽简洁。</p>
<h3 id="2-对象的扩展-1"><a href="#2-对象的扩展-1" class="headerlink" title="(2) 对象的扩展"></a><strong>(2) 对象的扩展</strong></h3><p>ES8标准下的<code>Object</code>对象又多了一些方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>keys()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回指定对象的所有属性名</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>values()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回指定对象的所有属性值</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>entries()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回以<code>[属性名 , 属性值]</code>为元素的数组</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>getOwnPropertyDescriptors()</code></td>
<td align="center"><code>Object</code></td>
<td align="center">返回指定对象的所有属性的描述对象</td>
<td align="center"><code>Array</code></td>
</tr>
<tr>
<td align="center"><code>getOwnPropertyDescriptor()</code></td>
<td align="center"><code>Object</code> ，<code>String</code></td>
<td align="center">返回指定对象的指定属性名的描述对象</td>
<td align="center"><code>Array</code></td>
</tr>
</tbody></table>
<p>其中，<code>entries()</code>方法常用于一般对象转<code>Map</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="number">514</span>, <span class="attr">c</span>: <span class="string">&quot;1919&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;810&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值对</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Object.entries(a) =&quot;</span>, <span class="title class_">Object</span>.<span class="title function_">entries</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Map() 构造函数来初始化映射</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Object.entries(a) = [ [ &#x27;a&#x27;, 114 ], [ &#x27;b&#x27;, 514 ], [ &#x27;c&#x27;, &#x27;1919&#x27; ], [ &#x27;d&#x27;, &#x27;810&#x27; ] ]</span><br><span class="line">b = Map(4) &#123; &#x27;a&#x27; =&gt; 114, &#x27;b&#x27; =&gt; 514, &#x27;c&#x27; =&gt; &#x27;1919&#x27;, &#x27;d&#x27; =&gt; &#x27;810&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>而<code>getOwnPropertyDescriptors()</code>常用于深拷贝对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="number">514</span>, <span class="attr">c</span>: <span class="string">&quot;1919&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;810&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 a 的描述对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过描述对象来创建新对象</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">&#123;</span><br><span class="line">  a: &#123; value: 114, writable: true, enumerable: true, configurable: true &#125;,</span><br><span class="line">  b: &#123; value: 514, writable: true, enumerable: true, configurable: true &#125;,</span><br><span class="line">  c: &#123;</span><br><span class="line">    value: &#x27;1919&#x27;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  d: &#123;</span><br><span class="line">    value: &#x27;810&#x27;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a = &#123; a: 114, b: 514, c: &#x27;1919&#x27;, d: &#x27;810&#x27; &#125;</span><br><span class="line">b = [Object: null prototype] &#123; a: 114, b: 514, c: &#x27;1919&#x27;, d: &#x27;810&#x27; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、ES9标准"><a href="#五、ES9标准" class="headerlink" title="五、ES9标准"></a><strong>五、ES9标准</strong></h2><h3 id="1-扩展运算符的扩展"><a href="#1-扩展运算符的扩展" class="headerlink" title="(1) 扩展运算符的扩展"></a><strong>(1) 扩展运算符的扩展</strong></h3><p>ES6标准下的扩展运算符只能用于数组，而在ES9标准下则可以用于对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114</span>, <span class="attr">b</span>: <span class="string">&quot;514&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">c</span>: <span class="string">&quot;1919&quot;</span>, <span class="attr">d</span>: <span class="number">810</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">c = &#123; a: 114, b: &#x27;514&#x27;, c: &#x27;1919&#x27;, d: 810 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-正则表达式扩展"><a href="#2-正则表达式扩展" class="headerlink" title="(2) 正则表达式扩展"></a><strong>(2) 正则表达式扩展</strong></h3><p>不知道什么是正则表达式？正则表达式的知识不用全都记牢，看过一遍就行，忘记了再翻翻教程网站就好。此处不会对JavaScript的正则表达式做解释，详情请参见 <a class="btn" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions ">MDN 文档</a> 。</p>
<h4 id="1-捕获分组命名"><a href="#1-捕获分组命名" class="headerlink" title="1. 捕获分组命名"></a><strong>1. 捕获分组命名</strong></h4><p>在ES9标准下，可以对正则表达式捕获的分组做命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写待匹配的字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">HTML1</span> = <span class="string">&quot;&lt;div id=\&quot;app\&quot; class=\&quot;anime_top\&quot;&gt;主页&lt;/div&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写正则表达式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/&lt;div id=&quot;(a.*)&quot; class=&quot;anime_top&quot;&gt;(.*)&lt;\/div&gt;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>)[<span class="number">0</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>)[<span class="number">1</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>)[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">[</span><br><span class="line">  &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  &#x27;app&#x27;,</span><br><span class="line">  &#x27;主页&#x27;,</span><br><span class="line">  index: 0,</span><br><span class="line">  input: &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  groups: undefined</span><br><span class="line">]</span><br><span class="line">&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;</span><br><span class="line">app</span><br><span class="line">主页</span><br></pre></td></tr></table></figure>

<p>上述的正则表达式匹配提取方式需要根据下表来提取，不直观，也不便于代码维护。因此ES9提出了捕获分组命名。只需要在捕获的<code>()</code>内最开始处写上<code>?&lt;&gt;</code> ，将该分组的名称填入<code>&lt;&gt;</code>内即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">HTML1</span> = <span class="string">&quot;&lt;div id=\&quot;app\&quot; class=\&quot;anime_top\&quot;&gt;主页&lt;/div&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/&lt;div id=&quot;(?&lt;id&gt;a.*)&quot; class=&quot;anime_top&quot;&gt;(?&lt;innerHTML&gt;.*)&lt;\/div&gt;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意提取方式变了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">id</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">innerHTML</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">[</span><br><span class="line">  &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  &#x27;app&#x27;,</span><br><span class="line">  &#x27;主页&#x27;,</span><br><span class="line">  index: 0,</span><br><span class="line">  input: &#x27;&lt;div id=&quot;app&quot; class=&quot;anime_top&quot;&gt;主页&lt;/div&gt;&#x27;,</span><br><span class="line">  groups: [Object: null prototype] &#123; id: &#x27;app&#x27;, innerHTML: &#x27;主页&#x27; &#125;</span><br><span class="line">]</span><br><span class="line">app</span><br><span class="line">主页</span><br></pre></td></tr></table></figure>

<p>这种提取方式更利于阅读与后期维护。</p>
<h4 id="2-反向断言"><a href="#2-反向断言" class="headerlink" title="2. 反向断言"></a><strong>2. 反向断言</strong></h4><p>在ES9标准之前的JavaScript的正则表达式，可以指定匹配项的后一个字符 &#x2F; 字符串，这就是断言。而反向断言，就是对匹配项的前一个字符 &#x2F; 字符串做判断。不符合要求的子串都会被认为不与正则表达式匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待匹配的字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">HTML1</span> = <span class="string">&quot;114514JS1919810h&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/[A-Z]+(?&lt;num&gt;\d+)(?=h)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向断言，需要加上 “&lt;” 以标明这是反向断言</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="regexp">/(?&lt;=JS)(?&lt;num&gt;\d+)/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">num</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="title class_">HTML1</span>).<span class="property">groups</span>.<span class="property">num</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">1919810</span><br><span class="line">1919810</span><br></pre></td></tr></table></figure>

<p>两种匹配方式都成功了。</p>
<h4 id="3-全匹配模式"><a href="#3-全匹配模式" class="headerlink" title="3. .全匹配模式"></a><strong>3. <code>.</code>全匹配模式</strong></h4><p>在JavaScript的正则表达式中，<code>.</code>只能匹配非换行符。在用JavaScript爬取网页时，经常会遇到网页中的标签之间含有换行符，因此只能使用<code>\s+</code>进行匹配。这是非常痛苦的，因为写正则表达式一时爽，写完后debug那叫一个火葬场（至少我很不愿意阅读正则表达式）。ES9标准下可以追加一个标识符来让 <code>.</code>也能匹配到换行符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个类似于 HTML 格式的字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">HTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;h1&gt;Target&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式，末尾写上标识符 “s”，代表启用 . 的全匹配模式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="regexp">/&lt;div&gt;.*&lt;h1&gt;(?&lt;target&gt;.*)&lt;\/h1&gt;.*&lt;\/div&gt;/</span>s;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">exec</span>(<span class="variable constant_">HTML</span>).<span class="property">groups</span>.<span class="property">target</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Target</span><br></pre></td></tr></table></figure>

<p>在启用全匹配模时，对于正则表达式中的 <code>.*</code> ，建议启用禁止贪婪模式，即 <code>.*?</code> 。</p>
<h2 id="六、ES10标准"><a href="#六、ES10标准" class="headerlink" title="六、ES10标准"></a><strong>六、ES10标准</strong></h2><p>ES10标准的改动主要是针对静态方法的细节扩展，因此此处就不对ES10做全面的介绍。</p>
<p>ES10标注对<code>Object</code>对象的方法又又做了扩展。<del>梅开三度。</del></p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>fromEntries()</code></td>
<td align="center"><code>Map</code>或<code>Array</code></td>
<td align="center">根据参数生成对象</td>
<td align="center"><code>Object</code></td>
</tr>
</tbody></table>
<p><code>fromEntries()</code>方法的参数可以是<code>Map</code>的实例对象，也可以是格式形如<code>Object.entries()</code>方法的返回值的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="number">114514</span>, <span class="attr">b</span>: <span class="number">1919810</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过数组生成</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Map 的实例对象生成</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(a)));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c =&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">b = &#123; a: 114514, b: 1919810 &#125;</span><br><span class="line">c = &#123; a: 114514, b: 1919810 &#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>fromEntries()</code>方法就是<code>entries()</code>方法的逆运算。</p>
<h2 id="七、ES11标准"><a href="#七、ES11标准" class="headerlink" title="七、ES11标准"></a><strong>七、ES11标准</strong></h2><p>终于要学完力！芜湖！</p>
<h3 id="1-私有属性"><a href="#1-私有属性" class="headerlink" title="(1) 私有属性"></a><strong>(1) 私有属性</strong></h3><p>ES11标准下的JavaScript可以使用私有属性。若属性名的前缀含有 <code>#</code> ，则该属性为私有属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用私有属性前，必须先定义它</span></span><br><span class="line">    #<span class="title class_">Type</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">Name, Type</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">Name</span> = <span class="title class_">Name</span>;</span><br><span class="line">        <span class="variable language_">this</span>.#<span class="title class_">Type</span> = <span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">Type</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.#<span class="title class_">Type</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-001&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试打印实例对象与 getter 的返回值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>.<span class="property">Type</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会抛出异常</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>.#<span class="title class_">Type</span>);</span><br></pre></td></tr></table></figure>

<p>删除引发异常的代码后，输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js &#125;</span></span><br><span class="line">HIE &#123; Name: &#x27;Lacia&#x27; &#125;</span><br><span class="line">Type-001</span><br></pre></td></tr></table></figure>

<p>可以看到私有属性是完全不允许在类外访问的，但是在类外可以通过getter和setter访问与修改。</p>
<h3 id="2-matchAll"><a href="#2-matchAll" class="headerlink" title="(2) matchAll()"></a><strong>(2) <code>matchAll()</code></strong></h3><p><code>matchAll()</code>方法被定义在了<code>String()</code>构造函数的原型对象下，即该方法可以被所有的字符串类型的变量调用。该方法的参数应该为一个正则表达式对象，返回值是一个可迭代对象。该方法的功能相当于对调用该方法的字符串做全局匹配，匹配所有的符合正则表达式的结果。</p>
<p>返回的可迭代对象的<code>next()</code>方法将会返回一个正常的正则表达式的匹配结果对象。该方法常用于爬虫。</p>
<h3 id="3-可选链操作符"><a href="#3-可选链操作符" class="headerlink" title="(3) 可选链操作符"></a><strong>(3) 可选链操作符</strong></h3><p>有时函数需要接受一个对象作为参数，但对象中有些属性可能没有，甚至调用函数的时候根本没有传入参数。如果没有传入参数，那么函数中的形参就将是<code>undefined</code> 。如果此时在函数中尝试获取形参的属性，就将抛出异常：不能获取<code>undefined</code>的属性。因此需要先判断参数是否存在，然后判断形参的某个对象属性是否存在，然后再……这样太麻烦了。所以就有了可选链操作符<code>?</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params">config</span>) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若 ? 前的对象不存在，则结果将为 undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(config?.<span class="property">a</span>?.<span class="property">b</span>?.<span class="property">c</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整定义参数对象时</span></span><br><span class="line"><span class="title function_">a</span>(&#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">b</span>: &#123;</span><br><span class="line">            <span class="attr">c</span>: <span class="number">114514</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不传参数时</span></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">114514</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<p>若没有使用可选链操作符，第二次调用函数时将会抛出异常。</p>
<h3 id="4-动态引入"><a href="#4-动态引入" class="headerlink" title="(4) 动态引入"></a><strong>(4) 动态引入</strong></h3><p>当一个JavaScript文件引入了大量其他模块时，执行该文件前的时间开销将很大。为了加快启动速度，按需加载模块（懒加载，用到的时候再加载），于是有了ES11定义的动态引入。</p>
<p>要使用动态引入，需要使用<code>import()</code>方法。该方法的参数是模块的路径，返回值是一个<code>Promise</code>对象。该对象的成功结果即为模块本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按需引入，只有当参数为 true 时才引入</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Module</span> = <span class="keyword">await</span> <span class="title function_">import</span>(<span class="string">&quot;./Test.mjs&quot;</span>);</span><br><span class="line">        <span class="title class_">Module</span>.<span class="title function_">a</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="title function_">a</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure>

<h3 id="5-BigInt"><a href="#5-BigInt" class="headerlink" title="(5) BigInt"></a><strong>(5) <code>BigInt</code></strong></h3><p>为了解决JavaScript的大整数运算问题，ES11标准定义了一个新的类型：<code>BigInt</code>类型。定义属于该类型的整数时，在字面量尾部加上<code>n</code>即可。将一般的整数数值转换为<code>BigInt</code>类型，使用<code>BigInt()</code>函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">114514n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;typeof a =&quot;</span>, <span class="keyword">typeof</span> a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(<span class="number">1919810</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">typeof a = bigint</span><br><span class="line">1919810n</span><br></pre></td></tr></table></figure>

<p>请注意，使用<code>BigInt()</code>函数时，只能传入值为整数的参数或可以隐式类型转换为整数的参数，否则将会抛出异常。</p>
<h3 id="6-绝对全局对象"><a href="#6-绝对全局对象" class="headerlink" title="(6) 绝对全局对象"></a><strong>(6) 绝对全局对象</strong></h3><p>有时我们希望能够在一个普通的函数中访问到当前运行环境对象。为了更方便地获取该对象，ES11标准定义了一个绝对全局对象<code>globalThis</code> 。</p>
<p>需要注意的是，在浏览器环境下<code>this === globalThis</code>的值是<code>true</code> ，而Node.js环境下则是<code>false</code> 。因此此处使用浏览器进行演示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this === globalThis is&quot;</span>, <span class="variable language_">this</span> === globalThis);</span></span><br><span class="line"><span class="language-javascript">    globalThis.<span class="property">a</span> = <span class="function">() =&gt;</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">a</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/04/30/ES6-ES11/5.png" alt="5" title="5"></p>
<p>可以看出二者是等价的。</p>
<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">JavaScript每年都会发布新的标准。并且随着互联网的发展，JavaScript将会有更多的功能。本文所介绍的只是已有知识的冰山一角，比如<code>Promise</code>与正则表达式，本文只是浅尝辄止未作深入。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>JavaScript进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础（一）</title>
    <url>/2022/02/06/GoGrammar01/</url>
    <content><![CDATA[<img src="/2022/02/06/GoGrammar01/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言（最好是C/C++/C#）的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>Go运行快效率高，语法简单，可以说是兼具了C的效率与Python的简洁性，并且Go能扩展到非常多的领域。其中，区块链开发上Go已是一家独大。</p>
<p>Go支持声明变量的类型，并且支持指针。但相比C&#x2F;C++，Go又显得简洁许多。<del>但是类型名后置就是个屑设计。</del></p>
<p>开发Go的运行环境请自行准备。</p>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a><strong>二、基础语法</strong></h2><h3 id="1-主体结构"><a href="#1-主体结构" class="headerlink" title="(1) 主体结构"></a><strong>(1) 主体结构</strong></h3><p>Go与Python类似。Python中每一个文件都可以是一个“包”，通过 <code>import "文件路径"</code> 来引用另一个Python文件中的函数或类。而Go则必须显式声明这个文件属于哪一个包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>

<p>用上述代码在第一行声明本文件属于名为 <code>main</code> 的包。</p>
<p>并且Go也可以像Python一样引用包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里的引号是必需的。</p>
<p>与C&#x2F;C++一样，Go必须要有一个 <code>main()</code> 函数，但Go中的函数和Python的函数一样不需要声明返回类型。 <code>main()</code> 函数是程序开始执行的入口点。代码主体结构应该如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>函数与分号</strong></div>

<div style="color:royalblue;">在Go中，函数的 <code>&#123;</code> 必须写在 <code>()</code> 的同一行，否则编译器将会报错。因为Go中也使用分号分隔语句，但是Go的编译器在编译时会自动地在每一行后加上分号，因此如果函数的 <code>()</code> 后面没有 <code>&#123;</code> ，编译器将会加上分号导致报错。这也是为什么Go里不需要写分号，而写了分号也不会报错<del>但是编译器会给你删掉</del>。</div>
</div>

<p>上述代码可以在控制台中打印 <code>Hello, world!</code> 。其中使用了一个叫 <code>fmt</code> 的包。这个包与C的 <code>stdio.h</code> 、C++的 <code>iostream</code> 类似，它提供了与标准输入输出等相关的函数。想使用C的 <code>printf()</code> 函数和格式化字符串？那不妨试试使用 <code>fmt.Printf()</code> 。关于 <code>fmt</code> 包的更多详情，请前往 <a class="btn" href="https://studygolang.com/pkgdoc ">Go语言标准库文档</a> 。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>不使用 <code>fmt</code> 包进行输出</strong></div>

<div style="color:royalblue;">在1.17
.6（我使用的这个版本）下，可以直接使用 <code>print()</code> 和 <code>println()</code> 函数进行输出，但它们都不能支持格式化字符串。</div>
</div>

<p>要想获取输入，请使用 <code>fmt.Scanln()</code> 或 <code>fmt.Scanf()</code> 。前者相当于 <code>getline()</code> ，后者相当与 <code>scanf()</code> ，不过 <code>fmt.Scanln()</code> 和 <code>fmt.Scanf()</code> 的接收输入的变量都需要取地址。</p>
<h3 id="2-声明变量"><a href="#2-声明变量" class="headerlink" title="(2) 声明变量"></a><strong>(2) 声明变量</strong></h3><p>声明变量有三种方式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>   <span class="comment">//编译器自动推断类型</span></span><br><span class="line"><span class="keyword">var</span> j <span class="type">string</span> = <span class="string">&quot;114514&quot;</span>  <span class="comment">//显式声明类型</span></span><br><span class="line">k := <span class="literal">true</span>  <span class="comment">//简写，依然是自动推断类型</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>未使用的变量</strong></div>

<div style="color:goldenrod;">Go不允许有未使用过的局部变量和包。一旦编译器检测到未使用的局部变量与包，将会直接显示Error，编译不会通过。</div>
</div>

<p>要想声明多个变量，可以使用如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span></span><br><span class="line">Lacia, Kouka := <span class="string">&quot;Lacia&quot;</span>, <span class="number">114514</span></span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>全局变量</strong></div>

<div style="color:royalblue;">与C/C++一样，Go中也存在全局变量，其声明方式与局部变量大体一致，但是有一种更简便的方法。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    i = <span class="number">114</span></span><br><span class="line">    j = <span class="string">&quot;514&quot;</span></span><br><span class="line">    k = <span class="number">1919.81</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;j = &quot;</span>, j)</span><br><span class="line">    fmt.Println(<span class="string">&quot;k = &quot;</span>, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div>

<h3 id="3-基本类型"><a href="#3-基本类型" class="headerlink" title="(3) 基本类型"></a><strong>(3) 基本类型</strong></h3><div class="tabs" id="basicvariabletype"><ul class="nav-tabs"><li class="tab active"><a href="#basicvariabletype-1"><code>int</code> 系列</a></li><li class="tab"><a href="#basicvariabletype-2"><code>byte</code></a></li><li class="tab"><a href="#basicvariabletype-3"><code>float</code></a></li><li class="tab"><a href="#basicvariabletype-4"><code>bool</code></a></li><li class="tab"><a href="#basicvariabletype-5"><code>string</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="basicvariabletype-1"><p>Go中的int类型详细分了很多种类。</p>
<p>有符号： <code>int8</code> 、 <code>int16</code> 、 <code>int32</code> 、 <code>int64</code><br>无符号： <code>uint8</code> 、 <code>uint16</code> 、 <code>uint32</code> 、 <code>uint64</code></p>
<p>在32位操作系统上，使用默认的 <code>int</code> &#x2F; <code>uint</code> ，等同于 <code>int32</code> &#x2F; <code>uint32</code> ，在64为操作系统上则等同于 <code>int64</code> &#x2F; <code>uint64</code> 。</p>
<p>如果 <code>int</code> 型变量没有初始化，则默认初始化为0。</p></div><div class="tab-pane" id="basicvariabletype-2"><p>Go并没有单独设置 <code>char</code> 类型。要保存单个字符，那只能使用 <code>byte</code> 了。一个  <code>byte</code> 占一个字节。因为底层保存的其实是ASCII码，所以 <code>int</code> 系列的类型也能用于存放字符。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>Go的编码</strong></div>

<div style="color:royalblue;">Go的编码格式统一为UTF-8，中文字符也会以UTF-8的方式进行编码。要想保存UTF-8编码的中文字符，可以尝试使用 <code>int32</code> 或者它的别名 <code>rune</code> 。</div>
</div>

<p>如果 <code>byte</code> 型变量没有初始化，则默认初始化为0。</p></div><div class="tab-pane" id="basicvariabletype-3"><p>Go中没有 <code>float</code> 与 <code>double</code> 类型，但是有占用大小一致的 <code>float32</code> 与 <code>float64</code> 类型。</p>
<p>如果 <code>float</code> 型变量没有初始化，则默认初始化为0。</p></div><div class="tab-pane" id="basicvariabletype-4"><p>与C&#x2F;C++相似， <code>bool</code> 类型只能存放 <code>true</code> 和 <code>false</code> 两个值中的一个，但不能对 <code>bool</code> 类型赋 <code>int</code> 型变量的值。</p>
<p>如果 <code>bool</code> 型变量没有初始化，则默认初始化为 <code>false</code> 。</p></div><div class="tab-pane" id="basicvariabletype-5"><p>Go将 <code>string</code> 类型归类到了基本类型，它的底层实现其实是一个 <code>byte</code> 数组。对 <code>string</code> 类型中的某一个字符的修改是非法的，但是你能直接给 <code>string</code> 类型的变量赋值一个新的字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HIE = <span class="string">&quot;Kouka&quot;</span></span><br><span class="line">HIE = <span class="string">&quot;Lacia&quot;</span>   <span class="comment">//这里不不会报错</span></span><br><span class="line"><span class="built_in">println</span>(HIE[<span class="number">0</span>])    <span class="comment">//打印结果为76，是&#x27;L&#x27;的ASCII码</span></span><br><span class="line">HIE[<span class="number">0</span>] = <span class="string">&#x27;K&#x27;</span>   <span class="comment">//这一行会报错</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>string</code> 型变量没有初始化，则默认初始化为 <code>""</code> 。</p></div></div></div>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>查看变量类型</strong></div>

<div style="color:royalblue;">可以使用 <code>fmt.Printf()</code> 与格式化字符串来查看变量类型。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Unknown = <span class="string">&#x27;中&#x27;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Unknown is&quot;</span>, Unknown)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Unknown is %c\n&quot;</span>, Unknown)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type of Unknown is %T\n&quot;</span>, Unknown)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run Hello.go</span></span><br><span class="line">Unknown is 20013</span><br><span class="line">Unknown is 中</span><br><span class="line">Type of Unknown is int32</span><br></pre></td></tr></table></figure>
</div>

<p>你可以使用 <code>type</code> 关键字来声明类型的别名。但是编译器会认为别名与本名不属于同一个类型，必须使用显式类型转换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Lacia <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> i Lacia = <span class="string">&quot;HIE&quot;</span></span><br><span class="line"><span class="keyword">var</span> j <span class="type">string</span> = <span class="string">&quot;Kouka&quot;</span></span><br><span class="line">i = Lacia(j)   <span class="comment">//去掉显式类型转换就会报错</span></span><br><span class="line"><span class="built_in">println</span>(i)</span><br></pre></td></tr></table></figure>

<p>所有的数据类型都可以声明它的别名，包括函数。这将在之后提及。</p>
<p>在Go中，值类型包括上述的类型、数组还有结构体。剩下的都为引用类型，如指针、map等。</p>
<h3 id="4-类型转换"><a href="#4-类型转换" class="headerlink" title="(4) 类型转换"></a><strong>(4) 类型转换</strong></h3><h4 id="1-数值转换"><a href="#1-数值转换" class="headerlink" title="1. 数值转换"></a><strong>1. 数值转换</strong></h4><p>对于熟悉C&#x2F;C++&#x2F;C#的同学来说，Go中没有隐式类型转换是一件令人沮丧的事，但是Go有显式类型转换。显式类型转换的语法有点像C++&#x2F;C#的类。使用 <code>类型名(变量)</code> 以进行显式类型转换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int8</span> = <span class="number">114</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="type">int64</span>(i)</span><br></pre></td></tr></table></figure>

<p>在大范围类型的变量转换为小范围类型变量时，有可能造成溢出。但是编译器无法检测到这种溢出，转换时会按处理溢出的方式来处理显式类型转换。</p>
<h4 id="2-字符串转换"><a href="#2-字符串转换" class="headerlink" title="2. 字符串转换"></a><strong>2. 字符串转换</strong></h4><p>在 <code>fmt</code> 包中定义了一个函数 <code>Sprintf()</code> 。它的参数与C&#x2F;C++的 <code>printf()</code> 、上文提到的 <code>fmt.printf()</code> 一致，支持格式化字符串。但是它并不向标准输出输出结果，而是将结果作为返回值，以 <code>string</code> 类型返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Name, Age, Type = <span class="string">&quot;Lacia&quot;</span>, <span class="number">17</span>, <span class="string">&#x27;5&#x27;</span></span><br><span class="line">Output := fmt.Sprintf(<span class="string">&quot;I&#x27;m %s, %d years old, Type-00%c&quot;</span>, Name, Age, Type)</span><br><span class="line"><span class="built_in">println</span>(Output)</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run Hello.go</span></span><br><span class="line">I&#x27;m Lacia, 17 years old, Type-005</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>Go的占位符</strong></div>

<div style="color:royalblue;">Go新定义了一些格式化字符串的占位符，这些占位符是C/C++所没有的。想查看所有的占位符，请前往 <a class="btn" href="https://studygolang.com/pkgdoc ">Go语言标准库文档</a> 。</div>
</div>

<p><code>fmt</code> 包中的函数只能将非字符串类型转换为字符串类型。想将字符串类型转换为非字符串类型，可以使用 <code>strconv</code> 包内定义的函数。</p>
<div class="tabs" id="strconvfunction"><ul class="nav-tabs"><li class="tab active"><a href="#strconvfunction-1"><code>FormatBool()</code></a></li><li class="tab"><a href="#strconvfunction-2"><code>FormatInt()</code></a></li><li class="tab"><a href="#strconvfunction-3"><code>FormatUint()</code></a></li><li class="tab"><a href="#strconvfunction-4"><code>FormatFloat()</code></a></li><li class="tab"><a href="#strconvfunction-5"><code>Itoa()</code></a></li><li class="tab"><a href="#strconvfunction-6"><code>ParseBool()</code></a></li><li class="tab"><a href="#strconvfunction-7"><code>ParseInt()</code></a></li><li class="tab"><a href="#strconvfunction-8"><code>ParseUint()</code></a></li><li class="tab"><a href="#strconvfunction-9"><code>ParseFloat()</code></a></li><li class="tab"><a href="#strconvfunction-10"><code>Atoi()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="strconvfunction-1"><p>该函数将 <code>bool</code> 转换为 <code>string</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(parameter <span class="type">bool</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>参数只有一个 <code>bool</code> 型变量 <code>parameter</code> ，会将它转换为 <code>string</code> 类型。</p></div><div class="tab-pane" id="strconvfunction-2"><p>该函数将 <code>int64</code> 转换为 <code>string</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(parameter <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>将 <code>int64</code> 型变量 <code>parameter</code> 转换为 <code>base</code> 进制的 <code>string</code> 类型。 <code>base</code> 的取值范围只能在2~36之间。</p></div><div class="tab-pane" id="strconvfunction-3"><p>与 <code>FormatInt()</code> 基本一致。<br>该函数将 <code>uint64</code> 转换为 <code>string</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(parameter <span class="type">uint64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>将 <code>uint64</code> 型变量 <code>parameter</code> 转换为 <code>base</code> 进制的 <code>string</code> 类型。 <code>base</code> 的取值范围只能在2~36之间。</p></div><div class="tab-pane" id="strconvfunction-4"><p>该函数将 <code>float</code> 转换为 <code>string</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(parameter <span class="type">float64</span>, format  <span class="type">byte</span>, prec <span class="type">int</span>, floatType <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>将 <code>float64</code> 型变量 <code>parameter</code> 转换为 <code>string</code> 。其中 <code>format</code> 控制转换格式， <code>prec</code> 控制转换精度， <code>floatType</code> 代表 <code>parameter</code> 是 <code>float32</code> 类型还是 <code>float64</code> 类型。</p></div><div class="tab-pane" id="strconvfunction-5"><p>相当于 <code>FormatInt(parameter int, 10)</code> 。但是请注意此处的 <code>parameter</code> 是 <code>int</code> 类型，而非 <code>int64</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(parameter <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="strconvfunction-6"><p>该函数将 <code>string</code> 转换为 <code>bool</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(parameter <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>请注意这个函数有两个返回值，一个为 <code>bool</code> 类型的转换结果，另一个为 <code>error</code> 类型的报错。如果字符串无法转换为 <code>bool</code> 类型，则会返回报错信息。</p></div><div class="tab-pane" id="strconvfunction-7"><p>该函数将 <code>string</code> 转换为 <code>int64</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(parameter <span class="type">string</span>, base <span class="type">int</span>, intType <span class="type">int</span>)</span></span> <span class="type">int64</span></span><br></pre></td></tr></table></figure>

<p>请注意这个函数有两个返回值，一个为 <code>int64</code> 类型的转换结果，另一个为 <code>error</code> 类型的报错。如果字符串无法转换为 <code>int64</code> 类型，则会返回报错信息。其中 <code>base</code> 控制转换的进制， <code>intType</code> 控制转换结果为哪一个具体类型的 <code>int</code> 。</p></div><div class="tab-pane" id="strconvfunction-8"><p>该函数将 <code>string</code> 转换为 <code>uint64</code> ，参数、细节与 <code>ParseInt()</code> 一致，但不接受正负号。</p></div><div class="tab-pane" id="strconvfunction-9"><p>该函数将 <code>string</code> 转换为 <code>float64</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(parameter <span class="type">string</span>, floatType <span class="type">int</span>)</span></span> <span class="type">float64</span></span><br></pre></td></tr></table></figure>

<p>请注意这个函数有两个返回值，一个为 <code>float64</code> 类型的转换结果，另一个为 <code>error</code> 类型的报错。如果字符串无法转换为 <code>float64</code> 类型，则会返回报错信息。其中， <code>floatType</code> 控制转换结果为 <code>float32</code> 类型还是 <code>float64</code> 类型。</p></div><div class="tab-pane" id="strconvfunction-10"><p>相当于 <code>ParseInt(parameter string, 10, 0)</code> ，但是返回值为 <code>int</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(parameter <span class="type">string</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="5-指针"><a href="#5-指针" class="headerlink" title="(5) 指针"></a><strong>(5) 指针</strong></h3><p>指针是个好文明。<del>因为我学的数据结构是C++的数据结构，离了指针我都不知道怎么画树。</del>Go保留了指针，它的用法和C&#x2F;C++大同小异。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">114514</span></span><br><span class="line"><span class="keyword">var</span> b *<span class="type">int64</span> = &amp;a</span><br><span class="line"><span class="keyword">var</span> c **<span class="type">int64</span> = &amp;b</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;**c = &quot;</span>, **c)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run Hello.go</span></span><br><span class="line">**c =  114514</span><br></pre></td></tr></table></figure>

<p>可以指针套娃。<del>C++人狂喜。</del>与C++相似，Go也可以为指针分配新地址。要想给空指针分配地址，可以使用 <code>new()</code> 函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i *<span class="type">int</span> = <span class="literal">nil</span>  <span class="comment">//相当于NULL或nullptr</span></span><br><span class="line">i = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">*i = <span class="number">114514</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>空指针</strong></div>

<div style="color:goldenrod;">Go的编译器很严格，然而还是没能解决C/C++遗留下来的问题——空指针赋值检测。在Go中，对空指针的赋值不会引起编译器报错，只会在运行时出现程序异常。你应当注意你的指针有没有确切地指向值的地址。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line">*i = <span class="number">114514</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;*i =&quot;</span>, *i)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">报错信息为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">panic: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">[signal 0xc0000005 code=0x1 addr=0x0 pc=0xac57a]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        D:/Go/src/Golang/Hello/main/main.go:9 +0x1a</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>
</div>

<p><code>new()</code> 函数不能分配多个连续的值地址。首先，Go中的数组是独立的变量类型，不像C&#x2F;C++一样；其次，Go中为数组等引用类型的变量分配空间时，应该使用 <code>make()</code> 函数。这将在之后讲述。</p>
<h3 id="6-控制流"><a href="#6-控制流" class="headerlink" title="(6) 控制流"></a><strong>(6) 控制流</strong></h3><p>Go里有 <code>if</code> 、 <code>switch</code> 、 <code>for</code> 循环。它们都和C&#x2F;C++大同小异。但是Go删除了 <code>while</code> 循环，因为它被 <code>for</code> 替代了。</p>
<h4 id="1-if"><a href="#1-if" class="headerlink" title="1. if"></a><strong>1. <code>if</code></strong></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">59</span></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">100</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i &gt; 100&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; <span class="number">50</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i &lt; 50&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>C++人看完代码，被格式气死了。</del>Go的 <code>if</code> 语句只能这么写。条件判断处可以不加括号<del>加上后编译器也会给你删咯</del>。 <code>&#123;</code> 不能换行，并且 <code>else if</code> 和 <code>else</code> 也都必须写在 <code>&#125;</code> 后，不然编译器会自动加上分号导致报错。</p>
<h4 id="2-switch"><a href="#2-switch" class="headerlink" title="2. switch"></a><strong>2. <code>switch</code></strong></h4><p>Go的 <code>switch</code> 不再需要 <code>break</code> 了。当匹配到符合的 <code>case</code> 时，只会执行这个 <code>case</code> 内的语句，执行完以后不需要 <code>break</code> ，直接退出 <code>switch</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="string">&quot;114514&quot;</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;1919810&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;1919&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;810&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;114514&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;114&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;514&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run Hello.go</span></span><br><span class="line">114</span><br><span class="line">514</span><br></pre></td></tr></table></figure>

<p>Go的 <code>case</code> 语句可以使用 <code>,</code> 来分隔多种匹配值，这些匹配值共用一个 <code>case</code> 。 <code>case</code> 的匹配值可以是变量，但是该变量的类型必须与待判断表达式的类型一致，否则编译器将会报错。</p>
<h4 id="3-for"><a href="#3-for" class="headerlink" title="3. for"></a><strong>3. <code>for</code></strong></h4><p>Go的 <code>for</code> 有三种写法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    temp++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;temp = %c\n&quot;</span>, temp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">    temp++</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;temp = %c\n&quot;</span>, temp)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    temp++</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">13</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;temp = %c\n&quot;</span>, temp)</span><br></pre></td></tr></table></figure>

<p>可以看出，第一种写法类似于标准的C&#x2F;C++的 <code>for</code> 循环，第二种写法与C&#x2F;C++的 <code>while</code> 循环基本一致。最后一种则相当于C&#x2F;C++的 <code>while(1)</code> 或 <code>for( ; ; )</code> 。</p>
<p>Go的 <code>break</code> 可以跳出多个循环，但需要使用标签。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Mark:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;i = &quot;</span>, i)</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> Mark</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会直接跳出两个循环，也就是直接跳出与 <code>Mark</code> 同一级的循环。</p>
<h3 id="7-函数"><a href="#7-函数" class="headerlink" title="(7) 函数"></a><strong>(7) 函数</strong></h3><p>Go的函数声明需要使用 <code>func</code> 关键字，参数类型后置，并且如果有返回值，最好显式声明返回值的类型。Go允许函数返回多个值，这一点与Python相似。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Function</span><span class="params">(i <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Lacia&quot;</span>, <span class="number">17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>声明返回值</strong></div>

<div style="color:royalblue;">有另一种可以声明返回值的方式。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Function</span><span class="params">(i <span class="type">int</span>)</span></span> (Lacia <span class="type">string</span>, Age <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">    Lacia = <span class="string">&quot;Lacia&quot;</span>   <span class="comment">//注意是赋值</span></span><br><span class="line">    Age = <span class="number">17</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>Go没有像C++一样的参数引用。要想修改参数，必须使用指针传参。同时Go也没有C++&#x2F;C#的重载，同一个包下的函数不允许同名。</p>
<p>Go中的函数也是一种数据类型，可以赋值给变量，这一点有点像JavaScript。如果用C++的思路来理解，这应该叫指向函数的指针。如果用C#的思路来理解，这应该叫委托。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Function</span><span class="params">(p *<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    *p += <span class="string">&quot;Lacia&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;HIE：&quot;</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">string</span> = &amp;a</span><br><span class="line">    <span class="keyword">var</span> c <span class="function"><span class="keyword">func</span><span class="params">(*<span class="type">string</span>)</span></span> <span class="type">bool</span> = Function</span><br><span class="line">    <span class="built_in">println</span>(c(p))</span><br><span class="line">    <span class="built_in">println</span>(*p)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of c is %T\n&quot;</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">true</span><br><span class="line">HIE：Lacia</span><br><span class="line">Type of c is func(*string)</span><br></pre></td></tr></table></figure>

<p>在上述代码中，将函数 <code>Function()</code> 赋值给 <code>c</code> 的这一段非常像C&#x2F;C++的指向函数的指针，但 <code>c</code> 不是指针而是变量。因此在Go中可以将函数作为参数进行传递。</p>
<p>也可以用类似的方法声明某一类函数（有相同的参数类型、参数个数、返回值个数、返回值类型的函数）的别名。</p>
<p>Go的函数也支持可变参数，但此处不做赘述。</p>
<h4 id="1-init-函数"><a href="#1-init-函数" class="headerlink" title="1. init() 函数"></a><strong>1. <code>init()</code> 函数</strong></h4><p>在Go中，每一个包都可以包含一个 <code>init()</code> 函数。这个 <code>init()</code> 函数将先于 <code>main()</code> 函数执行。</p>
<p>在同一个包内的，与全局变量初始化相关的函数将比 <code>init()</code> 函数更先执行。如果引入了其它的包，那么将会优先执行引入的包的全局变量初始化函数，再执行引入的包的 <code>init()</code> 函数，最后再执行 <code>main</code> 包的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main包的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;Golang/Hello/test&quot;</span>  <span class="comment">//test包的路径</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Package main main() executed.&quot;</span>)</span><br><span class="line">    <span class="comment">//这里需要用一次test包的函数，不然会提示test被引用但未使用</span></span><br><span class="line">    <span class="built_in">println</span>(test.GlobalVarInit())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Package main int() executed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = GlobalVarInit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GlobalVarInit</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Package main GlobalVarInit() executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test包的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Package test init() executed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = GlobalVarInit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GlobalVarInit</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Package test GlobalVarInit() executed.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">Package test GlobalVarInit() executed.</span><br><span class="line">Package test init() executed.</span><br><span class="line">Package main GlobalVarInit() executed.</span><br><span class="line">Package main int() executed.</span><br><span class="line">Package main main() executed.</span><br><span class="line">Package test GlobalVarInit() executed.</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h4 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2. 匿名函数"></a><strong>2. 匿名函数</strong></h4><p>与JavaScript类似，Go的函数可以不声明函数名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, world!&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>但是上面这种声明匿名函数的方式既不能调用函数，同时也会因为函数没有被调用而造成编译器报错。所以可以采用“JavaScript的方式”来解决。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">&quot;Hello, world!&quot;</span>) &#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>像这样将匿名函数赋值给变量，就能通过变量来调用匿名函数。这么做可以防止污染全局命名空间，变量在函数结束调用以后会自动释放。</p>
<h4 id="3-闭包函数"><a href="#3-闭包函数" class="headerlink" title="3. 闭包函数"></a><strong>3. 闭包函数</strong></h4><p>既然函数能赋值给变量，能作为参数传递，那么返回值可以是函数吗？可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    j, _ := Function()</span><br><span class="line">    <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;j(5) = &quot;</span>, j(<span class="number">5</span>))</span><br><span class="line">        _, k = Function()</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;k = &quot;</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Function</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i += n</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j, i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">j(5) =  15</span><br><span class="line">k =  10</span><br><span class="line">j(5) =  20</span><br><span class="line">k =  10</span><br><span class="line">j(5) =  25</span><br><span class="line">k =  10</span><br></pre></td></tr></table></figure>

<p>学过JavaScript的同学应该看到“闭包函数”时就已经明白了。上述的代码中将函数作为返回值，并且这个返回的函数调用了局部变量。可以看到这个返回的函数并没有实际改变函数内的局部变量，但是确实结果在不断累加。闭包函数与C++的类有相似之处，具体原理涉及到变量的的作用域，此处不做赘述。</p>
<p>函数与它所调用的所有变量，共同构成一个闭包。</p>
<h4 id="4-defer"><a href="#4-defer" class="headerlink" title="4. defer"></a><strong>4. <code>defer</code></strong></h4><p>在函数中，使用 <code>defer</code> 关键字修饰的语句不会立即执行，而是将该语句及其相关的资源压入一个栈。在函数退出时，按FILO顺序依次执行栈中语句。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Last output =&quot;</span>, Function(<span class="number">114514</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Function</span><span class="params">(inm <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;Second output =&quot;</span>, inm)</span><br><span class="line">    inm = <span class="number">1919810</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;First output =&quot;</span>, inm)</span><br><span class="line">    <span class="keyword">return</span> inm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">First output = 1919810</span><br><span class="line">Second output = 114514</span><br><span class="line">Last output = 1919810</span><br></pre></td></tr></table></figure>

<p>可以看到上述代码中，被 <code>defer</code> 的语句并没有改变它被 <code>defer</code> 前应该输出的结果。因此，可以利用 <code>defer</code> 关键字在打开文件、请求堆空间等操作后立即使用 <code>defer</code> 关键字释放资源。资源并不会立即释放，而是会等到函数执行完毕以后再释放。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong> <code>defer</code> 与指针</strong></div>

<div style="color:royalblue;">将上述代码的参数更改为指针，将 <code>defer</code> 输出的语句更改为输出指针指向的值，得到的依然是修改前的值。这说明 <code>defer</code> 语句应该是提前将指针指向的的值放到了栈中。</div>
</div>

<h4 id="5-常用函数"><a href="#5-常用函数" class="headerlink" title="5. 常用函数"></a><strong>5. 常用函数</strong></h4><div class="tabs" id="usefulfunction"><ul class="nav-tabs"><li class="tab active"><a href="#usefulfunction-1"><code>len()</code></a></li><li class="tab"><a href="#usefulfunction-2"><code>Contains()</code></a></li><li class="tab"><a href="#usefulfunction-3"><code>Count()</code></a></li><li class="tab"><a href="#usefulfunction-4"><code>EqualFold()</code></a></li><li class="tab"><a href="#usefulfunction-5"><code>HasPrefix()</code></a></li><li class="tab"><a href="#usefulfunction-6"><code>HasSuffix()</code></a></li><li class="tab"><a href="#usefulfunction-7"><code>Index()</code></a></li><li class="tab"><a href="#usefulfunction-8"><code>LastIndex()</code></a></li><li class="tab"><a href="#usefulfunction-9"><code>Replace()</code></a></li><li class="tab"><a href="#usefulfunction-10"><code>Split()</code></a></li><li class="tab"><a href="#usefulfunction-11"><code>ToLower()</code></a></li><li class="tab"><a href="#usefulfunction-12"><code>ToUpper()</code></a></li><li class="tab"><a href="#usefulfunction-13"><code>Trim()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="usefulfunction-1"><p><code>len()</code> 函数是内置的，不需要引用其它包。它可以用于测量字符串的字节数和数组的长度。由于Go统一采用UTF-8编码，在这种编码方式中，汉字占3个字节，因此使用 <code>len()</code> 来统计含有汉字时的字符串将不会返回字符数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="string">&quot;你好，世界！&quot;</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;len(i) =&quot;</span>, <span class="built_in">len</span>(i))</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;len(j) =&quot;</span>, <span class="built_in">len</span>(j))</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">len(i) = 13</span><br><span class="line">len(j) = 18</span><br></pre></td></tr></table></figure>

<p>可以看见不仅是汉字，中文输入法的汉字字符也会占用3个字节。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>输出单个汉字</strong></div>

<div style="color:royalblue;">可以尝试使用下面的代码。但是原理下文再详述。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="string">&quot;你好，世界！&quot;</span></span><br><span class="line"><span class="keyword">var</span> j = []<span class="type">int32</span>(i)</span><br><span class="line"><span class="comment">//原理下文详述。这里使用了一个显式类型转换。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;i = %c&quot;</span>, j[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
</div></div><div class="tab-pane" id="usefulfunction-2"><p><code>Contains()</code> 函数位于 <code>strings</code> 包内。它可以查找字符串内是否含有某个指定的子串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(String <span class="type">string</span>, SubString <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待查找的字符串， <code>SubString</code> 为指定的子串。返回值为 <code>bool</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-3"><p><code>Count()</code> 函数位于 <code>strings</code> 包内。它可以返回字符串内某个指定的子串出现的次数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(String <span class="type">string</span>, SubString <span class="type">string</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待查找的字符串， <code>SubString</code> 为指定的子串。返回值为 <code>int</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-4"><p><code>EqualFold()</code> 函数位于 <code>strings</code> 包内。它可以不区分大小写地比较两个字符串是否相等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqualFold</span><span class="params">(First <span class="type">string</span>, Second <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="usefulfunction-5"><p><code>HasPrefix()</code> 函数位于 <code>strings</code> 包内。它可以检测字符串是否以指定的字符串为前缀。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(String <span class="type">string</span>, Prefix <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待检测的字符串， <code>Prefix</code> 为指定的前缀。返回值为 <code>bool</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-6"><p><code>HasSuffix()</code> 函数位于 <code>strings</code> 包内。它可以检测字符串是否以指定的字符串为后缀。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(String <span class="type">string</span>, Suffix <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待检测的字符串， <code>Suffix</code> 为指定的后缀。返回值为 <code>bool</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-7"><p><code>Index()</code> 函数位于 <code>strings</code> 包内。它可以返回指定的子串在字符串中第一次出现的位置。若未检测到子串则返回-1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(String <span class="type">string</span>, SubString <span class="type">string</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待检测的字符串， <code>SubString</code> 为指定的子串。返回值为 <code>int</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-8"><p><code>Index()</code> 函数位于 <code>strings</code> 包内。它可以返回指定的子串在字符串中最后一次出现的位置。若未检测到子串则返回-1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(String <span class="type">string</span>, SubString <span class="type">string</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待检测的字符串， <code>SubString</code> 为指定的子串。返回值为 <code>int</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-9"><p><code>Replace()</code> 函数位于 <code>strings</code> 包内。它可以替换字符串中的指定的子串为新的子串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(String <span class="type">string</span>, Substring, Replace <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待替换的字符串； <code>SubString</code> 为指定的需要替换的子串； <code>Replace</code> 为替换子串的字符串； <code>n</code> 为要替换多少个子串，填-1则替换所有的子串。返回值为 <code>string</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-10"><p><code>Split()</code> 函数位于 <code>strings</code> 包内。它可以按给定的子串为界分割字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(String <span class="type">string</span>, Gap <span class="type">string</span>)</span></span> []<span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待检测的字符串， <code>Gap</code> 为指定的子串。返回值为 <code>string</code> 类型。</p></div><div class="tab-pane" id="usefulfunction-11"><p><code>ToLower()</code> 函数位于 <code>strings</code> 包内。它可以把给定的字符串全部转换为小写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(String <span class="type">string</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待转换的字符串，返回值为 <code>string</code>类型。</p></div><div class="tab-pane" id="usefulfunction-12"><p><code>ToUpper()</code> 函数位于 <code>strings</code> 包内。它可以把给定的字符串全部转换为大写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(String <span class="type">string</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>String</code> 为待转换的字符串，返回值为 <code>string</code>类型。</p></div><div class="tab-pane" id="usefulfunction-13"><p><code>Trim()</code> 函数位于 <code>strings</code> 包内。它可以把给定的字符串开头和结尾的指定字符串去掉。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(String <span class="type">string</span>, CutSet <span class="type">string</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>使用样例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j = <span class="string">&quot;%Hello, world!%&quot;</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;Trim(j) =&quot;</span>, strings.Trim(j, <span class="string">&quot;%&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">j = %Hello, world!%</span><br><span class="line">Trim(j) = Hello, world!</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a><strong>三、异常处理</strong></h2><p>Go中没有 <code>try</code> 块。要处理异常，可以使用 <code>recover()</code> 函数与 <code>defer</code> 关键字。 <code>recover()</code> 是内建函数，不需要引用任何包。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ErrorGenerator()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ErrorGenerator</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = <span class="built_in">recover</span>()</span><br><span class="line">        <span class="comment">//[1]</span></span><br><span class="line">        <span class="keyword">if</span> temp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">&quot;Error detected!&quot;</span>)</span><br><span class="line">            <span class="built_in">println</span>(temp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//在匿名函数的声明之后加上括号可以直接执行它</span></span><br><span class="line">    <span class="comment">//但是defer关键字推迟了这个执行</span></span><br><span class="line">    <span class="keyword">var</span> i, j = <span class="number">114514</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> k = i / j  <span class="comment">//除以0的异常</span></span><br><span class="line">    <span class="built_in">println</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">Error detected!</span><br><span class="line">(0x1027d00,0x10c9f30)</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<div class="note default"><div style="color:dimgray;font-size:1.5em;"><strong>代码中的注释</strong></div>

<div style="color:dimgray;">[1]关于 <code>recover()</code> 函数的更多信息，请前往 <a class="btn" href="https://studygolang.com/pkgdoc ">Go语言标准库文档</a> 。</div>
</div>

<p>当然你也可以使用定义在 <code>errors</code> 包中的 <code>New()</code> 函数来自定义错误，并使用内建函数 <code>panic()</code> 来强制退出程序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ErrorGenerator(<span class="string">&quot;114514&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ErrorGenerator</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s != <span class="string">&quot;1919810&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errors.New(<span class="string">&quot;1919810呢？&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">panic: 1919810呢？</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.ErrorGenerator(...)</span><br><span class="line">        D:/Go/src/Golang/Hello/main/main.go:15</span><br><span class="line">main.main()</span><br><span class="line">        D:/Go/src/Golang/Hello/main/main.go:9 +0x49</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p><code>panic()</code> 函数会直接抛出错误并退出程序。在它之后的所有语句均不会执行。</p>
<h2 id="四、复杂类型"><a href="#四、复杂类型" class="headerlink" title="四、复杂类型"></a><strong>四、复杂类型</strong></h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="(1) 数组"></a><strong>(1) 数组</strong></h3><p>在Go中，数组是值类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i [<span class="number">3</span>]<span class="type">string</span>  <span class="comment">//声明一个长度为3的字符串数组</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">    fmt.Scanf(<span class="string">&quot;%s&quot;</span>, &amp;i[j])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">    <span class="built_in">println</span>(i[j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">Lacia Kouka Method</span><br><span class="line">Lacia</span><br><span class="line">Kouka</span><br><span class="line">Method</span><br></pre></td></tr></table></figure>

<p>以上述代码的方式定义的数组是定长的，不能改变其长度。<del>类型名后置，数组长度却前置，搞不懂开发者怎么想的。</del>未被初始化的数组，其中所有元素的值均为该类型的默认初始值。</p>
<p>如果想要初始化数组，可以使用 <code>[...]int&#123;索引:值,索引:值······&#125;</code> 的方式。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = [...]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;114514&quot;</span>, <span class="number">0</span>: <span class="string">&quot;1919810&quot;</span>, <span class="number">2</span>: <span class="string">&quot;1919&quot;</span>, <span class="number">1</span>: <span class="string">&quot;114&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(i); j++ &#123;</span><br><span class="line">    <span class="built_in">println</span>(i[j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">1919810</span><br><span class="line">114</span><br><span class="line">1919</span><br><span class="line">114514</span><br></pre></td></tr></table></figure>

<p>由于显式地声明了数组内的元素及其索引，因此不必再显式声明数组的元素个数了，数组的长度为最大索引值+1，未被显式声明的索引值所对应的元素将被初始化为默认初始值。当然也可以不声明元素的索引，默认是索引值递增排列。</p>
<p>遍历数组可以使用 <code>for range</code> 循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = [...]<span class="type">string</span>&#123;<span class="number">3</span>: <span class="string">&quot;114514&quot;</span>, <span class="number">0</span>: <span class="string">&quot;1919810&quot;</span>, <span class="number">2</span>: <span class="string">&quot;1919&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> j, k := <span class="keyword">range</span> i &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;j =&quot;</span>, j, <span class="string">&quot; k =&quot;</span>, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">j = 0  k = 1919810</span><br><span class="line">j = 1  k =</span><br><span class="line">j = 2  k = 1919</span><br><span class="line">j = 3  k = 114514</span><br></pre></td></tr></table></figure>

<p>不难看出， <code>range</code> 关键字会返回数组中的每个元素的索引和值。</p>
<p>与基本数据类型相似，指针也有数组，并且有指向数组的指针。由于过于简单，此处不做赘述。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>值类型の痛</strong></div>

<div style="color:goldenrod;">Go中的数组是值类型，这意味着数组在作为函数的参数进行传递的时候，传递的是值的拷贝而非地址。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>&#125;</span><br><span class="line">    Changer(i)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Changer</span><span class="params">(k [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    k[<span class="number">0</span>] = <span class="number">810</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:goldenrod;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">[114 514 1919]</span><br></pre></td></tr></table></figure>

<div style="color:goldenrod;">原数组的值并未被改变。另外需要注意，Go认为不同长度的数组变量不属于同一类型。</div>
</div>

<p>二位数组的声明规则与C&#x2F;C++相似。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i [<span class="number">2</span>][<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">[[0 0 0 0 0] [0 0 0 0 0]]</span><br></pre></td></tr></table></figure>

<p>关于多维数组，此处不再赘述。</p>
<h3 id="2-切片（slice）"><a href="#2-切片（slice）" class="headerlink" title="(2) 切片（slice）"></a><strong>(2) 切片（slice）</strong></h3><p>Go将长度可变的数组称为切片，切片是引用类型。它的声明与数组相似：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i []<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>和数组的声明很像，但是切片的 <code>[]</code> 内什么都没有，而数组必须写上数组长度，或使用 <code>[...]</code> 来省略初始化了的数组长度。你可以让切片指向已有的数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>&#125;</span><br><span class="line"><span class="keyword">var</span> j []<span class="type">int</span> = i[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment">//此处语法与Python相似，不做赘述。</span></span><br><span class="line">i[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">fmt.Println(j)</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">[514 0 810]</span><br></pre></td></tr></table></figure>

<p>可以看出切片是指向原数组而非创建了新的值。切片有点像C&#x2F;C++的指针，可以为其分配空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">i[<span class="number">4</span>] = <span class="number">114514</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">[0 0 0 0 114514]</span><br></pre></td></tr></table></figure>

<p><code>make()</code> 函数和 <code>new()</code> 函数相似。它的第一个参数为切片的类型，第二个参数为切片的长度，第三个参数可以忽略，它初始化切片的容量。也可以使用类似数组的初始化方式、可以使用 <code>for range</code> 来遍历，这里不做赘述。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>切片的长度与容量</strong></div>

<div style="color:royalblue;">切片的长度指的是切片中元素个数，而切片的容量则是为这个切片分配了能装多少个元素的内存。如果不断地向切片中添加数据，那么为它分配的内存总有有用完的时候，这时就需要再次为它分配更多的内存。因此在可能会频繁出现内存分配的情况下，不建议使用切片。你可以使用 <code>cap()</code> 函数来查看目前这个切片最多能存放几个元素。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;len(i) =&quot;</span>, <span class="built_in">len</span>(i))</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;cap(i) =&quot;</span>, <span class="built_in">cap</span>(i))</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">len(i) = 5</span><br><span class="line">cap(i) = 10</span><br></pre></td></tr></table></figure>
</div>

<p>使用 <code>append()</code> 函数，以在切片尾部增加元素。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">i = <span class="built_in">append</span>(i, <span class="number">114514</span>, <span class="number">1919810</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i = <span class="built_in">append</span>(i, i...)</span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">[0 0 114514 1919810]</span><br><span class="line">[0 0 114514 1919810 0 0 114514 1919810]</span><br></pre></td></tr></table></figure>

<p><code>append()</code> 函数是可变参数的函数，这意味着你可以在参数列表写上任意多的你想插入的元素，或想插入的切片。</p>
<p><code>copy()</code> 函数功能为将第二个参数的切片的元素全部拷贝给第一个参数的切片。它不是直接赋值指针，而是进行值的拷贝。</p>
<h3 id="3-map"><a href="#3-map" class="headerlink" title="(3) map"></a><strong>(3) <code>map</code></strong></h3><p>官方翻译好像是叫映射。Python里叫字典，C++里是 <code>map</code> 容器。Go的 <code>map</code> 是引用类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>   <span class="comment">//声明时未初始化</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">map</span>[<span class="type">string</span>](<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)   <span class="comment">//套娃</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">10</span>)   <span class="comment">//声明时分配空间</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">114</span>: <span class="string">&quot;114514&quot;</span>&#125;   <span class="comment">//声明时初始化并分配一定空间</span></span><br></pre></td></tr></table></figure>

<p><code>map</code> 型变量的声明如上。变量 <code>j</code> 的声明可以不加括号，此处只是为了方便理解。 <code>[]</code> 内的类型是键的类型， <code>]</code> 之后的类型是值的类型。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>键的类型</strong></div>

<div style="color:royalblue;"><code>map</code> 的键的类型必须是可以用 <code>==</code> 来判断是否相等的类型。因此 <code>map</code> 、切片、 <code>func</code> 等类型不能用作键的类型，但是可以作为值的类型。</div>
</div>

<p>按照如上第一、第二种方式创建的 <code>map</code> 型变量并没有被分配空间，它的值是 <code>nil</code> 。为 <code>map</code> 型变量分配空间，应当使用 <code>make</code> 函数。关于这个函数此处不再赘述。</p>
<div class="tabs" id="mapoperation"><ul class="nav-tabs"><li class="tab active"><a href="#mapoperation-1">增加/修改</a></li><li class="tab"><a href="#mapoperation-2">删除</a></li><li class="tab"><a href="#mapoperation-3">查找</a></li><li class="tab"><a href="#mapoperation-4">遍历</a></li></ul><div class="tab-content"><div class="tab-pane active" id="mapoperation-1"><p>与C++一样，Go的 <code>map</code> 型变量的增加&#x2F;修改操作非常简单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">i[<span class="string">&quot;Lacia&quot;</span>] = <span class="string">&quot;Type-005&quot;</span></span><br><span class="line">i[<span class="string">&quot;Kouka&quot;</span>] = <span class="string">&quot;Type-001&quot;</span></span><br><span class="line">i[<span class="string">&quot;Method&quot;</span>] = <span class="string">&quot;Type-004&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里虽然初始化的时候只为 <code>i</code> 分配了一个键值对的空间，但 <code>map</code> 型变量的空间会自动动态扩展。</p></div><div class="tab-pane" id="mapoperation-2"><p><code>delete()</code> 函数是内建函数，它可以删除 <code>map</code> 型变量中的键值对。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">(Map <span class="keyword">map</span>[Key]Value, key Key)</span></span></span><br></pre></td></tr></table></figure>

<p><code>Map</code> 为需要删除键值对的 <code>map</code> 型变量。如果不存在键 <code>key</code> 或者 <code>Map</code> 为 <code>nil</code> ，函数均不会报错，也不会执行任何操作。</p>
<p>Go中没有删除 <code>map</code> 型变量的所有键值对的函数。要想删除所有键值对，要么遍历并挨个删除，要么使用 <code>make()</code> 函数重新为变量分配空间，让原来的空间自动被垃圾回收器回收。</p></div><div class="tab-pane" id="mapoperation-3"><p>可以使用 <code>len()</code> 函数来统计 <code>map</code> 型变量有多少组键值对。想判断是否存在某个键值对，可以使用如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">j, Exist := i[<span class="number">5</span>]</span><br><span class="line"><span class="keyword">if</span> Exist &#123;</span><br><span class="line">    <span class="built_in">println</span>(j)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;None&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>map</code> 型变量对其它变量赋值的时候，它会返回两个值。第二个值可以忽略，它是 <code>bool</code> 型的值。如果存在键值对则返回 <code>true</code> ，否则返回 <code>false</code> 。可以使用这个额外返回的变量来查询是否存在键值对。</p></div><div class="tab-pane" id="mapoperation-4"><p>对 <code>map</code> 型变量的遍历只能使用 <code>for range</code> 循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">i[<span class="string">&quot;Lacia&quot;</span>] = <span class="string">&quot;Type-005&quot;</span></span><br><span class="line">i[<span class="string">&quot;Kouka&quot;</span>] = <span class="string">&quot;Type-001&quot;</span></span><br><span class="line">i[<span class="string">&quot;Method&quot;</span>] = <span class="string">&quot;Type-004&quot;</span></span><br><span class="line"><span class="keyword">for</span> Name, Type := <span class="keyword">range</span> i &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Name =&quot;</span>, Name, <span class="string">&quot;, Type =&quot;</span>, Type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">Name = Lacia , Type = Type-005</span><br><span class="line">Name = Kouka , Type = Type-001</span><br><span class="line">Name = Method , Type = Type-004</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>遍历顺序</strong></div>

<div style="color:goldenrod;">在Go中， <code>map</code> 的底层实现是哈希表。因此遍历时的遍历顺序是随机的，并不会按照你的添加顺序遍历。</div>
</div></div></div></div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Go基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础（二）</title>
    <url>/2022/02/11/GoGrammar02/</url>
    <content><![CDATA[<img src="/2022/02/11/GoGrammar02/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言（最好是C/C++/C#）的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="五、面向对象"><a href="#五、面向对象" class="headerlink" title="五、面向对象"></a><strong>五、面向对象</strong></h2><p>Go的面向对象很怪。在Go中，没有 <code>class</code> 只有 <code>struct</code> 、没有重载、没有构造函数与析构函数，很多面向对象的传统特性也没有，包括 <code>this</code> 指针。但Go的面向对象特性仍然很强大。</p>
<h3 id="1-声明与定义-struct"><a href="#1-声明与定义-struct" class="headerlink" title="(1) 声明与定义 struct"></a><strong>(1) 声明与定义 <code>struct</code></strong></h3><p><code>struct</code> 是值类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HIE <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>struct</code> 可以在函数内声明，但这样声明的 <code>struct</code> 的作用域仅限于这个函数内部。</p>
<p><code>struct</code> 可以像基本类型一样声明变量、指针、数组和切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i HIE = HIE&#123;<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-001&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="keyword">var</span> k *HIE</span><br><span class="line"><span class="keyword">var</span> j [<span class="number">5</span>]HIE</span><br><span class="line"><span class="keyword">var</span> m []HIE</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>结构体的指针</strong></div>

<div style="color:royalblue;">与一般变量一样，可以使用 <code>new()</code> 函数来为指针分配空间：</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> k *HIE = <span class="built_in">new</span>(HIE)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">也可以使用另一种方式：</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> k *HIE = &amp;HIE&#123;&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">第二种方式本质上是创建了一个没有变量名的变量，并将这个变量的地址赋值给指针。通过指针来获取成员变量时，可以不使用 <code>*</code> 运算符，因为编译器会帮你加上 <code>*</code> 运算符。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> k *HIE = <span class="built_in">new</span>(HIE)</span><br><span class="line">k.Age = <span class="number">114514</span></span><br><span class="line">(*k).Name = <span class="string">&quot;野兽先辈&quot;</span>   <span class="comment">//标准书写方式</span></span><br><span class="line">k.Type = <span class="string">&quot;INM&quot;</span></span><br><span class="line">fmt.Println(k)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">&amp;&#123;野兽先辈 INM 114514&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">这很有可能造成误解，因为不论是不是指针都可以直接使用 <code>.</code> 运算符来获取成员变量，尤其是在使用类型推断声明变量的时候。</div>
</div>

<p>即便成员变量的类型、名称完全一致，Go也会认为两个类型名不同的 <code>struct</code> 不属于同一类型，因此不能相互赋值，但可以使用显式类型转换。</p>
<h3 id="2-私有与公有"><a href="#2-私有与公有" class="headerlink" title="(2)  私有与公有"></a><strong>(2)  私有与公有</strong></h3><p>在Go中，没有 <code>private</code> 与 <code>public</code> 关键字，只能通过变量名&#x2F;函数名来判断访问权。首字母大写代表它可以被所有代码访问，而小写则代表仅有本包的代码能够访问它。</p>
<p>上面的规则不仅适用于函数与全局变量，还适用于 <code>struct</code> 和它的成员变量、成员函数。首字母为小写的 <code>struct</code> 类型不能用于其它包的变量声明。</p>
<h3 id="3-方法（成员函数）"><a href="#3-方法（成员函数）" class="headerlink" title="(3) 方法（成员函数）"></a><strong>(3) 方法（成员函数）</strong></h3><p>在Go中，方法的声明不能在 <code>struct</code> 内部，必须在其外部声明。<del>类型名后置已经够反人类了，方法的声明更反人类。</del></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HIE <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法的声明。首字母大写，代表它是所有包都能调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(temp HIE)</span></span> Hello() &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;I&#x27;m&quot;</span>, temp.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> Lacia = HIE&#123;<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line">    Lacia.Hello()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一种调用方式</span></span><br><span class="line">    i := Lacia.Hello</span><br><span class="line">    i()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">I&#x27;m Lacia</span><br><span class="line">I&#x27;m Lacia</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>为什么Go的方法反人类</strong></div>

<div style="color:goldenrod;">在绝大多数有面向对象的语言里，如果一个对象的方法会在其内部修改对象的成员变量值，那么这种修改将会被保留。而Go则不会，因为 <code>struct</code> 是值类型，作为参数传递时是值拷贝的。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(temp HIE)</span></span> Hello() &#123;</span><br><span class="line">    temp.Name = <span class="string">&quot;Kouka&quot;</span>   <span class="comment">//修改了成员变量</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;I&#x27;m&quot;</span>, temp.Name)   <span class="comment">//检查修改是否成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> Lacia = HIE&#123;<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line">    Lacia.Hello()</span><br><span class="line">    <span class="built_in">println</span>(Lacia.Name)   <span class="comment">//检查修改是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">I&#x27;m Kouka</span><br><span class="line">Lacia</span><br></pre></td></tr></table></figure>

<div style="color:goldenrod;">因为值拷贝的特性，使得通过调用方法来修改成员变量是不可能的，即便你使用指针来调用方法也一样。要想能够修改成员变量的值，声明方法的时候应该使用 <code>struct</code> 的指针作为类型：</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(temp *HIE)</span></span> Hello() &#123;  <span class="comment">//这里改成了指针</span></span><br><span class="line">    temp.Name = <span class="string">&quot;Kouka&quot;</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;I&#x27;m&quot;</span>, temp.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> Lacia = &amp;HIE&#123;<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line">    Lacia.Hello()</span><br><span class="line">    <span class="built_in">println</span>(Lacia.Name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:goldenrod;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">I&#x27;m Kouka</span><br><span class="line">Kouka</span><br></pre></td></tr></table></figure>
</div>

<p>应当注意，不论类型名&#x2F;变量名&#x2F;函数名是大写还是小写，只要是属于同一个包的代码，就有权访问它。这意味着没必要专门定义修改成员变量的函数。如果要粗略地形容的话，Go的包对应的是C++&#x2F;C#的类，包内的函数与全局变量相当于这个“类”的方法和成员变量。<del>但这依然没能改变Go让我很难受的现实。</del></p>
<p>Go的在类型外定义方法的特性，使得程序员能够为一些已经封装了的类型添加方法，例如内置的 <code>int</code> 、 <code>string</code> 类型等。另外，不同类型中的方法是允许同名的。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>String()</code> 方法</strong></div>

<div style="color:royalblue;">在使用<code>fmt</code> 包中定义的函数输出变量的值的时候，编译器会先尝试寻找这个变量的类型有没有定义 <code>String()</code> 方法。如果定义了则输出调用 <code>String()</code> 方法的值</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HIE <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(temp HIE)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;114514&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> Lacia = HIE&#123;<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line">    fmt.Println(Lacia)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">114514</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">而如果使用内建的<code>print()</code> 函数则不会有这种效果。</div>
</div>

<h3 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="(4) 工厂模式"></a><strong>(4) 工厂模式</strong></h3><p>在Go中没有构造函数，但是有工厂模式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hIE <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HIE</span><span class="params">(Name <span class="type">string</span>, Type <span class="type">string</span>, Age <span class="type">int</span>)</span></span> *hIE &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;hIE&#123;Name: Name, Type: Type, Age: Age&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> Lacia = HIE(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>, <span class="number">17</span>)</span><br><span class="line">    fmt.Println(Lacia)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">&amp;&#123;Lacia Type-005 17&#125;</span><br></pre></td></tr></table></figure>

<p>其实本质就是个函数，但不是成员函数。这也是为什么Go的面向对象更像是以包为单位而非以 <code>struct</code> 为单位的原因。</p>
<p>基于上述代码的原理，也可实现跨包对私有<code>struct</code> 中的私有成员变量的访问与修改。</p>
<h3 id="5-继承"><a href="#5-继承" class="headerlink" title="(5) 继承"></a><strong>(5) 继承</strong></h3><p>基本的语法很简单。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Proletarian <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human</span><br><span class="line">    Wage <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>Proletarian</code> 继承了 <code>Human</code> 。但实际上是在 <code>Proletarian</code> 中添加了一个 <code>Human</code> 类型的匿名变量，因此也可以使用匿名指针来实现继承。子类有权调用父类的方法与成员变量。要想调用父类的方法和成员变量，有如下方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RES Proletarian</span><br><span class="line">RES.Human.Age = <span class="number">17</span></span><br><span class="line">RES.Name = <span class="string">&quot;RES&quot;</span>   <span class="comment">//省略父类名称</span></span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>就近原则</strong></div>

<div style="color:royalblue;">与JavaScript类似，Go在寻找成员变量和方法的时候，会优先在本类中寻找。如果没找到，再访问父类的成员变量和方法。如果多个父类都有同名成员变量或者方法，则必须指定是哪个父类，否则编译将报错。</div>
</div>

<p>Go也允许继承基本数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Complex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span></span><br><span class="line">    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i Complex</span><br><span class="line">    i.<span class="type">int</span> = <span class="number">114514</span>   <span class="comment">//不需要指定成员变量</span></span><br><span class="line">    i.<span class="type">string</span> = <span class="string">&quot;1919810&quot;</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">&#123;114514 1919810&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-接口（-interface-）"><a href="#6-接口（-interface-）" class="headerlink" title="(6) 接口（ interface ）"></a><strong>(6) 接口（ <code>interface</code> ）</strong></h3><p>在Go中定义 <code>interface</code> 与定义 <code>struct</code> 非常相似。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Speak <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>interface</code> 中只能写函数，并且只能声明，不允许实现。当某个 <code>struct</code> 实现了某个 <code>interface</code> 中声明的<span style="color:red;">所有</span>函数时，这个 <code>struct</code> 就实现了这个 <code>interface</code> 。Go的 <code>interface</code> 功能上相当于C++&#x2F;C#的多态和函数模板。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Person类和HIE类</span></span><br><span class="line"><span class="keyword">type</span> HIE <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Type <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Speak接口</span></span><br><span class="line"><span class="keyword">type</span> Speak <span class="keyword">interface</span> &#123;</span><br><span class="line">    SelfIntroduce()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Person类的接口。请注意此处不能使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(temp Person)</span></span> SelfIntroduce() &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;I&#x27;m&quot;</span>, temp.Name, <span class="string">&quot;and&quot;</span>, temp.Age, <span class="string">&quot;years old&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现HIE类的接口。请注意此处不能使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(temp HIE)</span></span> SelfIntroduce() &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;I&#x27;m&quot;</span>, temp.Name, <span class="string">&quot;and&quot;</span>, temp.Type, <span class="string">&quot;HIE&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处参数类型指的是任意实现了Speak接口的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SI</span><span class="params">(temp Speak)</span></span> &#123;</span><br><span class="line">    temp.SelfIntroduce()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := Person&#123;<span class="string">&quot;RES&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line">    j := HIE&#123;<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不同类型的变量传入同一个函数</span></span><br><span class="line">    SI(i)</span><br><span class="line">    SI(j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">I&#x27;m RES and 17 years old</span><br><span class="line">I&#x27;m Lacia and Type-005 HIE</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>接口类型的变量</strong></div>

<div style="color:royalblue;">虽然在声明函数的时候，看起来像是在声明 <code>temp</code> 变量属于 <code>Speak</code> 类，但是实际的意思是任意实现了 <code>Speak</code> 接口的类型均可。Go允许使用接口创建变量与数组，但这种变量是引用类型的，只能指向实现了该接口的类型的变量，并且这种变量只能调用该接口内声明的函数。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> k Speak = i</span><br><span class="line">k.SelfIntroduce()   <span class="comment">//正常调用</span></span><br><span class="line">k.Name = <span class="string">&quot;Proletarian&quot;</span>   <span class="comment">//此处报错</span></span><br><span class="line"><span class="comment">//k.Name undefined (type Speak has no field or method Name)</span></span><br></pre></td></tr></table></figure>
</div>

<p>同样，接口之间也存在继承，其规则与 <code>struct</code> 一样。Go也允许空接口存在，空接口的变量能指向任意变量。</p>
<h3 id="7-类型断言"><a href="#7-类型断言" class="headerlink" title="(7) 类型断言"></a><strong>(7) 类型断言</strong></h3><p>当你让 <code>interface</code> 型变量指向其它变量后，这个 <code>interface</code> 型变量就只能调用 <code>interface</code> 声明的函数，因此存在很多限制。为了解除这种限制，就需要使用类型断言。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">string</span> = <span class="string">&quot;114514&quot;</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">interface</span>&#123;&#125; = i</span><br><span class="line"><span class="keyword">var</span> c = j   <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> c = j.(<span class="type">string</span>)   <span class="comment">//正常</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;c =&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<p>删除报错行以后的输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">c = 114514</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>类型断言的局限</strong></div>

<div style="color:goldenrod;">如果类型断言的类型不匹配，编译器并不会报错，但在执行时将会出现程序异常。使用类型断言时，会有两个返回值，第二个返回值可以忽略但不建议，因为它是一个 <code>bool</code> 型变量，转换成功则返回 <code>true</code> ，否则返回 <code>false</code> 。</div>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c, checker := j.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> checker &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Convert success.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Error detected!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<h2 id="六、文件流"><a href="#六、文件流" class="headerlink" title="六、文件流"></a><strong>六、文件流</strong></h2><p>Go中的文件流相关操作，全都封装到了 <code>os</code> 包中。</p>
<div class="tabs" id="filestream"><ul class="nav-tabs"><li class="tab active"><a href="#filestream-1"><code>Open()</code></a></li><li class="tab"><a href="#filestream-2"><code>Close()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="filestream-1"><p><code>Open()</code> 函数用于打开文件，其声明为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>如果读取错误则会返回 <code>nil</code> 和 错误类型。读取成功，返回的则是文件描述符&#x2F;文件句柄&#x2F;文件指针&#x2F;文件对象。叫法不一，看个人喜好。</p></div><div class="tab-pane" id="filestream-2"><p><code>Close()</code> 函数用于释放文件描述符，其声明为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Close() <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>如果关闭失败则会返回错误类型。</p></div></div></div>

<p><code>Reader</code> 是定义在 <code>bufio</code> 包中的一个 <code>struct</code> 。 <code>bufio</code> 包实现了带有缓冲区的读写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">temp, err := os.Open(<span class="string">&quot;input.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">file := bufio.NewReader(temp)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    Number, err := file.ReadString(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="built_in">println</span>(Number)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">114,</span><br><span class="line">514,</span><br><span class="line">1919,</span><br><span class="line">810</span><br></pre></td></tr></table></figure>

<p>其中， <code>bufio.NewReader()</code> 函数将文件句柄绑定到 <code>Reader</code> 上。 <code>Reader</code> 的缓冲区大小默认为4096字节，即4KB。 <code>ReadString()</code> 是 <code>Reader</code> 的方法，其功能为依次读取文件，直到读取到传入的字符（包含）或者文件结束符。读取到文件结束符将返回一个定义在 <code>io</code> 包内的 <code>EOF</code> 错误。</p>
<p>关于文件流，Go还定义了许多其他的函数，此处不再赘述，详情请参见 <a class="btn" href="https://studygolang.com/pkgdoc ">Go语言标准库文档</a></p>
<h2 id="七、协程"><a href="#七、协程" class="headerlink" title="七、协程"></a><strong>七、协程</strong></h2><p>由于多线程之间的切换开销相对较大，且线程占用内存相对较多，因此出现了协程。协程是非抢占式的，可以把协程看作是线程的细分，一个线程只能同时执行一个协程。但是如果当前协程由于I&#x2F;O等事件挂起，则会执行下一个协程。此处不对协程做更多赘述，按多线程方式大致理解即可。</p>
<p>Go的协程极其简单，在调用函数时加上 <code>go</code> 修饰符便可以多协程运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Async</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Async() &quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">        <span class="comment">//该函数功能为延时</span></span><br><span class="line">        <span class="comment">//不延时会导致时间片全被main()抢占</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> Async()  <span class="comment">//以协程方式运行Async()</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;main() &quot;</span>, i+<span class="number">1</span>)</span><br><span class="line">        time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">        <span class="comment">//该函数功能为延时</span></span><br><span class="line">        <span class="comment">//不延时会导致时间片全被Async()抢占</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">go run main.go</span></span><br><span class="line">main()  1</span><br><span class="line">Async()  1</span><br><span class="line">Async()  2</span><br><span class="line">main()  2</span><br><span class="line">main()  3</span><br><span class="line">Async()  3</span><br><span class="line">Async()  4</span><br><span class="line">main()  4</span><br><span class="line">main()  5</span><br><span class="line">Async()  5</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>main()</code> 与 <code>Async()</code> 交错执行，达到了类似于多线程的效果。但是与多线程不一样的是，执行 <code>main()</code> 的是主线程，而执行 <code>Async()</code> 的是协程。当主线程结束时，即使协程还未执行完毕，依然会结束协程。</p>
<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">基础知识就到此为止了。Go还有许多功能，例如图形化、高并发、反射等，这里不做叙述。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Go基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（一）</title>
    <url>/2022/03/02/JavaGrammar01/</url>
    <content><![CDATA[<img src="/2022/03/02/JavaGrammar01/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言（最好是C#或C++）的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p><del>屑</del>数据库实验要用Java，C#泛型委托高速它不香吗？（无奈）</p>
<p>本来没有学Java的打算，但是为了将来挣dollar嘛，不寒碜。总之Java是一门跨平台且永远向下兼容的语言。跨平台意味着它能被广泛运用，而向下兼容则是双刃剑——Python放弃了兼容旧版本，新版本简化设计轻装上阵，却招致了骂声一片；C++坚持兼容旧版本，甚至要兼容一部分C语言，导致积重难返，同样遭到诟病。是利是弊，全看程序员个人见解。</p>
<p>学过C++的同学能在Java中看见不少C++的影子，而学过C#的同学则可能会惊呼C#竟是Java++。<del>为什么不是惊呼Java是C#++？因为Java比C#早。</del></p>
<p>Java环境的安装很简单，百度搜JDK就完事了，此处不做赘述。</p>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a><strong>二、基础语法</strong></h2><h3 id="1-Hello-world"><a href="#1-Hello-world" class="headerlink" title="(1) Hello, world!"></a><strong>(1) Hello, world!</strong></h3><p>Java语言的文件后缀名为 <code>.java</code> 。新建一个 <code>.txt</code> 文件，修改后缀名后就可以直接开始些Java了。</p>
<p>与C#不同，Java不需要 <code>dotnet new console</code>、 <code>main()</code> 函数不需要首字母大写、包含主函数的类不需要放在命名空间中、输出至控制台不需要引用包或头文件。所以最经典的Hello, world!程序结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与C#一样，Java的主函数应当放在某个类中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该函数作用相当于printf()+换行或者Console.WriteLine()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>Java的类名与主函数的参数</strong></div>

<div style="color:goldenrod;">上述代码的类名，即 <code>class</code> 关键字之后的 <code>MainProgram</code> 这个名字，应当与你的 <code>.java</code> 文件的文件名一致，否则编译将会失败。</div>

<div style="color:goldenrod;">另外，Java的主函数必须要写上参数 <code>String[] args</code> ，也就是环境变量，不能像C++/C#一样省略。</div>
</div>

<p>编译Java文件，使用如下命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java</span></span><br></pre></td></tr></table></figure>

<p>编译完后当前目录将会生成一个 <code>.class</code> 文件。要执行该程序，应当使用如下命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java MainProgram</span></span><br></pre></td></tr></table></figure>

<p>不需要带后缀名。输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java MainProgram</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<h3 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="(2) 基本类型"></a><strong>(2) 基本类型</strong></h3><p>Java中的基本数据类型和C++&#x2F;C#几乎一致，主要有：</p>
<ul>
<li>数值型<ul>
<li><code>byte</code> ，占1个字节</li>
<li><code>short</code> ，占2个字节</li>
<li><code>int</code> ，占4个字节</li>
<li><code>long</code> ，占8个字节</li>
</ul>
</li>
<li>浮点型<ul>
<li><code>float</code> ，占4个字节</li>
<li><code>double</code> ，占8个字节</li>
</ul>
</li>
<li>字符型<ul>
<li><code>char</code> ，占<span style="color:red;">2</span>个字节</li>
</ul>
</li>
<li>布尔型<ul>
<li><code>boolean</code> ，占1个字节</li>
</ul>
</li>
</ul>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>Java中的 <code>char</code> </strong></div>

<div style="color:goldenrod;">与C#一样，Java的 <code>char</code> 类型占用2个字节，目的是为了兼容更多字符。你可以试试分别在C++和Java/C#中使用单个 <code>char</code> 来保存单个汉字。Java/C#能够成功保存，而C++不行。<del>果然C#是J++。</del></div>
</div>

<h3 id="3-类型转换"><a href="#3-类型转换" class="headerlink" title="(3) 类型转换"></a><strong>(3) 类型转换</strong></h3><p>Java中的类型转换基本与C++一致，有显式类型转换与隐式类型转换。在Java中，一般低精度转高精度、少字节数类型转多字节数类型可以使用隐式类型转换。但更推荐采用显式类型转换。</p>
<p>显式类型转换语法与C++一致，结构为 <code>(类型名)变量</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">114.5141919</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">float</span>) a;</span><br><span class="line">System.out.printf(<span class="string">&quot;a = %f\n&quot;</span>, a);</span><br><span class="line">System.out.printf(<span class="string">&quot;b = %f\n&quot;</span>, b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">a = 114.514192</span><br><span class="line">b = 114.514191</span><br></pre></td></tr></table></figure>

<p>上述代码也说明了Java中的浮点数同样存在精度缺陷。</p>
<h3 id="4-标准输入输出流"><a href="#4-标准输入输出流" class="headerlink" title="(4) 标准输入输出流"></a><strong>(4) 标准输入输出流</strong></h3><p>上文的代码中已经简单展示了Java的标准输出流。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">格式化字符串</th>
<th align="center">自带换行</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>System.out.println()</code></td>
<td align="center">不支持</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center"><code>System.out.print()</code></td>
<td align="center">不支持</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>System.out.printf()</code></td>
<td align="center">支持格式化字符串</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>虽然标准输出流和C#&#x2F;C++大同小异，但很遗憾，Java的标准输入流要比标准输出流更复杂。首先，为了使用标准输入流，需要引用 <code>java.util.Scanner</code> 包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>

<p>和Python一样，这句代码写在第一行。接下来的代码有C#基础的同学应该能直接理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">InputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> InputStream.next();</span><br><span class="line">InputStream.close();</span><br><span class="line">System.out.printf(<span class="string">&quot;temp = %s\n&quot;</span>, temp);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">1145141919810测试文字いいよ来いよ     &lt;===这是输入</span><br><span class="line">temp = 1145141919810测试文字いいよ来いよ</span><br></pre></td></tr></table></figure>

<p>只学过C++而没学过C#的同学可能会因 <code>new</code> 关键字而感到迷惑，但这里就先搁置。上述代码可以这么理解：将标准输入流 <code>System.in</code> 传入一个对象（也可以叫变量） <code>InputStream</code> 中。这个对象将会指向标准输入流。利用这个对象的类封装的函数，从标准输入流中读取输入。</p>
<p><code>Scanner</code> 类中大致有如下的函数可以用于读取：</p>
<ul>
<li><code>nextInt()</code> ，读取下一个 <code>int</code> 型变量能容纳的整型</li>
<li><code>next()</code> ，读取下一个字符串</li>
<li><code>nextLine()</code> ，读取下一行，返回值为 <code>String</code> 类型<br>······</li>
</ul>
<p>还有很多此类函数，从VS Code的自动补全插件中就能窥见不少。</p>
<p><img src="/2022/03/02/JavaGrammar01/1.png" alt="1 1" title="1"></p>
<p>这个函数的功能可以举一反三，从函数名直接看出，此处就不再赘述。</p>
<h3 id="5-控制流"><a href="#5-控制流" class="headerlink" title="(5) 控制流"></a><strong>(5) 控制流</strong></h3><h4 id="1-条件分支"><a href="#1-条件分支" class="headerlink" title="1. 条件分支"></a><strong>1. 条件分支</strong></h4><p>Java的 <code>if</code> 语句和C#&#x2F;C++一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">5</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;temp &lt; 5&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">10</span>)</span><br><span class="line">    System.out.println(<span class="string">&quot;temp &lt; 5&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    System.out.println(<span class="string">&quot;temp &gt;= 10&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">temp &gt;= 10</span><br></pre></td></tr></table></figure>

<p>关于 <code>if</code> 语句，此处不再赘述。</p>
<p><code>switch</code> 与C&#x2F;C++一致，此处也不做赘述。不过，在使用 <code>switch</code> 时要记得加 <code>break</code> 关键字。Java可不像Go一样只会执行第一个符合条件的 <code>case</code> ！</p>
<h4 id="2-循环控制"><a href="#2-循环控制" class="headerlink" title="2. 循环控制"></a><strong>2. 循环控制</strong></h4><p>Java的 <code>for</code> 循环、 <code>while</code> 循环语法与C&#x2F;C++一致，包括 <code>break</code> 与 <code>continue</code> 。此处就只做演示不做赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    System.out.printf(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;分割线&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    System.out.printf(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">i = 3</span><br><span class="line">分割线</span><br><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">i = 3</span><br></pre></td></tr></table></figure>

<h3 id="6-随机数"><a href="#6-随机数" class="headerlink" title="(6) 随机数"></a><strong>(6) 随机数</strong></h3><p>要产生随机数，得先引入 <code>java.util.Random</code> 包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>

<p><code>Random</code> 类的使用方法与 <code>Scanner</code> 类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">Generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.printf(<span class="string">&quot;Random integer = %d\n&quot;</span>, Generator.nextInt(<span class="number">114514</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">Random integer = 94072</span><br></pre></td></tr></table></figure>

<p>与 <code>Scanner</code> 类似， <code>Random</code> 也有 <code>nextFloat()</code> 之类的函数。但 <code>Random</code> 没有返回值为 <code>String</code> 类型的函数，毕竟这是个产生随机数的类。</p>
<h3 id="7-数组"><a href="#7-数组" class="headerlink" title="(7) 数组"></a><strong>(7) 数组</strong></h3><p>与C#一样，Java没有指针（准确地说，是极力避免使用指针，一般情况下不会用到指针）。因此，不能使用指针与 <code>new</code> 来动态创建数组。不过实际上Java和C#都很好地解决了动态创建数组的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] temp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">6</span>];</span><br><span class="line">temp[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">temp[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">temp[<span class="number">2</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">temp[<span class="number">3</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">temp[<span class="number">4</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">temp[<span class="number">5</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> i : temp) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">114514</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>Java的 <code>for in</code> 循环</strong></div>

<div style="color:royalblue;">与C#的 <code>foreach</code> 循环、Python的 <code>for in</code> 循环类似，但细节上有所差别。简而言之，就是上述代码中的 <code>for</code> 循环中定义了一个临时变量 <code>i</code> ，该变量依次会遍历可迭代变量 <code>temp</code> 中的每一个元素。当然，Java的数组也可以使用一般的 <code>for</code> 与 <code>while</code> 循环来遍历：</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<p>看到上述代码，各位同学应该也大致能理解为什么Java极力避免指针，并且有奇怪的 <code>new</code> 关键字用法——因为Java中很多类型都是“指针”，或者严格一点地讲，都是引用类型。在程序运行时，实际上保存在栈中的并不是变量的值，而是一个指向存放在堆中的变量真正值的地址。要粗暴一点理解的话，就是这玩意分明是个指针，但语法和编译器强制要求它不加 <code>*</code> 运算符。<del>但就是因为“删掉”了指针，导致堆中空间的释放只能依靠虚拟机维护的垃圾收集器，而垃圾收集器又做得不够好，所以你才会被诟病啊Java！</del></p>
<p>可以做一个简单实验来验证Java中变量的真面目是“指针”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] temp = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">6</span>];</span><br><span class="line">temp[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">temp[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">temp[<span class="number">2</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">temp[<span class="number">3</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">temp[<span class="number">4</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">temp[<span class="number">5</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] a = temp;</span><br><span class="line">a[<span class="number">2</span>] = <span class="string">&#x27;?&#x27;</span>;   <span class="comment">//修改数组a中的值，但不动temp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> i : temp) &#123;</span><br><span class="line">    System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.print(<span class="string">&quot;a 的地址 = &quot;</span>+ a + <span class="string">&quot; \n&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;temp 的地址 = &quot;</span>+ temp +<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">11?514</span><br><span class="line">a 的地址 = [C@13221655</span><br><span class="line">temp 的地址 = [C@13221655   &lt;===地址完全一致</span><br></pre></td></tr></table></figure>

<p>因此，在你定义数组时若还未确定数组长度，可以使用 <code>null</code> 来初始化数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Java语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（二）</title>
    <url>/2022/03/03/JavaGrammar02/</url>
    <content><![CDATA[<img src="/2022/03/03/JavaGrammar02/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言（最好是C#或C++）的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a><strong>三、面向对象</strong></h2><p>其实Java抛弃了面向过程，而只有面向对象——从 <code>main()</code> 函数放在类中就能看出。因此面向对象可以说是Java的核心知识。</p>
<p>首先要明确的是对象与类的的差异。对象在C++中被称为变量，也就是通过类所定义的变量；而类是程序员所定义的一种数据类型。Java中所有的类，都间接或直接地继承自 <code>Object</code> 类。</p>
<h3 id="1-方法（成员函数）"><a href="#1-方法（成员函数）" class="headerlink" title="(1) 方法（成员函数）"></a><strong>(1) 方法（成员函数）</strong></h3><p>方法其实就是C++中的成员函数。由于Java是纯面向对象的语言，它抛弃了传统意义上的“函数”，而是将所有的函数都写在类中，作为成员函数（或者称为方法）来使用。运行Java程序时，会默认以一个名为 <code>main()</code> 的方法为程序入口，从这个函数开始执行。这一点与C&#x2F;C++类似，只不过Java将主函数放在了类中而已。Java中方法的定义与C++定义成员函数类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法，返回值为String类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>与C++相似，Java的方法允许重载——即允许同一个类中方法名相同，但必须满足参数类型或个数不同。此处不再赘述。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>值传递与引用传递</strong></div>

<div style="color:royalblue;">在编写函数时，有时程序员希望，在函数中对参数的修改，在函数外也能保留。在C中，程序员可以使用指针；在C++中，程序员可以使用 <code>&</code> 运算符或指针；在C#中，程序员可以使用 <code>ref</code> 关键字；在Python中，程序员只能依赖可变类型或者多个返回值；而在Java中，程序员似乎只能依赖引用类型或将返回值打包。</div>

<div style="color:royalblue;">引用类型，即类似于数组这样的类型，它在栈中保存的值是地址而非真实值。在传递参数时，形参会拷贝实参保存在栈中的“值”，而对于引用类型，其“值”就是它在堆中的真实值的地址。学过计算机组成原理或操作系统的同学应该不难理解其底层原理。实际上Java只有值传递，但Java的类型分为了引用类型（指针）和值类型。</div>
</div>

<h3 id="2-定义类"><a href="#2-定义类" class="headerlink" title="(2) 定义类"></a><strong>(2) 定义类</strong></h3><p>语法上与C++大同小异，但Java规定一个文件只能存在一个 <code>public</code> 类，并且该类的名称必须与文件名（不带后缀名）一致。关于 <code>public</code> 与 <code>private</code> 属性，下文再详述。</p>
<p>新建一个文件，重命名为 <code>HIE.java</code> ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HIE.java的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> String Type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HIE</span><span class="params">(String name, String type)</span> &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SelfIntroduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;I&#x27;m %s and %s HIE.\n&quot;</span>, Name, Type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再切换至 <code>MainProgram.java</code> 文件，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainProgram.java的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用HIE类的构造函数来初始化Lacia变量</span></span><br><span class="line">        <span class="type">HIE</span> <span class="variable">Lacia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-001&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Lacia.SelfIntroduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">I&#x27;m Lacia and Type-001 HIE.</span><br></pre></td></tr></table></figure>

<p>上述的 <code>MainProgram.java</code> 文件与 <code>HIE.java</code> 文件需在同一文件夹下。编译 <code>MainProgram.java</code> 时，会连 <code>HIE.java</code> 也一起编译，生成两个 <code>.class</code> 文件。</p>
<p>需要注意的是：由用户定义的类，<span style="color:red;">均为引用类型</span>。</p>
<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="(3) 构造函数"></a><strong>(3) 构造函数</strong></h3><p>由于Java允许重载，使得书写多种构造函数成为可能。但请记住最好使用 <code>public</code> 来修饰构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HIE</span> <span class="variable">Lacia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-001&quot;</span>);</span><br><span class="line">        Lacia.SelfIntroduce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> &#123;   <span class="comment">// &lt;=====没有加修饰符</span></span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> String Type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，但是不加public</span></span><br><span class="line">    <span class="comment">// 运行是正常的，但不推荐</span></span><br><span class="line">    HIE(String name, String type) &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SelfIntroduce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s, %s\n&quot;</span>, Name, Type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-继承"><a href="#4-继承" class="headerlink" title="(4) 继承"></a><strong>(4) 继承</strong></h3><p>Java中不允许一个类继承多个类，但允许一个类继承有父类的类。继承需要使用 <code>extends</code> 关键字，语法结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span></span><br></pre></td></tr></table></figure>

<p>其中A为子类，B为父类。</p>
<h4 id="1-this-与-super"><a href="#1-this-与-super" class="headerlink" title="1. this 与 super"></a><strong>1. <code>this</code> 与 <code>super</code></strong></h4><p>在了解 <code>this</code> 与 <code>super</code> 关键字之前，应该先掌握Java寻找变量的顺序。在类的方法中，寻找变量的顺序如下：</p>
<pre class="mermaid">
graph TD

A(方法的局部变量) --&gt; |没有则寻找| B(子类成员变量)
B --&gt; |没有则寻找| C(父类成员变量)

</pre>

<p>如果父类中也没有，那么就会直接报错，不会再向父类的父类寻找。上述的寻找方式中存在两个问题：</p>
<ol>
<li>成员变量与方法内的局部变量同名</li>
<li>父类成员变量与子类成员变量同名</li>
</ol>
<p>解决上述问题可以分别使用 <code>this</code> 关键字和 <code>super</code> 关键字。</p>
<table>
<thead>
<tr>
<th align="center"><code>this</code></th>
<th align="center"><code>super</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">永远指向本类</td>
<td align="center">永远指向父类</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主程序的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lacia</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lacia</span>();</span><br><span class="line">        temp.Function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">Type</span> <span class="operator">=</span> <span class="string">&quot;HIE Type&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span> <span class="keyword">extends</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">Type</span> <span class="operator">=</span> <span class="string">&quot;Lacia Type&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">Type</span> <span class="operator">=</span> <span class="string">&quot;Function Type&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出局部变量的Type</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Type = &quot;</span> + Type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出本类的Type</span></span><br><span class="line">        System.out.println(<span class="string">&quot;this.Type = &quot;</span> + <span class="built_in">this</span>.Type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出父类的Type</span></span><br><span class="line">        System.out.println(<span class="string">&quot;super.Type = &quot;</span> + <span class="built_in">super</span>.Type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">Type = Function Type</span><br><span class="line">this.Type = Lacia Type</span><br><span class="line">super.Type = HIE Type</span><br></pre></td></tr></table></figure>

<p>同理， <code>this</code> 与 <code>super</code> 关键字也能用于方法，此处不再赘述。当子类重写父类方法时，应当在方法名的上一行声明 <code>@Override</code> ，以表示这个方法重写了父类方法。但其实不加，编译器也不会报错或警告。</p>
<h4 id="2-继承中的构造函数"><a href="#2-继承中的构造函数" class="headerlink" title="2. 继承中的构造函数"></a><strong>2. 继承中的构造函数</strong></h4><p>当子类创建对象时，如果不显式调用父类的构造函数，那么就会默认调用父类的无参构造函数。要显式调用父类构造函数，应当使用 <code>super()</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lacia</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lacia</span>(<span class="number">114514</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HIE</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HIE</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类接收参数 = &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span> <span class="keyword">extends</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lacia</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类带参构造函数</span></span><br><span class="line">        <span class="built_in">super</span>(a);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;子类接收参数 = &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac -encoding utf-8 MainProgram.java ; java MainProgram</span></span><br><span class="line">父类接收参数 = 114514</span><br><span class="line">子类接收参数 = 114514</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>Java的编码</strong></div>

<div style="color:royalblue;">Java国际化做得很好，Java的环境会自动检测你的系统语言与编码，在编译时将默认采用你的系统编码。而这就是问题所在——我的源代码采用UTF-8编码，而我的系统编码是GBK，这导致若源代码中含有中文，Java采用默认编译以后会出现乱码：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">鐖剁被鎺ユ敹鍙傛暟 = 114514</span><br><span class="line">瀛愮被鎺ユ敹鍙傛暟 = 114514</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;"><del>一时不知该吐槽VS Code还是Java还是微软。</del></div>
</div>

<h3 id="5-访问权限修饰符"><a href="#5-访问权限修饰符" class="headerlink" title="(5) 访问权限修饰符"></a><strong>(5) 访问权限修饰符</strong></h3><p>Java中允许不加修饰符，但这不代表没有修饰符的类 &#x2F; 成员变量 &#x2F; 方法没有限制访问权限。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><code>private</code></th>
<th align="center">不加修饰符</th>
<th align="center"><code>protected</code></th>
<th align="center">public</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本类</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">同包类 &#x2F; 同包子类</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">非同包子类</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">有</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">无关类</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">有</td>
</tr>
</tbody></table>
<p>简单来说， <code>private</code> 只允许本类访问； 默认（即不加修饰符）只允许同包类访问；<code>protected</code> 只允许同包或子类访问；<code>public</code> 则不限制访问权。</p>
<h3 id="6-状态修饰符"><a href="#6-状态修饰符" class="headerlink" title="(6) 状态修饰符"></a><strong>(6) 状态修饰符</strong></h3><h4 id="1-final"><a href="#1-final" class="headerlink" title="1. final"></a><strong>1. <code>final</code></strong></h4><p>被 <code>final</code> 关键字修饰的方法不允许被重写；被修饰的成员变量必须有初始值，且不允许值被修改；被修饰的类不允许被继承。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>final</code> 修饰局部变量</strong></div>

<div style="color:royalblue;"><code>final</code> 关键字也可以用于修饰方法内的局部变量。被修饰的局部变量不允许修改其在栈中的值。这就意味着，对于值类型而言它相当于常量，而对于值类型而言它相当于变成了常量的指针，即不允许修改指向的地址，但允许修改其指向的地址中的值。</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">114</span>;</span><br><span class="line">a = <span class="number">514</span>;   <span class="comment">// &lt;===此行报错：不允许被修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">temp.add(<span class="number">114514</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br><span class="line">temp.add(<span class="number">1919810</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br><span class="line"></span><br><span class="line">temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">// &lt;===此行报错：不允许被修改</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">去掉报错的代码后，输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">temp = [114514]</span><br><span class="line">temp = [114514, 1919810]</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">可以看到修改引用类型的值是可以的，但是不允许修改其指向的地址。</div>
</div>

<h4 id="2-static"><a href="#2-static" class="headerlink" title="2. static"></a><strong>2. <code>static</code></strong></h4><p>Java的 <code>static</code> 关键字与C#的 <code>static</code> 关键字差别较小。此处建议参考此博客的<a href="/2022/01/19/CsharpGrammar04/#3-非static类中的static成员">C#语法基础（四）</a>。</p>
<p>这里就从简说明，Java的 <code>static</code> 能修饰成员变量和方法，但不能修饰类，这一点和C#不同。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">有 <code>static</code></th>
<th align="center">无 <code>static</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过类访问</td>
<td align="center">可以</td>
<td align="center">不可以</td>
</tr>
<tr>
<td align="center">通过对象访问</td>
<td align="center">可以（不建议）</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="center">对象共享</td>
<td align="center">共享</td>
<td align="center">不共享</td>
</tr>
</tbody></table>
<p>下面的代码能帮助理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HIE</span> <span class="variable">Lacia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HIE</span>(), Kouka = <span class="keyword">new</span> <span class="title class_">HIE</span>();</span><br><span class="line">        Lacia.A = <span class="number">114</span>;</span><br><span class="line">        Kouka.A = <span class="number">514</span>;</span><br><span class="line">        Kouka.B = <span class="number">1919810</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Lacia:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;A = &quot;</span> + Lacia.A + <span class="string">&quot;, B = &quot;</span> + Lacia.B);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Kouka:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + Kouka.A + <span class="string">&quot;, B = &quot;</span> + Kouka.B);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;HIE.B = &quot;</span> + HIE.B);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">Lacia:</span><br><span class="line">A = 114, B = 1919810</span><br><span class="line">Kouka:</span><br><span class="line">a = 514, B = 1919810</span><br><span class="line">HIE.B = 1919810</span><br></pre></td></tr></table></figure>

<p>再次强调，不建议使用对象访问 <code>static</code> 的成员变量或方法。被 <code>static</code> 修饰的函数只能访问 <code>static</code> 的成员，不能访问非 <code>static</code> 成员。</p>
<h3 id="7-多态"><a href="#7-多态" class="headerlink" title="(7) 多态"></a><strong>(7) 多态</strong></h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h4><p>使用父类创建的子类对象，只能调用父类中已有的成员。但若方法被子类重写了，则会调用子类的方法。或许看代码更容易理解一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HIE</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lacia</span>();</span><br><span class="line">        temp.Test();</span><br><span class="line">        temp.Work();   <span class="comment">// &lt;=== 此行报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span> <span class="keyword">extends</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对父类不可见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;I&#x27;m Lacia.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类可调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        Work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对父类不可见</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Work.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删掉报错的代码后，输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">I&#x27;m Lacia.</span><br><span class="line">Work.</span><br></pre></td></tr></table></figure>

<p>可以看见，按上述方式声明的父类对象，虽然不能直接调用父类中不存在的成员，但是该成员依然存在，且方法被子类重写时，会调用子类的方法。</p>
<p>另外，子类对象与多态的父类对象可以互相显式类型转换。</p>
<h4 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2. 抽象"></a><strong>2. 抽象</strong></h4><p><code>abstract</code> 修饰符只能用于修饰类和方法。被修饰的类相当于C++的虚类；被修饰的方法相当于C++的纯虚函数。 <code>abstract</code> 方法只能存在于 <code>abstract</code> 类中。</p>
<p><code>abstract</code> 类不能创建对象，但它可以有构造函数、 <code>static</code> 成员和非 <code>abstract</code> 成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Function</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>abstract</code> 类一般会和多态特性搭配使用。</p>
<h4 id="3-接口"><a href="#3-接口" class="headerlink" title="3. 接口"></a><strong>3. 接口</strong></h4><p>接口的底层实现是 <code>abstract</code> 类。接口的声明方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HIEstandard</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Function</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java的接口中，所有成员变量均为 <code>public</code> 、 <code>static</code> 且 <code>final</code> 的；所有的方法均为  <code>public</code> 且 <code>abstract</code> 的，即便你没有显式声明这些修饰符。接口不允许有构造函数。</p>
<p>声明某个类实现了接口，需要使用 <code>implements</code> 关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> <span class="keyword">implements</span> <span class="title class_">HIEstandard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Function</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以声明它实现了多个接口，只需要在 <code>implements</code> 关键字后以 <code>,</code> 分隔实现的接口即可。</p>
<p>声明实现了接口的类，要么该类是 <code>abstract</code> 的，要么该类必须全部实现接口中声明的函数。</p>
<h3 id="8-内部类"><a href="#8-内部类" class="headerlink" title="(8) 内部类"></a><strong>(8) 内部类</strong></h3><p>Java可以在类中创建类。内部类可以访问外部类的所有成员，外部类也能访问内部内的所有成员（但是非 <code>static</code> 成员需要通过创建实例对象才能访问）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HIE</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HIE</span>();</span><br><span class="line">        temp.Test();</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Lacia</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Function</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Lacia</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lacia</span>();</span><br><span class="line">        temp.Function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>如果要想在无关类中直接创建内部类的对象，必须将内部类修改为 <code>public</code> ，并且使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HIE.<span class="type">Lacia</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HIE</span>().<span class="keyword">new</span> <span class="title class_">Lacia</span>();</span><br></pre></td></tr></table></figure>

<p><del>然而直接创建内部类对象属于是整花活没啥用的功能。</del>内部类也可以写在方法中，但是它只能在该方法中生效。内部类也可以是匿名的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名类，该类是HIE的子类</span></span><br><span class="line">        <span class="type">HIE</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HIE</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重写HIE类的Test()方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;   <span class="comment">// &lt;=== 不要忘记写分号</span></span><br><span class="line"></span><br><span class="line">        temp.Test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这种方式也可以，即用即扔</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HIE</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Alternative&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HIE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">Hello, world!</span><br><span class="line">Alternative</span><br></pre></td></tr></table></figure>

<h3 id="9-包的创建与引用"><a href="#9-包的创建与引用" class="headerlink" title="(9) 包的创建与引用"></a><strong>(9) 包的创建与引用</strong></h3><p>在Java中，你可以将 <code>.java</code> 文件归属到包中。先上一张图方便理解：</p>
<p><img src="/2022/03/03/JavaGrammar02/1.png" alt="1 1" title="1"></p>
<p><del>图片有点变形？因为我PS了一下 <code>Test</code> 文件夹下两个文件的位置。VS Code的缩进太少了，不好分辨在不在文件夹里。</del>上图中，<code>Java</code> 是工作目录； <code>Test</code> 是包名；<code>Hello</code> 是该包中的类名。</p>
<p>首先，在你的工作目录下创建一个文件夹，文件夹命名为包名。在该文件夹下创建一个 <code>.java</code> 文件，在该文件的第一行加上如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure>

<p><del>有点Go那味儿了。</del>当你需要引用这个包时，在你的工作目录下的 <code>.java</code> 文件开头加上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.类名;</span><br></pre></td></tr></table></figure>

<p>你可能会遇到报错，不过不必担心，因为你还没编译你的包。在你的包所处的目录下打开PowerShell &#x2F; cmd &#x2F; Windows Terminal，编译你的包。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac 类名.java;</span></span><br></pre></td></tr></table></figure>

<p>上述命令会在该文件夹下生成一个 <code>.class</code> 文件，然后你就能正常使用你的包了。这有点像 <code>.dll</code> 文件，需要先编译才能使用。</p>
<h3 id="10-杂项"><a href="#10-杂项" class="headerlink" title="(10) 杂项"></a><strong>(10) 杂项</strong></h3><p>隔壁C#是支持 <code>get</code> 和 <code>set</code> 关键字的，但Java要想在类外访问 <code>private</code> 的成员变量，只能通过 <code>getVal()</code> 和 <code>setVal()</code> 方法，也就是通过方法修改或返回 <code>private</code> 成员变量。学有余力的同学可以看看C#是如何处理这个问题的，详情请参见本站的 <a href="/2022/01/19/CsharpGrammar04/#6-属性">C#语法基础（四）</a> 。<del>但我估计大部分没接触过C#的同学会暴毙在接口和内部类部分，并没有什么余力（悲）。</del></p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Java语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（四）</title>
    <url>/2022/03/05/JavaGrammar04/</url>
    <content><![CDATA[<img src="/2022/03/05/JavaGrammar04/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言（最好是C#或C++）的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a><strong>六、泛型</strong></h2><p>本来泛型应该更早讲的，但本文默认读者是至少会C++的，所以就放到后面来讲。不要觉得泛型很难很晦涩，因为你已经完整地接触了Java的泛型了。有C++基础的人只需要一句话就能理解泛型——泛型类就是类模板。</p>
<p>与C++的类模板不同的是，Java的泛型只允许传入引用类型。这是因为Java的泛型底层是用向上向下转型和类型检查实现的。<del>隔壁C#真泛型用着多爽啊，Java你得给劲儿啊</del></p>
<h3 id="1-声明泛型类"><a href="#1-声明泛型类" class="headerlink" title="(1) 声明泛型类"></a><strong>(1) 声明泛型类</strong></h3><p>Java声明泛型类相比C++要简单一点，不需要使用 <code>template</code> 关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T Value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T Value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.Value = Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的类就是一个泛型类。</p>
<h3 id="2-声明泛型方法"><a href="#2-声明泛型方法" class="headerlink" title="(2) 声明泛型方法"></a><strong>(2) 声明泛型方法</strong></h3><p>下述代码在非泛型类中声明了一个泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">Trash</span><span class="params">(T temp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-声明泛型接口"><a href="#3-声明泛型接口" class="headerlink" title="(3) 声明泛型接口"></a><strong>(3) 声明泛型接口</strong></h3><p>下述代码声明了一个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Trash</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(T a)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-类型通配符"><a href="#4-类型通配符" class="headerlink" title="(4) 类型通配符"></a><strong>(4) 类型通配符</strong></h3><p><code>?</code> 关键字在泛型中代表任意的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;?&gt; temp = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>上述写法是成立的，并且可以在 <code>?</code> 关键字后面追加 <code>extends</code> 关键字或 <code>super</code> 关键字。<br>追加 <code>extends</code> 关键字时，表示位于此处的类型必须是某类或其子类；追加 <code>super</code> 关键字时，表示位于此处的类型必须是某类或其父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>&gt; a = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number类是Integer类的父类</span></span><br><span class="line">Collection&lt;? <span class="built_in">super</span> Integer&gt; b = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Number&gt;();</span><br></pre></td></tr></table></figure>

<p>其实重点不在 <code>?</code> 上，而在于可以使用  <code>extends</code> 关键字或 <code>super</code> 关键字限制类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; T <span class="title function_">Trash</span><span class="params">(T temp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的泛型方法限制了传入的类型必须为 <code>Number</code> 类型或其子类。请注意，接口的底层实现也是类，这意味着你可以用 <code>extends</code> 关键字来限制传入的类必须实现什么接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类型限制比较绕</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">Trash</span><span class="params">(T temp)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先别急着往下看，想想这是做了什么限制</span></span><br></pre></td></tr></table></figure>

<p>上面的类型限制为：类型 <code>T</code> 必须实现了能与其本身或父类作比较的接口。</p>
<h2 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a><strong>七、异常</strong></h2><p>Java将异常包装成了类，所有的异常类都直接或间接地继承自 <code>Throwable</code> 类。<code>Throwable</code> 类的子类有<code>Error</code> 类和 <code>Exception</code> 类。</p>
<pre class="mermaid">
graph TD

A(&lt;code&gt;Throwable&lt;&#x2F;code&gt; 类) --&gt;|派生| B(&lt;code&gt;Error&lt;&#x2F;code&gt; 类)
A --&gt;|派生| C(&lt;code&gt;Exception&lt;&#x2F;code&gt; 类)
C --&gt;|派生| D(运行时异常)
C --&gt;|派生| E(编译时异常)
D --&gt;|派生| F(数不清的异常类型)

</pre>

<p>其中，需要程序员专门编写代码来处理的是运行时异常。编译时异常是编译就通不过，程序员必须要修改错误代码，而运行时异常是一些非法输入（例如计算a÷b，输入的b等于0）或者意想不到的问题。</p>
<h3 id="1-Throwable-类的方法"><a href="#1-Throwable-类的方法" class="headerlink" title="(1) Throwable 类的方法"></a><strong>(1) <code>Throwable</code> 类的方法</strong></h3><p><code>Throwable</code> 类中定义了一些常用的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getMessage()</code></td>
<td align="center">无</td>
<td align="center">返回异常原因</td>
<td align="center"><code>String</code></td>
</tr>
<tr>
<td align="center"><code>toString()</code></td>
<td align="center">无</td>
<td align="center">转换为 <code>String</code> 类型</td>
<td align="center"><code>String</code></td>
</tr>
<tr>
<td align="center"><code>printStackTrace()</code></td>
<td align="center">无</td>
<td align="center">打印详细的异常信息</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>它们的输出信息略有差别：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">getMessage()：</span><br><span class="line">Index 3 out of bounds for length 3</span><br><span class="line"></span><br><span class="line">toString()：</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span><br><span class="line"></span><br><span class="line">printStackTrace()：</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span><br><span class="line">        at MainProgram.main(MainProgram.java:5)</span><br></pre></td></tr></table></figure>

<h3 id="2-try-catch"><a href="#2-try-catch" class="headerlink" title="(2) try catch"></a><strong>(2) <code>try catch</code></strong></h3><p>Java中也有 <code>try catch</code> 语句，它用于执行可能会出现异常的代码，并处理出现的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段代码将会引发异常：数组越界</span></span><br><span class="line">    System.out.println(a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生异常！&quot;</span>);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">发生异常！</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>上述的程序并没有在数组越界时中断执行，并且输出了相关的程序异常信息。根据异常信息，就可以进一步细化异常处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(a[<span class="number">3</span>]);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组越界，请检查索引&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生异常！&quot;</span>);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">数组越界，请检查索引</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>可以在 <code>catch</code> 块后追加 <code>finally</code> 关键字。不论异常是否发生，在处理完异常以后均会执行 <code>finally</code> 块中的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(a[<span class="number">3</span>]);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组越界，请检查索引&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生异常！&quot;</span>);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">数组越界，请检查索引</span><br><span class="line">114514</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<h3 id="3-throws-关键字"><a href="#3-throws-关键字" class="headerlink" title="(3) throws 关键字"></a><strong>(3) <code>throws</code> 关键字</strong></h3><p><code>throws</code> 关键字用于将异常抛出给调用这个方法的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 异常将在这里进行处理</span></span><br><span class="line">        Test();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组越界，请检查索引&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发生异常！&quot;</span>);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// throws关键字将异常扔给调用该方法的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这行代码将引发异常</span></span><br><span class="line">    System.out.println(a[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="(4) 自定义异常"></a><strong>(4) 自定义异常</strong></h3><p>自定义的异常类需要继承自 <code>Exception</code> 类或 <code>RuntimeException</code> 类，并且该类必须定义无参构造函数和一个带参构造函数，大致框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自RuntimeException类，也就是运行时异常类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(String a)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你想引发自定义异常时，使用如下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="string">&quot;报错信息&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>请注意区分 <code>throw</code> 和 <code>throws</code> 关键字的区别。 <code>throw</code> 关键字一定会抛出一个异常，且只能在方法内使用；而 <code>throws</code> 关键字需要写在方法名之后，且不一定真的会发生异常。</p>
<h2 id="八、文件流"><a href="#八、文件流" class="headerlink" title="八、文件流"></a><strong>八、文件流</strong></h2><p>文件流涉及的类较多，没必要全都记牢。当你需要理解内容，但不清楚继承关系时，再回来看下面的继承图吧。</p>
<p>首先是关于字节流的继承图。</p>
<pre class="mermaid">
graph TD

A(Object) --&gt;|派生| B(InputStream)
A --&gt;|派生| D(File)
A --&gt;|派生| C(OutputStream)
B --&gt;|派生| E(FileInputStream)
B --&gt;|派生| F(FilterInputStream)
C --&gt;|派生| G(FileOutputStream)
C --&gt;|派生| H(FilterOutputStream)
F --&gt;|派生| I(BufferedInputStream)
H --&gt;|派生| J(BufferedOutputStream)
H --&gt;|派生| L(PrintStream)

</pre>

<p>下图是关于字符流的继承图。</p>
<pre class="mermaid">
graph TD

A(Object) --&gt;|派生| L(Reader)
A --&gt;|派生| K(Writer)
L --&gt;|派生| N(InputStreamReader)
K --&gt;|派生| M(OutputStreamWriter)
N --&gt;|派生| O(FileReader)
M --&gt;|派生| P(FileWriter)
L --&gt;|派生| Q(BufferedReader)
K --&gt;|派生| R(BufferedWriter)
K --&gt;|派生| B(PrintWriter)

</pre>

<p>在使用文件流方法之前，应当引入 <code>java.io.IOException</code> 包，并在方法名后加上 <code>throws IOException</code> 关键字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 你的代码</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-File"><a href="#1-File" class="headerlink" title="(1) File"></a><strong>(1) <code>File</code></strong></h3><p>Java把文件的路径封装为了 <code>File</code> 类。该类定义在 <code>java.io.File</code> 包中。该类有三个常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File(String 路径 )</span><br><span class="line"></span><br><span class="line">File(String 父路径, String 子路径)</span><br><span class="line"></span><br><span class="line">File(File 父路径, String 子路径)</span><br></pre></td></tr></table></figure>

<p>在实例化对象时，父路径会和子路径进行拼接。该路径不一定需要指向一个实际存在的文件或目录。目录可以是相对路径，也可以是绝对路径。</p>
<h4 id="1-新建"><a href="#1-新建" class="headerlink" title="1. 新建"></a><strong>1. 新建</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>createNewFile()</code></td>
<td align="center">无</td>
<td align="center">创建新文件，存在则不创建</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>mkdir()</code></td>
<td align="center">无</td>
<td align="center">新建文件夹，若父文件夹不存在则不创建</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>mkdirs()</code></td>
<td align="center">无</td>
<td align="center">新建文件夹，若父文件夹不存在也一起新建</td>
<td align="center"><code>boolean</code></td>
</tr>
</tbody></table>
<h4 id="2-路径检查"><a href="#2-路径检查" class="headerlink" title="2. 路径检查"></a><strong>2. 路径检查</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>isDirectory()</code></td>
<td align="center">无</td>
<td align="center">检查路径是否为目录</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>isFile()</code></td>
<td align="center">无</td>
<td align="center">检查路径是否为文件</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>exists()</code></td>
<td align="center">无</td>
<td align="center">检查路径是否真实存在</td>
<td align="center"><code>boolean</code></td>
</tr>
</tbody></table>
<h4 id="3-路径获取"><a href="#3-路径获取" class="headerlink" title="3. 路径获取"></a><strong>3. 路径获取</strong></h4><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getAbsolutePath()</code></td>
<td align="center">无</td>
<td align="center">返回此路径的绝对路径</td>
<td align="center"><code>String</code></td>
</tr>
<tr>
<td align="center"><code>getPath()</code></td>
<td align="center">无</td>
<td align="center">返回封装的路径</td>
<td align="center"><code>String</code></td>
</tr>
<tr>
<td align="center"><code>getName()</code></td>
<td align="center">无</td>
<td align="center">返回指向的文件或文件夹名</td>
<td align="center"><code>String</code></td>
</tr>
<tr>
<td align="center"><code>list()</code></td>
<td align="center">无</td>
<td align="center">返回该文件夹下所有的文件与文件夹名</td>
<td align="center"><code>String[]</code></td>
</tr>
<tr>
<td align="center"><code>listFiles()</code></td>
<td align="center">无</td>
<td align="center">返回该文件夹下所有的文件与文件夹名</td>
<td align="center"><code>File[]</code></td>
</tr>
</tbody></table>
<h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a><strong>4. 删除</strong></h4><p>删除的常见方法就一个。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>delete</code></td>
<td align="center">无</td>
<td align="center">删除指向的文件或文件夹</td>
<td align="center"><code>boolean</code></td>
</tr>
</tbody></table>
<h3 id="2-字节流"><a href="#2-字节流" class="headerlink" title="(2) 字节流"></a><strong>(2) 字节流</strong></h3><p>字节流以字节为单位向文件中写入数据（即写入ASCII码而非字符本身）。与字节流相关的类有 <code>FileOutputStream</code> 类与 <code>FileInputStream</code> 类。</p>
<h4 id="1-FileOutputStream"><a href="#1-FileOutputStream" class="headerlink" title="1. FileOutputStream"></a><strong>1. <code>FileOutputStream</code></strong></h4><p><code>FileOutputStream</code> 定义在 <code>java.io.FileOutputStream</code> 包内。它有两个常用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream(String 路径, <span class="type">boolean</span> 追加)</span><br><span class="line"></span><br><span class="line">FileOutputStream(File 对象, <span class="type">boolean</span> 追加)</span><br></pre></td></tr></table></figure>

<p>如果不存在指定的文件，则会创建它。当传入的 <code>boolean</code> 值为 <code>true</code> 时，将不会清空已有文件中的内容，写入的内容将追加到文件末尾。该参数可以省略（用重载实现），默认为 <code>false</code> 。该类中有如下常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>int</code></td>
<td align="center">写入一个字符</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>byte[]</code></td>
<td align="center">将 <code>byte[]</code> 中的数据全部写入文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>byte[]</code> 、起始位置、写入长度</td>
<td align="center">从起始索引开始，将 <code>byte[]</code> 中的数据写入文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>close()</code></td>
<td align="center">无</td>
<td align="center">释放文件资源</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>其中，第2个方法搭配 <code>String</code> 类的 <code>getBytes()</code> 方法可以做到写入指定的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">temp.write(<span class="string">&quot;1145141919810&quot;</span>.getBytes());</span><br><span class="line">temp.close();</span><br></pre></td></tr></table></figure>

<p>上述代码将会在源代码的文件夹下创建一个名为 <code>test.txt</code> 的文件，并向其中写入文本“1145141919810”。</p>
<h4 id="2-FileInputStream"><a href="#2-FileInputStream" class="headerlink" title="2. FileInputStream"></a><strong>2. <code>FileInputStream</code></strong></h4><p><code>FileInputStream</code> 定义在 <code>java.io.FileInputStream</code> 包内。它有两个常用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream(String 路径)</span><br><span class="line"></span><br><span class="line">FileInputStream(File 对象)</span><br></pre></td></tr></table></figure>

<p>当指定的文件不存在时将引发异常。该类中有如下常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>read()</code></td>
<td align="center">无</td>
<td align="center">读取一个字节</td>
<td align="center"><code>int</code></td>
</tr>
<tr>
<td align="center"><code>read()</code></td>
<td align="center"><code>byte[]</code></td>
<td align="center">读取字符，最多读取 <code>byte[]</code> 的长度个字符</td>
<td align="center"><code>int</code> （读取的字节数）</td>
</tr>
<tr>
<td align="center"><code>read()</code></td>
<td align="center"><code>byte[]</code> 、起始位置、写入长度</td>
<td align="center">读取字符到起始位置处</td>
<td align="center"><code>int</code> （读取的字节数）</td>
</tr>
<tr>
<td align="center"><code>close()</code></td>
<td align="center">无</td>
<td align="center">释放文件资源</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>需要注意的是，当读取到文件结束符时将会返回-1。</p>
<h3 id="3-字节缓冲流"><a href="#3-字节缓冲流" class="headerlink" title="(3) 字节缓冲流"></a><strong>(3) 字节缓冲流</strong></h3><p>字节缓冲流采用了缓冲区，底层实现是 <code>byte[]</code> 数组，实际上是对字节流进行了包装。与字节流不同的是，字节流每次使用读取都会进行系统调用，而为此进行的上下文切换的开销是很大的。而带缓冲区的字节流，可以只用一次系统调用就将缓冲区内的数据全部处理完毕。对于大文件的处理，应当优先考虑字节缓冲流。</p>
<p>与字节缓冲流相关的类有 <code>BufferedOutputStream</code> 类与 <code>BufferedInputStream</code> 类。</p>
<h4 id="1-BufferedOutputStream"><a href="#1-BufferedOutputStream" class="headerlink" title="1. BufferedOutputStream"></a><strong>1. <code>BufferedOutputStream</code></strong></h4><p><code>BufferedOutputStream</code> 类定义在 <code>java.io.BufferedOutputStream</code> 包中。它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedOutputStream(OutputStream 对象, <span class="type">int</span> 缓冲区字节大小)</span><br></pre></td></tr></table></figure>

<p>其中，缓冲区大小可以省略，默认为8192字节； <code>OutputStream</code> 对象不一定非要是 <code>OutputStream</code> 类的对象，可以利用多态来传入 <code>FileOutputStream</code> 对象。该类的常用方法与 <code>FileOutputStream</code> 类一致，此处不再赘述。</p>
<h4 id="2-BufferedInputStream"><a href="#2-BufferedInputStream" class="headerlink" title="2. BufferedInputStream"></a><strong>2. <code>BufferedInputStream</code></strong></h4><p><code>BufferedInputStream</code> 类定义在 <code>java.io.BufferedInputStream</code> 包中。它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedInputStream(InputStream 对象, <span class="type">int</span> 缓冲区字节大小)</span><br></pre></td></tr></table></figure>

<p>其中，缓冲区大小可以省略，默认为8192字节； <code>InputStream</code> 对象不一定非要是 <code>InputStream</code> 类的对象，可以利用多态来传入 <code>FileInputStream</code> 对象。该类的常用方法与 <code>FileInputStream</code> 类一致，此处不再赘述。</p>
<h3 id="4-字节打印流"><a href="#4-字节打印流" class="headerlink" title="(4) 字节打印流"></a><strong>(4) 字节打印流</strong></h3><p>字节打印流的类为 <code>PrintStream</code> ，它只能用于输出。它的构造函数相对较多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream(String 路径, String 编码格式)</span><br><span class="line">PrintStream(File 对象, String 编码格式)</span><br><span class="line">PrintStream(OutputStream 对象, <span class="type">boolean</span> 自动刷新)</span><br></pre></td></tr></table></figure>

<p>其中，编码格式可以省略，默认将采用运行Java程序的平台采用的编码方式。常用的选项有 <code>"UTF-8"</code> 和 <code>"GBK"</code> 。关于自动刷新，详见下文的“流的刷新”。构造函数可以接受 <code>OutputStream</code> 对象，说明该类可以用于包装字节流。</p>
<p>该类不仅有字节流的常用方法，还有很熟悉的、与标准输流出一致的方法（因为它就是标准输出流的类，下文将进一步解释）：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">格式化字符串</th>
<th align="center">自动换行</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>println()</code></td>
<td align="center">不支持</td>
<td align="center">有</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>print()</code></td>
<td align="center">不支持</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>printf()</code></td>
<td align="center">支持格式化字符串</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>上述方法与打印到控制台的 <code>System.out.println()</code> 等标准输出流方法的功能完全一致，只不过标准输出流是输出到控制台，而上述方法是输出到文件。</p>
<h3 id="5-字符流"><a href="#5-字符流" class="headerlink" title="(5) 字符流"></a><strong>(5) 字符流</strong></h3><p>字符流是传输字符的，它不是直接写入ASCII码，而是将内容转换为ASCII码再写入（即底层实现还是字节流，<span style="color:red;">字符流类是字节流类的包装类</span>）。与字符流相关的类有 <code>OutputStreamWriter</code> 类与 <code>InputStreamReader</code> 类。</p>
<h4 id="1-OutputStreamWriter"><a href="#1-OutputStreamWriter" class="headerlink" title="1. OutputStreamWriter"></a><strong>1. <code>OutputStreamWriter</code></strong></h4><p><code>OutputStreamWriter</code> 类定义在 <code>java.io.OutputStreamWriter</code> 包内。它有一个常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter(OutputStream 对象, String 编码格式)</span><br></pre></td></tr></table></figure>

<p>该类中有如下常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>int</code></td>
<td align="center">写入一个字符</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>char[]</code></td>
<td align="center">将 <code>char[]</code> 中的数据写入文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>char[]</code> 、起始位置、写入长度</td>
<td align="center">从起始索引开始，将 <code>char[]</code> 中的数据写入文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>String</code></td>
<td align="center">将 <code>String</code> 中的数据写入文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>write()</code></td>
<td align="center"><code>String</code> 、起始位置、写入长度</td>
<td align="center">从起始索引开始，将 <code>String</code> 中的数据写入文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>flush()</code></td>
<td align="center">无</td>
<td align="center">刷新流（立即执行写入）</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>close()</code></td>
<td align="center">无</td>
<td align="center">释放文件资源</td>
<td align="center">无</td>
</tr>
</tbody></table>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>流的刷新</strong></div>

<div style="color:royalblue;"><code>OutputStreamWriter</code> 类其实也维护了一个缓冲区。所有的写入操作并不会立即得到执行，而是先写入缓冲区内，将字符转换为字节并等待写入。该类中有一个名为 <code>flush()</code> 的方法，可以刷新流（即立即执行写入）。当然你也可以不手动刷新流，因为 <code>close()</code> 方法会先刷新流再释放文件资源。</div>
</div>

<h4 id="2-InputStreamReader"><a href="#2-InputStreamReader" class="headerlink" title="2 InputStreamReader"></a><strong>2 <code>InputStreamReader</code></strong></h4><p><code>InputStreamReader</code> 类定义在 <code>java.io.InputStreamReader</code> 包内。它有一个常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader(InputStream 对象, String 编码格式)</span><br></pre></td></tr></table></figure>

<p>其中，编码格式可以省略。该类中有如下常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>read() </code></td>
<td align="center">无</td>
<td align="center">读取一个字符</td>
<td align="center"><code>int</code></td>
</tr>
<tr>
<td align="center"><code>read()</code></td>
<td align="center"><code>char[]</code></td>
<td align="center">读取一串字符，并返回读取的字符数</td>
<td align="center"><code>int</code></td>
</tr>
<tr>
<td align="center"><code>close()</code></td>
<td align="center">无</td>
<td align="center">释放文件资源</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h3 id="6-字符缓冲流"><a href="#6-字符缓冲流" class="headerlink" title="(6) 字符缓冲流"></a><strong>(6) 字符缓冲流</strong></h3><p>字符缓冲流采用了缓冲区，实际上是对字符流进行了包装，这使得它频繁读写的效率比字符流高。与字节缓冲流相关的类有 <code>BufferedWriter</code> 类与 <code>BufferedReader</code> 类。</p>
<h4 id="1-BufferedWriter"><a href="#1-BufferedWriter" class="headerlink" title="1. BufferedWriter"></a><strong>1. <code>BufferedWriter</code></strong></h4><p><code>BufferedWriter</code> 类定义在 <code>java.io.BufferedWriter</code> 包内。它有一个常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter(Writer 对象, <span class="type">int</span> 缓冲区大小)</span><br></pre></td></tr></table></figure>

<p>其中，缓冲区大小可以省略。由与字节流相关类都是继承自 <code>Writer</code> 类，因此大多数字节写入流相关类都可以用于初始化 <code>BufferedWriter</code> 类。该类的常用方法不仅包含了 <code>OutputStreamWriter</code> 类的常用方法，还有一个特有方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>newLine()</code></td>
<td align="center">无</td>
<td align="center">写入当前系统的换行符</td>
<td align="center">无</td>
</tr>
</tbody></table>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>换行符</strong></div>

<div style="color:royalblue;">在不同的操作系统中，换行符是不一样的。在Windows环境下换行符是 <code>\r\n</code> ，在Linux环境下是 <code>\n</code> ，在macOS环境下是 <code>\r</code> 。</div>
</div>

<h4 id="1-BufferedReader"><a href="#1-BufferedReader" class="headerlink" title="1. BufferedReader"></a><strong>1. <code>BufferedReader</code></strong></h4><p><code>BufferedReader</code> 类定义在 <code>java.io.BufferedReader</code> 包内。它有一个常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader(Reader 对象, <span class="type">int</span> 缓冲区大小)</span><br></pre></td></tr></table></figure>

<p>其中，缓冲区大小可以省略。由与字节流相关类都是继承自 <code>Reader</code> 类，因此大多数字节读取流相关类都可以用于初始化 <code>BufferedReader</code> 类。该类的常用方法不仅包含了 <code>InputStreamReader</code> 类的常用方法，还有一个特有方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>readLine()</code></td>
<td align="center">无</td>
<td align="center">读取一行字符串</td>
<td align="center"><code>String</code></td>
</tr>
</tbody></table>
<h3 id="7-字符打印流"><a href="#7-字符打印流" class="headerlink" title="(7) 字符打印流"></a><strong>(7) 字符打印流</strong></h3><p>字节打印流的类为 <code>PrintWriter</code> ，与字节打印流相似，字符打印流也只能用于输出。由于其隶属于字符流，因此当该类的输出方法也不会立即执行，需要刷新流。</p>
<p>该类的常用方法与 <code>PrintStream</code> 基本一致（但没有自动刷新的参数），此处不再赘述。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>字符打印流与字节打印流的区别</strong></div>

<div style="color:royalblue;">在实际使用中，感觉上二者并没有差别，但二者的底层实现不一样。首先来看字符打印流 <code>PrintWriter</code> 类的源码片段：</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接传入文件路径的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this代表该类，因此此处会跳转到另一个构造函数</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(  <span class="comment">// 字符缓冲流</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(  <span class="comment">//字符流</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName)</span><br><span class="line">            )</span><br><span class="line">        ), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正发挥作用的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(Writer out, <span class="type">boolean</span> autoFlush)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(out);</span><br><span class="line">    <span class="built_in">this</span>.out = out;</span><br><span class="line">    <span class="built_in">this</span>.autoFlush = autoFlush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">可以看到 <code>PrintWriter</code> 类实际上是层层包装了其它类，最终实际上是直接包装了字符缓冲流，这意味着它维护了一个缓冲区。接下来看字节打印流 <code>PrintStream</code> 的源代码片段：</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接传入文件路径的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正发挥作用的构造函数，它是private的</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">PrintStream</span><span class="params">(<span class="type">boolean</span> autoFlush, OutputStream out)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(out);</span><br><span class="line">    <span class="built_in">this</span>.autoFlush = autoFlush;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于输出字符</span></span><br><span class="line">    <span class="built_in">this</span>.charOut = <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于输出文本（字符串）</span></span><br><span class="line">    <span class="built_in">this</span>.textOut = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(charOut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">可以看到 <code>PrintStream</code> 类也维护了一个缓冲区，但它还有一个没有使用缓冲区的字符流，无缓冲区字符流用于输出字符，而带缓冲区字符流是用于输出字符串的。实际上字节打印流的底层实现还是字符流。</div>
</div>

<h2 id="九、再探标准流"><a href="#九、再探标准流" class="headerlink" title="九、再探标准流"></a><strong>九、再探标准流</strong></h2><p>之前曾经提到过Java的标准输入输出流，以及如何打印到控制台和从控制台读取输入。在有了文件流的基础以后，进一步理解标准流就不是那么困难了。</p>
<p>在 <code>System</code> 类中，有两个 <code>static</code> 成员变量 <code>in</code> 和 <code>out</code> 。前者为 <code>InputStream</code> 类型，代表标准输入流；后者是 <code>PrintStream</code> 类型，代表标准输出流。</p>
<h3 id="1-标准输入流"><a href="#1-标准输入流" class="headerlink" title="(1) 标准输入流"></a><strong>(1) 标准输入流</strong></h3><p>利用文件流中提到的类，可以将标准输入流打包为一个字符缓冲流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">cout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br></pre></td></tr></table></figure>

<p>这里再次整理一下各个类的关系（因为我都有点混乱）： <code>System.in</code> 是一个 <code>InputStream</code> 类型的对象，属于字节流，因此可以用隶属于字节流的 <code>InputStreamReader</code> 类型对象包装它；而字节流又可以被字节缓冲流包装。因此上述代码就是将标准输入流包装为字符缓冲流的过程。</p>
<p>但是并不推荐自己包装标准输入流，因为Java已经提供了一个包装类—— <code>Scanner</code> 类。当然，也可以直接使用 <code>InputStream</code> 内置的 <code>read()</code> 方法进行读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] Input = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">Length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读取的字节数</span></span><br><span class="line">    Length = System.in.read(Input);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException Error) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;共输入 %d 个字节\n&quot;</span>, Length);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Length; i++) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>) Input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">114514 | 义已逝，吾亦死 | いいよ、来いよ</span><br><span class="line">共输入 42 个字节</span><br><span class="line">114514 | ?￥???????￡?￠?? | ??????????????</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>字符与字符串</strong></div>

<div style="color:royalblue;">使用 <code>read()</code> 方法读取的数据为 <code>byte[]</code> 类型。即整型数组。直接输出会输出为ASCII码，而采用显式类型转换为 <code>char</code> 类型虽然能正确输出英文与数字，但其他语言则由于占据至少2个字符而不支持。要想能打印汉字，得把 <code>byte[]</code> 数组转换为 <code>String</code> 类型，并设置编码方式为 <code>"GBK"</code> 。</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用String类型的构造函数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">Output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Input, <span class="number">0</span>, Length, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;共输入 %d 个字节\n&quot;</span>, Output.length());</span><br><span class="line">System.out.println(<span class="string">&quot;Output = &quot;</span> + Output);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">114514 | 义已逝，吾亦死 | いいよ、来いよ</span><br><span class="line">共输入 28 个字符</span><br><span class="line">Output = 114514 | 义已逝，吾亦死 | いいよ、来いよ</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">请注意，<code>read()</code> 方法会读取换行符，而输出的时候又加了一个换行符，因此会出现一个空行。</div>
</div>

<h3 id="2-标准输出流"><a href="#2-标准输出流" class="headerlink" title="(2) 标准输出流"></a><strong>(2) 标准输出流</strong></h3><p>标准输出流的类和标准输入流的类不是“兄弟类”（Java似乎并没有兄弟类的概念，此处兄弟类是指父类是同一个类的类）。标准输出流 <code>System.in</code> 的类型是 <code>PrintStream</code> ，回顾如下的继承图：</p>
<pre class="mermaid">
graph TD

A(Object) --&gt;|派生| B(InputStream)
A --&gt;|派生| C(OutputStream)
C --&gt;|派生| D(FilterOutputStream)
D --&gt;|派生| E(PrintStream)

</pre>

<p><code>PrintStream</code> 类就是上文讲到的字节打印流的类。可以抽象理解成Java把控制台也看做是一种文件，对其进行打印输出。这也是为什么 <code>System.out</code> 可以直接使用 <code>printf()</code> 而 <code>System.in</code> 却没有 <code>scanf()</code> ，因为前者已经包装完毕了而后者还未包装。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Java语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（三）</title>
    <url>/2022/03/04/JavaGrammar03/</url>
    <content><![CDATA[<img src="/2022/03/04/JavaGrammar03/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言（最好是C#或C++）的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="四、一些常见类"><a href="#四、一些常见类" class="headerlink" title="四、一些常见类"></a><strong>四、一些常见类</strong></h2><p>一些Java库中的类不允许创建对象，但它又是非 <code>abstract</code> 的。其底层原理是用 <code>private</code> 关键字修饰了无参构造函数，并且没有定义有参构造函数。使用 <code>private</code> 关键字修饰构造函数，意味着其它类无权访问构造函数，因此也就不能创建对象。</p>
<h3 id="1-String"><a href="#1-String" class="headerlink" title="(1) String"></a><strong>(1) <code>String</code></strong></h3><h4 id="1-底层实现"><a href="#1-底层实现" class="headerlink" title="1. 底层实现"></a><strong>1. 底层实现</strong></h4><p><code>String</code> 类型的底层是用 <code>byte[]</code> 数组实现的。字符串类型的值一旦被赋值后就不能对其进行修改，但可以重新赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line">temp = <span class="string">&quot;1919810&quot;</span>;</span><br><span class="line">temp[<span class="number">1</span>] = <span class="string">&#x27;4&#x27;</span>;   <span class="comment">// 这一行会报错</span></span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br></pre></td></tr></table></figure>

<p>删掉报错的行以后输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">temp = 1919810</span><br></pre></td></tr></table></figure>

<h4 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a><strong>2. 构造函数</strong></h4><p><code>String</code> 有三个常用构造函数：</p>
<ul>
<li><code>String()</code> ，创建空字符串</li>
<li><code>String(char[])</code> ，字符数组转字符串</li>
<li><code>String(byte[])</code> ， <code>byte[]</code> 数组转字符串</li>
</ul>
<h4 id="3-字符串的比较"><a href="#3-字符串的比较" class="headerlink" title="3. 字符串的比较"></a><strong>3. 字符串的比较</strong></h4><p>上文已经阐述了在Java中变量分为引用类型和值类型。当使用 <code>==</code> 运算符判断两个变量是否相等时，会判断这个变量在栈中的值是否相等。这意味着，对于引用类型的变量，它判断的不是真实值是否一致，而是判断它们是否指向同一地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;a == b is &quot;</span> + (a == b));</span><br><span class="line">System.out.println(<span class="string">&quot;a == c is &quot;</span> + (a == c));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">a = 114514</span><br><span class="line">b = 114514</span><br><span class="line">c = 114514</span><br><span class="line">a == b is true</span><br><span class="line">a == c is false</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>Java中的字符串常量</strong></div>

<div style="color:royalblue;">对于上述代码中的 <code>"114514"</code> 这种直接书写的字符串，一般称之为字符串常量。在Java中，所有用相同字符串常量赋值的 <code>String</code> 型变量都会指向同一个地址，这个地址就是该字符串的首地址。</div>
</div>

<p>上述代码证明了在Java中对于像 <code>String</code> 这样的引用类型，不能使用 <code>==</code> 来作比较。所以Java的 <code>String</code> 类中有一个 <code>equals()</code> 方法，它可以用于检测两个字符串是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4&#x27;</span> &#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;a.equals(b) is &quot;</span> + a.equals(b));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">a.equals(b) is true</span><br></pre></td></tr></table></figure>

<h4 id="4-索引"><a href="#4-索引" class="headerlink" title="4. 索引"></a><strong>4. 索引</strong></h4><p>Java中的 <code>String</code> 不能使用形如 <code>str[i]</code> 的方式来获取第i个字符。<del>C++人和C#人极度不适。</del>作为补偿，<code>String</code> 类中有一个 <code>charAt()</code> 方法用于获取第i个字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a.charAt(3) is &quot;</span> + a.charAt(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">a.charAt(3) is 5</span><br></pre></td></tr></table></figure>

<p>该方法搭配 <code>String</code> 类中的 <code>length()</code> 方法（用于获取该字符串的长度），即可实现遍历字符串中的每一个字符。</p>
<p>Java的 <code>String</code> 也支持使用 <code>+</code> 运算符进行拼接。但请注意该拼接的底层实现并不是运算符重载（Java不支持运算符重载），而是一个语法糖。关于 <code>String</code> 类的更多方法，详情请参见 <a class="btn" href="https://www.runoob.com/java/java-string.html ">菜鸟教程</a> 。</p>
<h3 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="(2) StringBuilder"></a><strong>(2) <code>StringBuilder</code></strong></h3><p><code>StringBuilder</code> 类为可变字符串类型。 <code>String</code> 类型不可被更改，因此在进行拼接时会使用新的内存地址，将拼接后的值放在新的地址中并让变量指向该地址。而 <code>StringBuilder</code> 类则会保持变量指向的地址不变。</p>
<div class="tabs" id="stringbuilder"><ul class="nav-tabs"><li class="tab active"><a href="#stringbuilder-1">构造函数</a></li><li class="tab"><a href="#stringbuilder-2"><code>append()</code></a></li><li class="tab"><a href="#stringbuilder-3"><code>reverse()</code></a></li><li class="tab"><a href="#stringbuilder-4"><code>String</code> 与 <code>StringBuilder</code> 互转</a></li></ul><div class="tab-content"><div class="tab-pane active" id="stringbuilder-1"><p><code>StringBuilder</code> 的常用构造函数有以下两个：</p>
<ul>
<li><code>StringBuilder()</code> ，创建空的 <code>StringBuilder</code> 变量。</li>
<li><code>StringBuilder(String)</code> ，以 <code>String</code> 类型的变量初始化 <code>StringBuilder</code> 变量。</li>
</ul></div><div class="tab-pane" id="stringbuilder-2"><p><code>append()</code> 方法为 <code>StringBuilder</code> 类中的方法。该方法的功能为拼接字符串，并且返回变量本身。学过数据结构的同学应该察觉到了 <code>StringBuilder</code> 底层应该是用一个类似于C++的STL容器来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line"></span><br><span class="line">temp.append(<span class="string">&quot;19&quot;</span>).append(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;9&#x27;</span> &#125;);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">a</span> <span class="operator">=</span> temp.append(<span class="number">810</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br><span class="line">System.out.println(<span class="string">&quot;a == temp is &quot;</span> + (a == temp));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">a = 1145141919810</span><br><span class="line">temp = 1145141919810</span><br><span class="line">a == temp is true</span><br></pre></td></tr></table></figure>

<p>很明显， <code>append()</code> 方法会修改原对象，并且返回的对象与原对象指向了同一地址。</p></div><div class="tab-pane" id="stringbuilder-3"><p><code>reverse()</code> 方法为 <code>StringBuilder</code> 类中的方法，其功能为反转字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line">temp.reverse();</span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br></pre></td></tr></table></figure>

<p>输出结果为;</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">temp = 415411</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="stringbuilder-4"><p><code>String</code> 类型转换为 <code>StringBuilder</code> 类型可以直接使用 <code>StringBuilder</code> 类的构造函数。而 <code>StringBuilder</code> 类型转换为 <code>String</code> 类型，则可以使用 <code>toString()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;114514&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> temp.toString();</span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">a = 114514</span><br></pre></td></tr></table></figure></div></div></div>

<p>关于更多 <code>StringBuilder</code> 类的方法，请参见 <a class="btn" href="https://www.runoob.com/java/java-stringbuffer.html ">菜鸟教程</a> 。</p>
<h3 id="3-Math"><a href="#3-Math" class="headerlink" title="(3) Math"></a><strong>(3) <code>Math</code></strong></h3><p><code>Math</code> 类中定义了很多常用的数学运算方法，这些方法都是 <code>static</code> 的，因此不需要用 <code>Math</code> 类创建实例对象也可以调用。这里只例举一些常见的：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>abs()</code></td>
<td align="center">整型或浮点型</td>
<td align="center">返回绝对值</td>
<td align="center"><code>int</code> 、 <code>long</code> 或浮点型</td>
</tr>
<tr>
<td align="center"><code>ceil()</code></td>
<td align="center">浮点型</td>
<td align="center">向上取整</td>
<td align="center"><code>double</code></td>
</tr>
<tr>
<td align="center"><code>floor()</code></td>
<td align="center">浮点型</td>
<td align="center">向下取整</td>
<td align="center"><code>double</code></td>
</tr>
<tr>
<td align="center"><code>round()</code></td>
<td align="center">浮点型</td>
<td align="center">四舍五入取整</td>
<td align="center"><code>int</code> 或 <code>long</code></td>
</tr>
<tr>
<td align="center"><code>min()</code></td>
<td align="center">2个类型相同的整型或浮点型</td>
<td align="center">返回最小值</td>
<td align="center"><code>int</code> 、 <code>long</code> 或浮点型</td>
</tr>
<tr>
<td align="center"><code>max()</code></td>
<td align="center">2个类型相同的整型或浮点型</td>
<td align="center">返回最大值</td>
<td align="center"><code>int</code> 、 <code>long</code> 或浮点型</td>
</tr>
<tr>
<td align="center"><code>pow()</code></td>
<td align="center">2个 <code>double</code> 类型</td>
<td align="center">次方运算</td>
<td align="center"><code>double</code></td>
</tr>
<tr>
<td align="center"><code>random()</code></td>
<td align="center">无</td>
<td align="center">返回∈ [0,1) 的随机数</td>
<td align="center"><code>double</code></td>
</tr>
</tbody></table>
<p>关于更多 <code>Math</code> 类方法，请参见 <a class="btn" href="https://www.runoob.com/java/java-number.html ">菜鸟教程</a> 。</p>
<h3 id="4-System"><a href="#4-System" class="headerlink" title="(4) System"></a><strong>(4) <code>System</code></strong></h3><p><code>System</code> 类之前在讲标准输入输出流的时候就已经接触过了。与 <code>Math</code> 类一样，该类的成员都是 <code>static</code> 的。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exit()</code></td>
<td align="center"><code>int</code></td>
<td align="center">结束线程，非0参数表示异常</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>currentTimeMillis()</code></td>
<td align="center">无</td>
<td align="center">返回当前系统时间（毫秒）</td>
<td align="center"><code>long</code></td>
</tr>
</tbody></table>
<p><code>System</code> 中还有如下 <code>static</code> 的成员变量：</p>
<table>
<thead>
<tr>
<th align="center">成员变量名</th>
<th align="center">类型</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>err</code></td>
<td align="center"><code>PrintStream</code></td>
<td align="center">标准错误流</td>
</tr>
<tr>
<td align="center"><code>in</code></td>
<td align="center"><code>InputStream</code></td>
<td align="center">标准输入流</td>
</tr>
<tr>
<td align="center"><code>out</code></td>
<td align="center"><code>PrintStream</code></td>
<td align="center">标准输出流</td>
</tr>
</tbody></table>
<p>Java中的 <code>PrintStream</code> 类里有可以直接向控制台输出的方法，而 <code>InputStream</code> 类中虽然有直接读取输入的方法，但是不好用且可能会造成缓冲区溢出，在使用它们之前必须使用 <code>throws IOException</code> 关键字。因此还是建议使用 <code>Scanner</code> 类。</p>
<h3 id="5-Object"><a href="#5-Object" class="headerlink" title="(5) Object"></a><strong>(5) <code>Object</code></strong></h3><p><code>Object</code> 是<del>万物起源</del>所有类的直接或间接的父类。它有两个常用的非 <code>static</code> 的方法。说这两个方法“常用”并不是代表程序员经常要用 <code>Object</code> 类下的这两个方法，而是经常要重写或者调用重写后的这两个方法。</p>
<h4 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString()"></a><strong>1. <code>toString()</code></strong></h4><p>定义在 <code>Object</code> 类下的 <code>toString()</code> 方法并不是 <code>abstract</code> 的。程序员可以通过重写 <code>toString()</code> 方法来自定义该类的输出行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">114514</span><br><span class="line">B@1f32e575</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>B</code> 类型的对象输出的是 <code>类名@地址</code> ，而 <code>A</code> 类型的对象则是输出了 <code>toString()</code> 中返回的字符串。</p>
<p>上述行为的底层原理就是多态，在键入 <code>System.out.println()</code> 时，IntelliCode就已经给出了很关键的信息：</p>
<p><img src="/2022/03/04/JavaGrammar03/1.png" alt="1 1" title="1"></p>
<p>可以看到选中的 <code>println</code> 方法，其参数为 <code>Object</code> 类型。传入的参数将会被隐式类型转换为 <code>Object</code> 类，并在类中调用 <code>Object</code> 类型的 <code>toString()</code> 方法。由于子类重写了父类的该方法，因此调用的时候将会调用子类的 <code>toString()</code> 方法。</p>
<h4 id="2-equals"><a href="#2-equals" class="headerlink" title="2. equals()"></a><strong>2. <code>equals()</code></strong></h4><p>之前提到过， <code>String</code> 类型不能使用 <code>==</code> 来判断是否相等，必须使用 <code>equals()</code> 方法。该方法也和 <code>toString()</code> 方法一样，是重写的父类方法。</p>
<p>对于程序员自定义的类，调用 <code>equals()</code> 方法时会调用父类 <code>Object</code> 的方法，而父类的方法是用 <code>==</code> 来判断是否相等的。因此，如果希望能判断自定义类的对象是否相等，程序员必须重写 <code>equals()</code> 方法。</p>
<h3 id="6-Arrays"><a href="#6-Arrays" class="headerlink" title="(6) Arrays"></a><strong>(6) <code>Arrays</code></strong></h3><p><code>Arrays</code> 类定义在 <code>java.util.Arrays</code> 包中，它的的成员均为 <code>static</code> 的，其中有一些常见的用于数组的操作。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sort()</code></td>
<td align="center">数组</td>
<td align="center">快速排序</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>equals()</code></td>
<td align="center">2个同类型数组</td>
<td align="center">判断相等</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>binarySearch()</code></td>
<td align="center">数组，元素</td>
<td align="center">返回元素在数组中的索引</td>
<td align="center"><code>int</code></td>
</tr>
</tbody></table>
<p><code>Arrays</code> 类还有许多方法和重载的方法，详情请参见 <a class="btn" href="https://docs.oracle.com/javase/8/docs/api/ ">Java官方文档</a> 。<del>怎么不一开始就上官方文档？因为全是英文看得我都头疼，有中文理解能快不少。</del></p>
<h3 id="7-基本类型包装类"><a href="#7-基本类型包装类" class="headerlink" title="(7) 基本类型包装类"></a><strong>(7) 基本类型包装类</strong></h3><p>Java中的基本数据类型并不是类，因此也就没有继承自 <code>Object</code> 。而Java自身又提供了对基本类型的封装类，也就是将基本数据类型打包成继承自 <code>Object</code> 的类。</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">封装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>byte</code></td>
<td align="center"><code>Byte</code></td>
</tr>
<tr>
<td align="center"><code>short</code></td>
<td align="center"><code>Short</code></td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center"><code>Integer</code></td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center"><code>Long</code></td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center"><code>Float</code></td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center"><code>Double</code></td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center"><code>Character</code></td>
</tr>
<tr>
<td align="center"><code>boolean</code></td>
<td align="center"><code>Boolean</code></td>
</tr>
</tbody></table>
<p>这些包装类中封装了不少关于类型转换等功能的方法。关于这些包装类的成员，此处不做赘述，详情请参见 <a class="btn" href="https://docs.oracle.com/javase/8/docs/api/ ">Java官方文档</a> 。</p>
<h3 id="8-ArrayList-lt-T-gt"><a href="#8-ArrayList-lt-T-gt" class="headerlink" title="(8) ArrayList&lt;T&gt;"></a><strong>(8) <code>ArrayList&lt;T&gt;</code></strong></h3><p>就像C++中有STL容器一样，Java也有一些好用的容器，比如 <code>ArrayList</code> ，它类似于C#的 <code>List</code> 和C++的 <code>vector</code> ，<span style="color:red;">其底层实现为数组，即顺序表</span>。在使用 <code>ArrayList</code> 之前，应当导入 <code>java.util.ArrayList</code> 包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>

<p>声明一个存放 <code>StringBuilder</code> 对象的 <code>ArrayList</code> 对象，并初始化的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;StringBuilder&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>类型推断</strong></div>

<div style="color:royalblue;">上述代码中，在 <code>new</code> 关键字之后的 <code>ArrayList<></code> 可以不用写类型，编译器会自动推断。但隔壁C#已经做到只需要 <code>new</code> 关键字了。</div>
</div>

<p>与C++的 <code>vector</code> 类似， <code>ArrayList</code> 也有不少内置的方法。</p>
<div class="tabs" id="arraylistfunction"><ul class="nav-tabs"><li class="tab active"><a href="#arraylistfunction-1"><code>add()</code></a></li><li class="tab"><a href="#arraylistfunction-2"><code>remove()</code></a></li><li class="tab"><a href="#arraylistfunction-3"><code>set()</code></a></li><li class="tab"><a href="#arraylistfunction-4"><code>get()</code></a></li><li class="tab"><a href="#arraylistfunction-5"><code>contains()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="arraylistfunction-1"><p><code>add()</code> 方法的功能为向 <code>ArrayList</code> 对象中添加一个元素。<br>该方法有一个重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里初始化时的类型是Integer而不是int</span></span><br><span class="line">ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//当参数只有一个时</span></span><br><span class="line"><span class="comment">//返回值为boolean类型，指示是否添加成功</span></span><br><span class="line">System.out.println(temp.add(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当参数有两个时，第一个参数为插入位置</span></span><br><span class="line"><span class="comment">//无返回值</span></span><br><span class="line">temp.add(<span class="number">0</span>);</span><br><span class="line">temp.add(<span class="number">0</span>, <span class="number">8</span>);  <span class="comment">//在第0个元素前插入“8”</span></span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">true</span><br><span class="line">temp = [8, 1, 0]</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>数组越界</strong></div>

<div style="color:goldenrod;">当使用两个参数的 <code>add()</code> 时，应当注意插入位置不能越界，否则将会引发程序异常。</div>
</div></div><div class="tab-pane" id="arraylistfunction-2"><p><code>remove()</code> 方法的功能为删除 <code>ArrayList</code> 对象中的某个元素。它有一个重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">temp.add(<span class="number">114</span>);</span><br><span class="line">temp.add(<span class="number">514</span>);</span><br><span class="line">temp.add(<span class="number">1919</span>);</span><br><span class="line">temp.add(<span class="number">810</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种：删除第i个元素</span></span><br><span class="line"><span class="comment">// 返回值为该元素的值</span></span><br><span class="line">System.out.println(<span class="string">&quot;temp.remove(1) = &quot;</span> + temp.remove(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种： 删除指定值的元素，此处使用了显式类型转换</span></span><br><span class="line"><span class="comment">// 返回值为boolean类型，指示是否删除成功</span></span><br><span class="line"><span class="comment">// 有多个相同元素时，只会删除索引值最小的元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;temp.remove(1919) = &quot;</span> + temp.remove((Integer) <span class="number">1919</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">temp.remove(1) = 514</span><br><span class="line">temp.remove(1919) = true</span><br><span class="line">temp = [114, 810]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraylistfunction-3"><p><code>set()</code> 方法用于修改某个元素的值。该方法有两个参数：待修改的元素索引，指定的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">temp.add(<span class="number">114</span>);</span><br><span class="line">temp.add(<span class="number">514</span>);</span><br><span class="line">temp.add(<span class="number">1919</span>);</span><br><span class="line">temp.add(<span class="number">810</span>);</span><br><span class="line"></span><br><span class="line">temp.set(<span class="number">1</span>, <span class="number">114514</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">temp = [114, 114514, 1919, 810]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraylistfunction-4"><p><code>get()</code> 方法用于获取 <code>ArrayList</code> 对象的第i个元素。Java的 <code>ArrayList</code> 对象<span style="color:red;">不能</span>通过类似于数组的索引方式来获取元素<del>而C++和C#都支持</del>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">temp.add(<span class="number">114</span>);</span><br><span class="line">temp.add(<span class="number">514</span>);</span><br><span class="line">temp.add(<span class="number">1919</span>);</span><br><span class="line">temp.add(<span class="number">810</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;temp[2] = &quot;</span> + temp.get(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">temp[2] = 1919</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraylistfunction-5"><p><code>contains()</code> 方法用于判断某个元素是否在 <code>ArrayList</code> 对象中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">temp.add(<span class="number">114</span>);</span><br><span class="line">temp.add(<span class="number">514</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;114 in temp is &quot;</span> + temp.contains(<span class="number">114</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">114 in temp is true</span><br></pre></td></tr></table></figure></div></div></div>

<p>下面还有一些功能很简单的方法：</p>
<ul>
<li><code>clear()</code> ，清空元素</li>
<li><code>isEmpty()</code> ，如果为空则返回 <code>true</code> ，否则返回 <code>false</code></li>
<li><code>size()</code> ，返回元素个数</li>
</ul>
<p>关于更多 <code>ArrayList</code> 类的方法，请参见 <a class="btn" href="https://www.runoob.com/java/java-arraylist.html ">菜鸟教程</a> 。</p>
<h3 id="9-LinkedList-lt-T-gt"><a href="#9-LinkedList-lt-T-gt" class="headerlink" title="(9) LinkedList&lt;T&gt;"></a><strong>(9) <code>LinkedList&lt;T&gt;</code></strong></h3><p><code>LinkedList</code> 类定义在 <code>java.util.LinkedList</code> 包内，它与 <code>ArrayList</code> 差异不大，但其底层实现是链表。 <code>LinkedList</code> 中有一些独有的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>addFirst()</code></td>
<td align="center">元素</td>
<td align="center">在表头插入指定元素</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>addLast()</code></td>
<td align="center">元素</td>
<td align="center">在表尾新增指定元素</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>getFirst()</code></td>
<td align="center">无</td>
<td align="center">返回表头元素</td>
<td align="center">元素</td>
</tr>
<tr>
<td align="center"><code>getLast()</code></td>
<td align="center">无</td>
<td align="center">返回表尾元素</td>
<td align="center">元素</td>
</tr>
<tr>
<td align="center"><code>removeFirst()</code></td>
<td align="center">无</td>
<td align="center">删除表头元素并返回</td>
<td align="center">元素</td>
</tr>
<tr>
<td align="center"><code>removeLast()</code></td>
<td align="center">无</td>
<td align="center">删除表尾元素并返回</td>
<td align="center">元素</td>
</tr>
</tbody></table>
<h3 id="10-HashSet-lt-T-gt"><a href="#10-HashSet-lt-T-gt" class="headerlink" title="(10) HashSet&lt;T&gt;"></a><strong>(10) <code>HashSet&lt;T&gt;</code></strong></h3><p><code>HashSet</code> 类定义在 <code>java.util.HashSet</code> 包内。它的常见方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>add()</code></td>
<td align="center">元素</td>
<td align="center">添加元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>remove()</code></td>
<td align="center">元素</td>
<td align="center">删除指定的元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>clear()</code></td>
<td align="center">无</td>
<td align="center">清空集合</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>contains()</code></td>
<td align="center">元素</td>
<td align="center">判断集合是否包含元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>isEmpty</code></td>
<td align="center">无</td>
<td align="center">判断集合是否为空</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>size()</code></td>
<td align="center">无</td>
<td align="center">返回集合中元素个数</td>
<td align="center"><code>int</code></td>
</tr>
</tbody></table>
<p><code>HashSet</code> 的底层实现是哈希表。这意味着，存储于 <code>HashSet</code> 对象内的元素是乱序且唯一的。</p>
<h3 id="11-LinkedHashSet-lt-T-gt"><a href="#11-LinkedHashSet-lt-T-gt" class="headerlink" title="(11) LinkedHashSet&lt;T&gt;"></a><strong>(11) <code>LinkedHashSet&lt;T&gt;</code></strong></h3><p><code>LinkedHashSet</code> 类定义在 <code>java.util.LinkedHashSet</code> 包内。它基于链表和哈希表，存储于 <code>HashSet</code> 对象中的元素不仅有序，而且唯一。它定义的常用的方法与 <code>HashSet</code> 一致，此处不再赘述。</p>
<h3 id="12-TreeSet-lt-T-gt"><a href="#12-TreeSet-lt-T-gt" class="headerlink" title="(12) TreeSet&lt;T&gt;"></a><strong>(12) <code>TreeSet&lt;T&gt;</code></strong></h3><p><code>TreeSet</code> 类定义在 <code>java.util.TreeSet</code> 包内。它的元素同样有序且唯一，但排序方式可以采用默认的自然排序，或自定义排序方式。它和上述的“Set家族”类差异体现在构造函数上。</p>
<ul>
<li>无参构造函数，采用自然排序</li>
<li>带参构造函数，根据给定的比较器进行排序</li>
</ul>
<p>关于比较器，下文的“一些常见接口”一章将会详述。</p>
<h3 id="13-HashMap-lt-K-V-GT"><a href="#13-HashMap-lt-K-V-GT" class="headerlink" title="(13) HashMap&lt;K, V&GT;"></a><strong>(13) <code>HashMap&lt;K, V&GT;</code></strong></h3><p><code>HashMap</code> 类定义在 <code>java.util.HashMap</code> 包内，其中， <code>K</code> 为键的类型， <code>V</code> 为值的类型。该类与C++的 <code>map</code> 、Python的字典类似。它有如下的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>put()</code></td>
<td align="center">键，值</td>
<td align="center">创建新键值对</td>
<td align="center">值</td>
</tr>
<tr>
<td align="center"><code>remove()</code></td>
<td align="center">键</td>
<td align="center">删除指定的键值对</td>
<td align="center">值</td>
</tr>
<tr>
<td align="center"><code>clear()</code></td>
<td align="center">无</td>
<td align="center">删除所有键值对</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>containsKey()</code></td>
<td align="center">键</td>
<td align="center">判断是否含有指定键</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>containsValue()</code></td>
<td align="center">值</td>
<td align="center">判断是否含有指定值</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>isEmpty()</code></td>
<td align="center">无</td>
<td align="center">判断对象是否为空</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>size()</code></td>
<td align="center">无</td>
<td align="center">返回键值对个数</td>
<td align="center"><code>int</code></td>
</tr>
<tr>
<td align="center"><code>get()</code></td>
<td align="center">键</td>
<td align="center">返回键对应的值</td>
<td align="center">值或 <code>null</code></td>
</tr>
<tr>
<td align="center"><code>keySet()</code></td>
<td align="center">无</td>
<td align="center">返回所有的键</td>
<td align="center"><code>Set&lt;K&gt;</code></td>
</tr>
<tr>
<td align="center"><code>values()</code></td>
<td align="center">无</td>
<td align="center">返回所有的值</td>
<td align="center"><code>Collection&lt;V&gt;</code></td>
</tr>
<tr>
<td align="center"><code>entrySet()</code></td>
<td align="center">无</td>
<td align="center">返回所有的键值对</td>
<td align="center"><code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code></td>
</tr>
</tbody></table>
<p>其中， <code>Map.Entry&lt;K, V&gt;</code> 是一个接口，该接口声明了如下两个常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getKey()</code></td>
<td align="center">无</td>
<td align="center">返回键</td>
<td align="center">键</td>
</tr>
<tr>
<td align="center"><code>getValue</code></td>
<td align="center">无</td>
<td align="center">返回值</td>
<td align="center">值</td>
</tr>
</tbody></table>
<p>可以使用上述两个方法，搭配 <code>entrySet()</code> 方法，以遍历 <code>HashMap</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; temp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">temp.put(<span class="number">114</span>, <span class="string">&quot;いいよ&quot;</span>);</span><br><span class="line">temp.put(<span class="number">514</span>, <span class="string">&quot;来いよ&quot;</span>);</span><br><span class="line">temp.put(<span class="number">1919</span>, <span class="string">&quot;行く行く&quot;</span>);</span><br><span class="line">temp.put(<span class="number">810</span>, <span class="string">&quot;入れ&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有键值对</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; a = temp.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用增强型for循环遍历Set对象</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; i : a) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + i.getKey() + <span class="string">&quot;, Value = &quot;</span> + i.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">Key = 114, Value = いいよ</span><br><span class="line">Key = 514, Value = 来いよ</span><br><span class="line">Key = 810, Value = 入れ</span><br><span class="line">Key = 1919, Value = 行く行く</span><br></pre></td></tr></table></figure>

<p>可以看到键值对的遍历顺序不是插入顺序，说明该类是乱序存储的。从命名也能看出，这是个基于哈希表实现的类。</p>
<p>当然，也可以用 <code>getKey()</code> 方法，只获取所有键，遍历键的同时使用 <code>get()</code> 方法来获取其对应值。此处就不做代码实例了。</p>
<h3 id="14-Collections"><a href="#14-Collections" class="headerlink" title="(14) Collections"></a><strong>(14) <code>Collections</code></strong></h3><p><code>Collections</code> 类定义在 <code>java.util.Collections</code> 包中。该类的所有成员均为 <code>static</code> 的，其中大多数为针对容器的一些方法。该类不允许有实例对象。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sort()</code></td>
<td align="center">列表</td>
<td align="center">升序排序列表</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>reverse()</code></td>
<td align="center">列表</td>
<td align="center">反转列表中元素顺序</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>shuffle</code></td>
<td align="center">列表</td>
<td align="center">随机洗切列表中的元素</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">······</td>
<td align="center">······</td>
<td align="center">······</td>
<td align="center">······</td>
</tr>
</tbody></table>
<p>关于更多 <code>Collections</code> 类的方法，请参见 <a class="btn" href="https://docs.oracle.com/javase/8/docs/api/ ">Java官方文档</a> 。</p>
<h2 id="五、一些常见接口"><a href="#五、一些常见接口" class="headerlink" title="五、一些常见接口"></a><strong>五、一些常见接口</strong></h2><p>Java是纯面向对象语言，多态又是面向对象的特色，在创建类似于C++ STL的对象时，建议采用接口作为类型，以某一具体类作为实现，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>其中， <code>Collection</code> 是一个接口，而 <code>ArrayList</code> 是一个实现了该接口的类。</p>
<h3 id="1-Iterator-lt-T-gt-（迭代器）"><a href="#1-Iterator-lt-T-gt-（迭代器）" class="headerlink" title="(1) Iterator&lt;T&gt; （迭代器）"></a><strong>(1) <code>Iterator&lt;T&gt;</code> （迭代器）</strong></h3><p><code>Iterator</code> 接口定义在 <code>java.util.Iterator</code> 包内。它声明的常见的方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>hasNext()</code></td>
<td align="center">无</td>
<td align="center">判断是否有下一个元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>next</code></td>
<td align="center">无</td>
<td align="center">返回下一个元素，并让“指针”后移</td>
<td align="center">元素</td>
</tr>
<tr>
<td align="center"><code>remove()</code></td>
<td align="center">无</td>
<td align="center">删除当前元素</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>一般情况下，实现了 <code>Iterator</code> 接口的类会封装为 <code>private</code> 的内部类，只能通过 <code>iterator()</code> 方法获取。接下来就会讲如何应用迭代器。</p>
<h3 id="2-Collection-lt-T-gt-（集合）"><a href="#2-Collection-lt-T-gt-（集合）" class="headerlink" title="(2) Collection&lt;T&gt; （集合）"></a><strong>(2) <code>Collection&lt;T&gt;</code> （集合）</strong></h3><p><code>Collection</code> （集合）接口定义在 <code>java.util.Collection</code> 包内。应当注意它与 <code>Collections</code> 类的区别。它声明的常见的方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>add()</code></td>
<td align="center">元素</td>
<td align="center">添加元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>remove()</code></td>
<td align="center">元素</td>
<td align="center">删除指定的元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>clear()</code></td>
<td align="center">无</td>
<td align="center">清空集合</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>contains()</code></td>
<td align="center">元素</td>
<td align="center">判断集合是否包含元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>isEmpty</code></td>
<td align="center">无</td>
<td align="center">判断集合是否为空</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>size()</code></td>
<td align="center">无</td>
<td align="center">返回集合中元素个数</td>
<td align="center"><code>int</code></td>
</tr>
<tr>
<td align="center"><code>iterator()</code></td>
<td align="center">无</td>
<td align="center">返回一个迭代器</td>
<td align="center"><code>Iterator&lt;T&gt;</code></td>
</tr>
</tbody></table>
<p>使用迭代器遍历集合的操作非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">temp.add(<span class="string">&quot;114&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;514&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;1919&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;810&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取迭代器</span></span><br><span class="line">Iterator&lt;String&gt; i = temp.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">    System.out.println(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">114</span><br><span class="line">514</span><br><span class="line">1919</span><br><span class="line">810</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>增强型 <code>for</code> 循环</strong></div>

<div style="color:royalblue;">之前有提到过Java的数组能用类似Python的 <code>for in</code> 循环。实际上，只要是实现了 <code>Iterator</code> 接口的类，就都能使用 <code>for in</code> 循环（准确的说法应该是增强型 <code>for</code> 循环）。</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String i : temp) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">114</span><br><span class="line">514</span><br><span class="line">1919</span><br><span class="line">810</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">其底层原理是 <code>Iterator</code> 接口声明了一个特殊的方法。可以粗暴地认为，该方法重载了 <code>for</code> 循环。</div>
</div>

<h3 id="3-ListIterator-lt-T-gt-（列表迭代器）"><a href="#3-ListIterator-lt-T-gt-（列表迭代器）" class="headerlink" title="(3) ListIterator&lt;T&gt; （列表迭代器）"></a><strong>(3) <code>ListIterator&lt;T&gt;</code> （列表迭代器）</strong></h3><p><code>ListIterator</code> 接口定义在 <code>java.util.ListIterator</code> 包内，它继承自 <code>Iterator</code> 接口。它新增了如下方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>previous</code></td>
<td align="center">无</td>
<td align="center">返回上一个元素，并让“指针”前移</td>
<td align="center">元素</td>
</tr>
<tr>
<td align="center"><code>hasPrevious</code></td>
<td align="center">无</td>
<td align="center">判断是否有上一个元素</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>add()</code></td>
<td align="center">元素</td>
<td align="center">在当前位置插入元素</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h3 id="4-List-lt-T-gt-（列表）"><a href="#4-List-lt-T-gt-（列表）" class="headerlink" title="(4) List&lt;T&gt; （列表）"></a><strong>(4) <code>List&lt;T&gt;</code> （列表）</strong></h3><p><code>List</code> 接口定义在 <code>java.util.List</code> 包内，它继承自 <code>Collection</code> 接口。实现了该接口的常见类有 <code>ArrayList</code> 和 <code>LinkedList</code> 。该接口新增的方法有：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>add()</code></td>
<td align="center"><code>int</code> ，元素</td>
<td align="center">在指定位置插入元素</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>remove()</code></td>
<td align="center"><code>int</code></td>
<td align="center">删除指定位置的元素</td>
<td align="center">删除的元素值</td>
</tr>
<tr>
<td align="center"><code>set()</code></td>
<td align="center"><code>int</code> ，元素</td>
<td align="center">修改指定位置的元素</td>
<td align="center">被修改的元素值</td>
</tr>
<tr>
<td align="center"><code>get()</code></td>
<td align="center"><code>int</code></td>
<td align="center">返回指定位置的元素</td>
<td align="center">元素</td>
</tr>
<tr>
<td align="center"><code>listIterator()</code></td>
<td align="center">无</td>
<td align="center">返回一个列表迭代器</td>
<td align="center"><code>ListIterator&lt;T&gt;</code></td>
</tr>
</tbody></table>
<p>列表迭代器能够对列表进行增加操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">temp.add(<span class="string">&quot;114&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;514&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;1919&quot;</span>);</span><br><span class="line">temp.add(<span class="string">&quot;810&quot;</span>);</span><br><span class="line"></span><br><span class="line">ListIterator&lt;String&gt; i = temp.listIterator();</span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">    System.out.println(i.next());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向当前位置添加元素</span></span><br><span class="line">    i.add(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;temp = &quot;</span> + temp);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">114</span><br><span class="line">514</span><br><span class="line">1919</span><br><span class="line">810</span><br><span class="line">temp = [114, ?, 514, ?, 1919, ?, 810, ?]</span><br></pre></td></tr></table></figure>

<h3 id="5-Set-lt-T-gt"><a href="#5-Set-lt-T-gt" class="headerlink" title="(5) Set&lt;T&gt;"></a><strong>(5) <code>Set&lt;T&gt;</code></strong></h3><p><code>Set</code> 接口定义在 <code>java.util.Set</code> 包内，它继承自 <code>Collection</code> 接口，在其基础之上追加了一个新功能：不允许重复元素。<code>Set</code> 接口没有在 <code>Collection</code> 接口的基础上新增什么常用的方法，这里就不做赘述。但实现了 <code>Set</code> 接口的类，遍历时元素的输出顺序一般为乱序，典型的类有 <code>HashSet</code> 、 <code>LinkedHashSet</code> 和 <code>TreeSet</code>。</p>
<h3 id="6-Comparable-lt-T-gt-（自然排序）"><a href="#6-Comparable-lt-T-gt-（自然排序）" class="headerlink" title="(6) Comparable&lt;T&gt; （自然排序）"></a><strong>(6) <code>Comparable&lt;T&gt;</code> （自然排序）</strong></h3><p><code>Comparable</code> 接口只声明了一个方法： <code>compareTo()</code> 。该方法的声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span></span><br></pre></td></tr></table></figure>

<p>该方法的目的是实现两个对象之间的比较。<br>若返回0，则认为两个对象相等；<br>若返回正数，则认为参数对象较大；<br>若返回负数，则认为调用方法的对象较大。</p>
<h3 id="7-Comparator-lt-T-gt-（比较器）"><a href="#7-Comparator-lt-T-gt-（比较器）" class="headerlink" title="(7) Comparator&lt;T&gt; （比较器）"></a><strong>(7) <code>Comparator&lt;T&gt;</code> （比较器）</strong></h3><p><code>Comparator</code> 接口声明了很多方法，但常用的就一个： <code>compare()</code> 。该方法的声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span></span><br></pre></td></tr></table></figure>

<p>该方法的目的也是实现两个对象之间的比较。<br>若返回0，则认为两个对象相等；<br>若返回正数，则认为前者较大；<br>若返回负数，则认为后者较大。</p>
<p>在使用 <code>Comparator</code> 接口时，通常使用匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Lacia&gt; temp = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Lacia&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Lacia a, Lacia b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="comment">// 你的判断代码</span></span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只需要重写 <code>compare()</code> 方法即可。</p>
<h3 id="8-Map-lt-K-V-gt"><a href="#8-Map-lt-K-V-gt" class="headerlink" title="(8) Map&lt;K, V&gt;"></a><strong>(8) <code>Map&lt;K, V&gt;</code></strong></h3><p><code>Map</code> 接口定义在 <code>java.util.Map</code> 包内。其中， <code>K</code> 为键的类型， <code>V</code> 为值的类型。该类型声明的方法中，常用的方法与上文中 <code>HashMap</code> 类的常用方法一致（因为 <code>HashMap</code> 类实现了该接口）。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Java语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript DOM基础</title>
    <url>/2022/02/01/JavaScriptDOM/</url>
    <content><![CDATA[<img src="/2022/02/01/JavaScriptDOM/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要JavaScript基础与HTML基础，并且最好有数据结构基础。</div>
</div>

<span id="more"></span>

<h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a><strong>什么是DOM</strong></h2><a class="btn" href="https://baike.baidu.com/item/%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">百度百科</a>

<p>看不懂百度百科也没关系。<del>因为我也看不懂。</del>总之，JavaScript要想控制网页的交互行为，就必须能有与HTML发生关系的“连接方式”，这种“连接方式”就是DOM。</p>
<h2 id="一、document对象"><a href="#一、document对象" class="headerlink" title="一、document对象"></a><strong>一、document对象</strong></h2><p>在JavaScript基础部分曾经提到了运行环境会为JavaScript脚本提供一个调用此脚本的对象，也就是this指向的对象。在浏览器中，这个对象就是Window。Window对象下还有一个作为“成员变量”的子对象，document。</p>
<p><img src="/2022/02/01/JavaScriptDOM/1.png" alt="1 1" title="1"></p>
<div class="note info"><div style="color:royalblue;font-size:1.5em"><strong>浏览器的控制台</strong></div>

<div style="color:royalblue;">我使用的是微软的Microsoft Edge，基于Chromium内核。随便打开一个网页，按F12以打开开发人员工具，并找到控制台选项。直接在这个控制台输入变量名可以看见它的值，this也不例外。</div>
</div>

<p>document对象指向的就是HTML文件。通过对document对象的操作，就能改变网页的外观与行为。</p>
<h2 id="二、抽象理解HTML"><a href="#二、抽象理解HTML" class="headerlink" title="二、抽象理解HTML"></a><strong>二、抽象理解HTML</strong></h2><p>HTML里有许多标签，标签里还能再套一个标签，也就是子标签。有没有想起什么？对，树。</p>
<p><img src="/2022/02/01/JavaScriptDOM/2.png" alt="2 2"></p>
<p>document对象将HTML文件抽象成了树，每一个标签就是一个结点。没学过数据结构？往下学其实也没什么太大影响。</p>
<p>通过document对象获取到标签对象（如何获得下文再将）以后，你所得到的是一个标签的对象。有对象自然就有属性。属性，对没错指的就是HTML的标签的属性。因此，通过JavaScript设置标签的属性，也就是设置交互行为就成为了可能。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>结点的种类</strong></div>

<div style="color:goldenrod;">HTML中，结点可以大致分为4类——文档结点、标签结点、属性结点、文本结点。文档结点就是根结点。由于标签之间的换行、空格会被算作文本结点，因此应当注意不要将这些结点混淆使用。</div>
</div>

<h2 id="三、获取标签对象"><a href="#三、获取标签对象" class="headerlink" title="三、获取标签对象"></a><strong>三、获取标签对象</strong></h2><p>可以使用document对象自带的方法。</p>
<ul>
<li><p>getElementById(string)<br>传入的参数为标签的ID。获取对应ID的标签对象，返回值为对象本身。</p>
</li>
<li><p>getElementsByClassName(string)<br>传入的参数为标签的类名。获取所有含有此类名的标签对象，返回值为对象的数组。</p>
</li>
<li><p>getElementsByTagName(string)<br>传入的参数为标签名。获取所有此标签名的标签对象，返回值为对象的数组。</p>
</li>
<li><p>getElementsByName(string)<br>传入的参数为name的值。获取所有name属性为此值的标签对象，返回值为对象的数组。</p>
</li>
</ul>
<p>用于获取标签对象的常用方法就这四种。</p>
<h2 id="四、更改标签属性"><a href="#四、更改标签属性" class="headerlink" title="四、更改标签属性"></a><strong>四、更改标签属性</strong></h2><p>这部分由于之前已经有JavaScript、CSS、HTML基础了，所以举一反三很容易，因此只举一个简单的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入加数&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入加数&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>求和<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为这个按钮添加点击事件函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Button</span> = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Inputs</span> = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="title class_">Button</span>.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> input0 = <span class="title class_">Inputs</span>[<span class="number">0</span>].<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> input1 = <span class="title class_">Inputs</span>[<span class="number">1</span>].<span class="property">value</span>;</span><br><span class="line">    <span class="comment">//获取文本输入</span></span><br><span class="line">    input0 = <span class="built_in">parseFloat</span>(input0);</span><br><span class="line">    input1 = <span class="built_in">parseFloat</span>(input1);</span><br><span class="line">    <span class="comment">//转换为数字</span></span><br><span class="line">    <span class="keyword">var</span> temp = input0 + input1;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Result</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="comment">//创建新的div标签结点，但此时还未插入HTML中</span></span><br><span class="line">    <span class="title class_">Result</span>.<span class="property">innerHTML</span> = <span class="title class_">String</span>(temp);</span><br><span class="line">    <span class="comment">//将标签内的文本更换为temp</span></span><br><span class="line">    <span class="title class_">Button</span>.<span class="property">parentNode</span>.<span class="title function_">append</span>(<span class="title class_">Result</span>);</span><br><span class="line">    <span class="comment">//寻找Button的父结点，并将其插入到这个标签的最末尾处</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>请注意上述代码并没有检测输入的合法性<del>其实是我懒得做</del>。</p>
<p>标签对象的常用属性&#x2F;方法有:</p>
<ul>
<li><p>appendChild(Tag)<br>在最后一个子标签之后添加一个子标签</p>
</li>
<li><p>children<br>返回标签的所有子标签数组</p>
</li>
<li><p>getAttribute(string)<br>返回标签指定属性的值</p>
</li>
<li><p>hasAttribute(string)<br>如果标签含有指定的属性则返回true，否则返回false</p>
</li>
<li><p>innerHTML<br>返回或者修改标签内部的文本</p>
</li>
<li><p>insertBefore(Tag)<br>在第一个子标签之前添加一个子标签</p>
</li>
<li><p>nextElementSibling<br>返回标签的下一个兄弟标签</p>
</li>
<li><p>nextSibling<br>返回标签的下一个紧跟着的标签</p>
</li>
<li><p>previousElementSibling<br>返回标签的上一个兄弟标签</p>
</li>
<li><p>previousSibling<br>返回标签的上一个紧跟着的标签</p>
</li>
<li><p>removeAttribute(string)<br>删除标签的指定属性</p>
</li>
<li><p>parentNode<br>获取标签的父标签</p>
</li>
</ul>
<p>要查看所有标签对象的属性&#x2F;方法，请前往 <a class="btn" href="https://www.runoob.com/jsref/dom-obj-all.html">菜鸟教程</a> 。</p>
<p>当然除了上述的属性&#x2F;方法外，HTML的标签的属性在JavaScript里也能使用。<span style="color:red;">但是请注意，要修改标签外观只能修改位于style属性内的内联样式。获取标签样式时，应当使用getAttribute()，而不能直接使用“标签.style”的方式查询</span>。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>网页开发基础</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础（五）</title>
    <url>/2022/03/07/JavaGrammar05/</url>
    <content><![CDATA[<img src="/2022/03/07/JavaGrammar05/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">
[1] 建议至少有学过一门其它编程语言（最好是C#或C++）的基础再看本文。<br>
[2] 本文默认读者有操作系统基础。
</div>
</div>

<span id="more"></span>

<h2 id="十、多线程"><a href="#十、多线程" class="headerlink" title="十、多线程"></a><strong>十、多线程</strong></h2><p>在Java中，与多线程相关的类是 <code>Thread</code> 类。与C#相比，Java的好处是不用担心主线程结束时，会一并结束未执行完毕的子线程。</p>
<h3 id="1-启动多线程"><a href="#1-启动多线程" class="headerlink" title="(1) 启动多线程"></a><strong>(1) 启动多线程</strong></h3><p><code>Thread</code> 类没有被 <code>final</code> 关键字修饰，因此它可以被程序员的自定义类继承。在 <code>Thread</code> 类中，有两个方法与多线程相关：</p>
<ul>
<li><code>run()</code> ，等待多线程执行的方法</li>
<li><code>start()</code> ，以 <code>run()</code> 方法为入口，开始执行新的线程</li>
</ul>
<p>程序员只需要重写 <code>run()</code> 方法即可。但当要开启多线程时，应该调用 <code>start()</code> 方法，直接调用 <code>run()</code> 方法不会创建新的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Trash</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trash</span>();</span><br><span class="line">        temp.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trash</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码由于输出过多且多线程会导致每次输出不一致，此处就不展示输出结果。</p>
<h3 id="2-线程名称"><a href="#2-线程名称" class="headerlink" title="(2) 线程名称"></a><strong>(2) 线程名称</strong></h3><p>Java的 <code>Thread</code> 类中有一个 <code>String</code> 类型的成员变量，变量名为 <code>name</code> 。它是 <code>private</code> 的，因此不能在子类中访问，但有 <code>getName()</code> 和 <code>setName()</code> 方法，分别能获取和写入线程名。即便不手动写入线程名，构造函数也会为其自动分配。</p>
<p>想设置线程名称，可以在创建完对象以后再调用 <code>setName()</code> 方法；也可以直接在构造函数中传入线程名，但这要求自定义的类有带参构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Trash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Trash</span><span class="params">(String Name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-线程优先级"><a href="#3-线程优先级" class="headerlink" title="(3) 线程优先级"></a><strong>(3) 线程优先级</strong></h3><p>Java允许高优先级的线程抢占CPU。 <code>Thread</code> 类中有一个用于标记线程优先级的 <code>private</code> 的 <code>int</code> 型成员变量 <code>priority</code> 。它与 <code>name</code> 一样，有配套的 <code>getPriority()</code> 和 <code>setPriority()</code> 方法。</p>
<p>线程默认的优先级是5。虽然线程的优先级是用 <code>int</code> 型变量标记的，但它的取值范围比 <code>int</code> 的取值范围要小，其最小值是 <code>MIN_PRIORITY</code> ，最大值是 <code>MAX_PRIORITY</code> ，它们都定义在 <code>Thread</code> 类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;最小优先级 = &quot;</span> + Thread.MIN_PRIORITY);</span><br><span class="line">System.out.println(<span class="string">&quot;最大优先级 = &quot;</span> + Thread.MAX_PRIORITY);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">javac MainProgram.java ; java MainProgram</span></span><br><span class="line">最小优先级 = 1</span><br><span class="line">最大优先级 = 10</span><br></pre></td></tr></table></figure>

<p>在 <code>Thread</code> 类的源代码中也能看到其定义：</p>
<p><img src="/2022/03/07/JavaGrammar05/1.png" alt="1 1" title="1"></p>
<p>线程优先级越高，其获得CPU时间片的概率越高。</p>
<h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="(4) 常用方法"></a><strong>(4) 常用方法</strong></h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
<th align="center"><code>static</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>sleep()</code></td>
<td align="center"><code>long</code></td>
<td align="center">让线程休眠，单位为毫秒</td>
<td align="center">无</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>sleep()</code></td>
<td align="center"><code>long</code> ， <code>int</code></td>
<td align="center">让线程休眠，单位为毫秒和纳秒</td>
<td align="center">无</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>join()</code></td>
<td align="center">无</td>
<td align="center">等待该线程执行完毕</td>
<td align="center">无</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><code>currentThread()</code></td>
<td align="center">无</td>
<td align="center">返回当前线程的对象</td>
<td align="center"><code>Thread</code></td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><code>setDaemon()</code></td>
<td align="center"><code>boolean</code></td>
<td align="center">是否将该线程设置为守护线程</td>
<td align="center">无</td>
<td align="center">否</td>
</tr>
</tbody></table>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>守护线程</strong></div>

<div style="color:royalblue;">Java虚拟机会在还有非守护线程的时候保持运行，当没有线程或剩余的线程全为守护线程时，Java虚拟机会自动退出，即程序结束运行。Java中的子线程默认是非守护线程，通过这种方式来让子线程在主线程结束以后依然保持运行。而C#默认的方案是进程不会等待子线程执行结束。</div>
</div>

<p>此外，如果想要终止线程，建议在自定义类中增加一个flag，并在 <code>run()</code> 方法内检测该flag，通过改变flag来控制线程退出。当然也可以使用 <code>Thread</code> 类定义的 <code>stop()</code> 方法，但该方法是不安全的。</p>
<h3 id="5-Runnable-接口"><a href="#5-Runnable-接口" class="headerlink" title="(5) Runnable 接口"></a><strong>(5) <code>Runnable</code> 接口</strong></h3><p>自定义的类可以不继承自 <code>Thread</code> 类而实现多线程，但它必须实现 <code>Runnable</code> 接口。该接口只声明了一个名为 <code>run()</code> 的方法。只需要将该类的对象传入 <code>Thread</code> 对象的构造函数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Thread对象，并设置线程名称</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Trash</span>(), <span class="string">&quot;114514&quot;</span>);</span><br><span class="line">        temp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trash</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程名称也可以用下述方式</span></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;垃圾线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Java不允许多继承，因此当你不得不继承其它类而又必须实现多线程时，不妨考虑考虑实现 <code>Runnable</code> 接口。</p>
<h3 id="6-线程同步"><a href="#6-线程同步" class="headerlink" title="(6) 线程同步"></a><strong>(6) 线程同步</strong></h3><p>使用多线程时，程序员经常会面临多个线程同时读写一个变量的问题。为了解决这个问题，就需要使用线程同步。使用线程同步时，<span style="color:red;">建议使用实现 <code>Runnable</code> 接口的方式来实现多线程。</span></p>
<h4 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1. synchronized"></a><strong>1. <code>synchronized</code></strong></h4><p><code>synchronized</code> 关键字有两种使用方式。下面是第一种，直接括住关键区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Trash</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trash</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建4个线程</span></span><br><span class="line">        <span class="comment">// 每个线程都会尝试访问并修改同一个数据</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(temp);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(temp);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(temp);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(temp);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请注意这里是实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trash</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁，它是Object类型的</span></span><br><span class="line">    <span class="comment">// 这意味着所有的类都可以作为互斥锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会同时被4个线程尝试访问并修改的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 语法有点像if语句</span></span><br><span class="line">            <span class="comment">// synchronized块内的代码为关键区</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Trash.mutex) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span> + Trash.i);</span><br><span class="line">                Trash.i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码输出过长，此处就不做展示。输出结果应该是从0逐次递增，直至输出到99。</p>
<p>第二种方式是作为方法的修饰符，被修饰的方法内的所有语句都是关键区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行synchronized方法</span></span><br><span class="line">        CriticalArea();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法内的所有语句均为关键区</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">CriticalArea</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + Trash.i);</span><br><span class="line">    Trash.i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两种线程同步的代码的输出结果是一致的。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>为什么不推荐继承自 <code>Thread</code> 类</strong></div>

<div style="color:royalblue;">继承自 <code>Thread</code> 类意味着你在使用多线程的时候，需要创建多个不同的自定义对象；而实现 <code>Runnable</code> 接口则只需要一个自定义对象，但需要多个线程对象。不同之处在于，自定义对象是复数个的时候，互斥锁和共享资源都需要使用 <code>static</code> 修饰，因为不同的对象无法互相访问对方的数据。</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建了多个自定义对象</span></span><br><span class="line">        <span class="type">Trash</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trash</span>();</span><br><span class="line">        <span class="type">Trash</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trash</span>();</span><br><span class="line">        <span class="type">Trash</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trash</span>();</span><br><span class="line">        <span class="type">Trash</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trash</span>();</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类继承自Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trash</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同的对象访问同一数据，只能用static修饰符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;</span><br><span class="line">            CriticalArea();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非static方法</span></span><br><span class="line">    <span class="comment">// 此处的synchronized关键字将无效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">CriticalArea</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + Trash.i);</span><br><span class="line">        Trash.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">部分输出见下图：</div>

<p><img src="/2022/03/07/JavaGrammar05/2.png" alt="2 2" title="2"></p>
<div style="color:royalblue;">可以看见 <code>synchronized</code> 关键字并没有生效，线程并没有同步。实际上，把 <code>synchronized</code> 用于修饰方法时也使用了一个互斥锁，这个锁就是 <code>this</code> ，即该对象。这就是为什么不建议继承自 <code>Thread</code> 类。但是要继承自 <code>Thread</code> 类也不是不可以，只是需要用 <code>static</code> 修饰被 <code>synchronized</code> 修饰的方法。</div>
</div>

<h4 id="2-Lock-接口"><a href="#2-Lock-接口" class="headerlink" title="2. Lock 接口"></a><strong>2. <code>Lock</code> 接口</strong></h4><p><code>Lock</code> 接口也可以用于实现线程同步。该接口声明的方法中，有两个常用方法：</p>
<ul>
<li><code>lock()</code> ，获得锁</li>
<li><code>unlock()</code> ，释放锁</li>
</ul>
<p>它们都没有参数，也没有返回值。 <code>ReentrantLock</code> 类是一个实现了 <code>Lock</code> 接口的类。本文默认读者有操作系统基础，关于这种互斥锁的使用方式此处不再赘述。</p>
<h2 id="十一、网络通信"><a href="#十一、网络通信" class="headerlink" title="十一、网络通信"></a><strong>十一、网络通信</strong></h2><p>网络通信三要素：</p>
<ul>
<li>IP地址</li>
<li>端口</li>
<li>协议</li>
</ul>
<p>Java为这三个要素都做了类（悲），由于涉及的类过多，此处就不做详解，有具体需要请查询 <a class="btn" href="https://docs.oracle.com/javase/8/docs/api/ ">Java官方文档</a> 。</p>
<p>Java不仅做了相关的类，还做了各种相关的异常，这些异常全都被 <code>throws</code> 出了其内置的方法，最终会让程序员处理。由于异常过多，这里不作说明，只简单说明如何在学习时绕过这些异常，不触发因为没有抛出异常而造成的报错：</p>
<ul>
<li>使用 <code>try catch</code> 块<br>把 <code>catch</code> 块的参数写成 <code>Exception</code> 类型即可。</li>
<li><code>throws</code> 异常<br>在函数名后写上 <code>throws Exception</code> 即可。</li>
</ul>
<p>注意上述两种方式的异常并没有得到处理，仅仅是装成处理了的样子，该引发运行时程序异常中止时还是会引发。</p>
<h3 id="1-UDP通信"><a href="#1-UDP通信" class="headerlink" title="(1) UDP通信"></a><strong>(1) UDP通信</strong></h3><h4 id="1-DatagramPacket-类"><a href="#1-DatagramPacket-类" class="headerlink" title="1. DatagramPacket 类"></a><strong>1. <code>DatagramPacket</code> 类</strong></h4><p><code>DatagramPacket</code> 类定义在 <code>java.net.DatagramPacket</code> 包下。该类用于打包要发送的数据或用于接收数据。它有两个常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于包装要发送的数据</span></span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] 数据, <span class="type">int</span> 起始索引, <span class="type">int</span> 数据长度, InetAddress 目标地址, <span class="type">int</span> 目标端口)</span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] 数据, <span class="type">int</span> 数据长度, InetAddress 目标地址, <span class="type">int</span> 目标端口)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于接收数据</span></span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] 数据, <span class="type">int</span> 数据长度)</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>InetAddress</code> 类</strong></div>

<div style="color:royalblue;"><code>InetAddress</code> 类定义在 <code>java.net.InetAddress</code> 包中，它是一个用于存储IP地址的类。该类只有一个 <code>private</code> 的构造函数，这意味着不能使用构造函数来创建该类的对象。常用的创建该类对象的方法有：</div>

<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getByName()</code></td>
<td align="center"><code>String</code> （域名）</td>
<td align="center">生成一个 <code>InetAddress</code> 对象</td>
<td align="center"><code>InetAddress</code></td>
</tr>
<tr>
<td align="center"><code>getByAddress()</code></td>
<td align="center"><code>byte[]</code> （IP地址）</td>
<td align="center">生成一个 <code>InetAddress</code> 对象</td>
<td align="center"><code>InetAddress</code></td>
</tr>
<tr>
<td align="center"><code>getByAddress()</code></td>
<td align="center">域名，IP地址</td>
<td align="center">生成一个 <code>InetAddress</code> 对象</td>
<td align="center"><code>InetAddress</code></td>
</tr>
<tr>
<td align="center"><code>getData()</code></td>
<td align="center">无</td>
<td align="center">返回数据</td>
<td align="center"><code>bytes[]</code></td>
</tr>
</tbody></table>
<div style="text-align:center;color:red;">※域名可以直接写IP地址</div>

<div style="color:royalblue;">它们都是 <code>static</code> 的。</div>
</div>

<h4 id="2-DatagramSocket-类"><a href="#2-DatagramSocket-类" class="headerlink" title="2. DatagramSocket 类"></a><strong>2. <code>DatagramSocket</code> 类</strong></h4><p>在Java中， <code>DatagramSocket</code> 是一个实现了UDP协议的类，它定义在 <code>java.net.DatagramSocket</code> 类中。它既可以发送数据，也可以接收数据。它有如下常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定要监听的端口</span></span><br><span class="line">DatagramSocket(<span class="type">int</span> 端口)</span><br></pre></td></tr></table></figure>

<p>这里只介绍 <code>DatagramSocket</code> 类最基础的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>send()</code></td>
<td align="center"><code>InetAddress</code> 对象</td>
<td align="center">发送数据包</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>receive()</code></td>
<td align="center"><code>InetAddress</code> 对象</td>
<td align="center">指定用于接收数据的数据包，阻塞式</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>close()</code></td>
<td align="center">无</td>
<td align="center">关闭这个Socket</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h4 id="3-一种UDP的实现"><a href="#3-一种UDP的实现" class="headerlink" title="3. 一种UDP的实现"></a><strong>3. 一种UDP的实现</strong></h4><p>功能：子线程开始监听11451端口后，主线程开始接收来自控制台的输入，并将其打包发送到本机的11451端口。子线程接收到信息后将会打印该信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子线程开始</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">Server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Receiver</span>());</span><br><span class="line">        Server.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收控制台输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">Input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">byte</span>[] Information = Input.nextLine().getBytes();</span><br><span class="line">        Input.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打包数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">Request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(Information,</span><br><span class="line">                Information.length,</span><br><span class="line">                InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">                <span class="number">11451</span>);</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">Client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        Client.send(Request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        Client.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending Finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子线程不能直接throws错误，必须使用try块</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听11451端口</span></span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">Listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">11451</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置大小为4KB的接收缓冲区</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">Request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>], <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开始监听</span></span><br><span class="line">            Listener.receive(Request);</span><br><span class="line">            System.out.println(<span class="string">&quot;Server Accept: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(Request.getData()));</span><br><span class="line">            Listener.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Something is wrong.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-TCP通信"><a href="#2-TCP通信" class="headerlink" title="(2) TCP通信"></a><strong>(2) TCP通信</strong></h3><p>Java中与TCP相关的类有两个： <code>Socket</code> 类和 <code>ServerSocket</code> 类。前者用于客户端发送 &#x2F; 接收信息，后者用于服务端处理请求。</p>
<h4 id="1-Socket"><a href="#1-Socket" class="headerlink" title="1. Socket"></a><strong>1. <code>Socket</code></strong></h4><p>该类定义在 <code>java.net.Socket</code> 包内。该类有两个常用的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket(String 域名, <span class="type">int</span> 端口)</span><br><span class="line">Socket(InetAddress 对象, <span class="type">int</span> 端口)</span><br></pre></td></tr></table></figure>

<p><code>Socket</code> 类的常用方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>getOutputStream()</code></td>
<td align="center">无</td>
<td align="center">返回一个输出流</td>
<td align="center"><code>OutputStream</code></td>
</tr>
<tr>
<td align="center"><code>getInputStream()</code></td>
<td align="center">无</td>
<td align="center">返回一个输入流</td>
<td align="center"><code>InputStream</code></td>
</tr>
</tbody></table>
<p>这两个方法可用于发送和接收数据，返回的流可以通过之前的方式向其中写入数据 &#x2F; 读取其中的数据。</p>
<h4 id="2-ServerSocket"><a href="#2-ServerSocket" class="headerlink" title="2. ServerSocket"></a><strong>2. <code>ServerSocket</code></strong></h4><p>该类定义在 <code>java.net.ServerSocket</code> 包下。这里就极简介绍下这个类的关键方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ServerSocket(<span class="type">int</span> 端口号)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>accept()</code></td>
<td align="center">无</td>
<td align="center">接收TCP请求，并返回一个套接字对象</td>
<td align="center"><code>Socket</code></td>
</tr>
</tbody></table>
<p><code>accept()</code> 方法是阻塞的，未接收到请求的时候程序将一直阻塞于此。有了 <code>Socket</code> 对象以后，就可以直接与发起TCP的客户端进行数据传输。</p>
<h4 id="3-一种TCP的实现"><a href="#3-一种TCP的实现" class="headerlink" title="3. 一种TCP的实现"></a><strong>3. 一种TCP的实现</strong></h4><p>功能：子线程开始监听11451端口后，主线程开始接收来自控制台的输入，并将其打包发送到本机的11451端口。子线程接收到信息后将会打印该信息，并向主线程发送“Information from server.”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainProgram</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">Server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Receiver</span>());</span><br><span class="line">        Server.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置套接字</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">Client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">11451</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成发送与接收信息的输出与输入流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">Put</span> <span class="operator">=</span> Client.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">Get</span> <span class="operator">=</span> Client.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收键盘输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">KeyboardInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for input :&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为byte[]数组方便发送</span></span><br><span class="line">        <span class="type">byte</span>[] Information = KeyboardInput.nextLine().getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送信息</span></span><br><span class="line">        Put.write(Information, <span class="number">0</span>, Information.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量重新赋值，变成缓冲区</span></span><br><span class="line">        Information = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据并打印</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">Length</span> <span class="operator">=</span> Get.read(Information, <span class="number">0</span>, <span class="number">4096</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Client got information : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(Information, <span class="number">0</span>, Length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 善后处理</span></span><br><span class="line">        KeyboardInput.close();</span><br><span class="line">        Get.close();</span><br><span class="line">        Put.close();</span><br><span class="line">        Client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建服务端</span></span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">Listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">11451</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等候来自主线程的TCP连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">Server</span> <span class="operator">=</span> Listener.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取输入与输出流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">Get</span> <span class="operator">=</span> Server.getInputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">Put</span> <span class="operator">=</span> Server.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置缓冲区，并接收数据</span></span><br><span class="line">            <span class="type">byte</span>[] Buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">Length</span> <span class="operator">=</span> Get.read(Buffer, <span class="number">0</span>, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印数据，并发回确认信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Server got information : &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(Buffer, <span class="number">0</span>, Length));</span><br><span class="line">            Buffer = <span class="string">&quot;Information from server.&quot;</span>.getBytes();</span><br><span class="line">            Put.write(Buffer, <span class="number">0</span>, Buffer.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 善后处理</span></span><br><span class="line">            Put.close();</span><br><span class="line">            Get.close();</span><br><span class="line">            Listener.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Something is wrong.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">至此Java的基础部分就结束了。请注意，本文对lambda表达式、反射以及GUI编程只字未提，也并未涉及Java的一个重要框架Spring。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Java语法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2022/01/27/JavaScriptGrammar/</url>
    <content><![CDATA[<img src="/2022/01/27/JavaScriptGrammar/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言（最好是C/C++/C#）的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>JavaScript是一门面向对象的解释型语言，这意味着它并不需要经过编译生成可执行文件就可以直接运行。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>解释器</strong></div>

<div style="color:royalblue;">像Python需要一个解释器一样，JavaScript也需要一个解释器。浏览器自带的解释器可以执行.js文件，但如果想直接运行脚本，最好安装Node.js。推荐使用NVM安装Node.js。</div>
</div>

<p>另外，JavaScript对变量类型的要求也不严格，这一点与Python类似。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>弱类型语言の痛</strong></div>

<div style="color:royalblue;">虽然不需要明确变量类型带来了很多好处，但它致命的坏处就在于你可能会遇到很多由于隐式类型转换带来的令人困惑的错误，尤其是你的代码非常多的时候。</div>
</div>

<p>在JavaScript中，你能看到很多熟悉的语法，例如for、while、switch等。其中与C&#x2F;C++&#x2F;C#相似的语法本文只会简略提及，而着重于叙述与C&#x2F;C++&#x2F;C#的不相似之处与JavaScript的语法细节。</p>
<h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a><strong>二、变量</strong></h2><p>与C#类似，JavaScript的所有类型均继承自Object。</p>
<h3 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="(1) 定义变量"></a><strong>(1) 定义变量</strong></h3><p>JavaScript对变量的类型要求并不严格，因此定义变量时也像Python一样比较随意。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">StringType</span> = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IntType</span> = <span class="number">114514</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">FloatType</span> = <span class="number">114.514</span>;</span><br></pre></td></tr></table></figure>

<p>使用var关键字就能够定义变量，并且解释器会自动帮你判断这个变量属于哪种类型。</p>
<h3 id="2-变量的类型"><a href="#2-变量的类型" class="headerlink" title="(2) 变量的类型"></a><strong>(2) 变量的类型</strong></h3><div class="tabs" id="variabletypes"><ul class="nav-tabs"><li class="tab active"><a href="#variabletypes-1">string类型</a></li><li class="tab"><a href="#variabletypes-2">number类型</a></li><li class="tab"><a href="#variabletypes-3">boolean类型</a></li><li class="tab"><a href="#variabletypes-4">undefined类型</a></li><li class="tab"><a href="#variabletypes-5">object类型</a></li></ul><div class="tab-content"><div class="tab-pane active" id="variabletypes-1"><p>string类型的变量与C++的string行为基本一致，可以通过variable[i]来特定第i+1个字符。但即便是单个字符也属于字符串类型，没有char类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a[2] is &quot;</span> + (<span class="keyword">typeof</span> (a[<span class="number">2</span>])));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a[2]= &quot;</span> + a[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">type of a is string</span><br><span class="line">a = Lacia</span><br><span class="line">type of a[2] is string</span><br><span class="line">a[2]= c</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="variabletypes-2"><p>number类型的变量能够存储整数与浮点数。能存储的最大值为Number.MAX_VALUE，最小值为Number.MIN_VALUE。超出最大值的将被视为Infinity（无限）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="number">1</span>;  <span class="comment">//让b溢出</span></span><br><span class="line"><span class="keyword">var</span> c = a * <span class="number">2</span>;  <span class="comment">//让c大量溢出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of b is &quot;</span> + (<span class="keyword">typeof</span> b));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of c is &quot;</span> + (<span class="keyword">typeof</span> c));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c = &quot;</span> + c);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">type of a is number</span><br><span class="line">a = 1.7976931348623157e+308</span><br><span class="line">type of b is number</span><br><span class="line">b = 1.7976931348623157e+308  &lt;===没有溢出</span><br><span class="line">type of c is number</span><br><span class="line">c = Infinity</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>为何b没有溢出</strong></div>

<div style="color:royalblue;">上述例子中b的值并没有溢出成为Infinity，是因为b采用了浮点数的计数方式。</div>
</div>

<p>与C&#x2F;C++一样，JavaScript的浮点数同样存在精度缺陷。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">var</span> c = a + b;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c = &quot;</span> + c);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 0.1</span><br><span class="line">b = 0.2</span><br><span class="line">c = 0.30000000000000004  &lt;===精度缺陷</span><br></pre></td></tr></table></figure>

<p>JavaScript中还有一种特殊的属于number类型的值，它被定义为NaN（Not a Number）。将不含有数字的string强制转换为number时就会看到这个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">parseInt</span>(a);  <span class="comment">//此函数下文会详细讲解</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of b is &quot;</span> + (<span class="keyword">typeof</span> b));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of c is &quot;</span> + (<span class="keyword">typeof</span> c));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c = &quot;</span> + c);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">type of a is string</span><br><span class="line">a = Lacia</span><br><span class="line">type of b is number  &lt;===转换成功</span><br><span class="line">b = NaN              &lt;===值为NaN，不是数字</span><br><span class="line">type of c is number</span><br><span class="line">c = NaN</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="variabletypes-3"><p>boolean类型即为C&#x2F;C++&#x2F;C#中的bool类型，仅有true与false两个值，行为也与C&#x2F;C++&#x2F;C#大体一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of b is &quot;</span> + (<span class="keyword">typeof</span> b));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">type of a is boolean</span><br><span class="line">a = true</span><br><span class="line">type of b is boolean</span><br><span class="line">b = false</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="variabletypes-4"><p>所有定义了却未初始化或赋值的变量均属于此类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;  <span class="comment">//a未初始化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">a = <span class="number">1</span>;  <span class="comment">//对a赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">type of a is undefined</span><br><span class="line">a = undefined</span><br><span class="line">type of a is number</span><br><span class="line">a = 1</span><br></pre></td></tr></table></figure>

<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>一定要初始化！</strong></div>

<div style="color:darkred;">undefined的变量是很危险的。你应该时刻注意你的变量有没有初始化。</div>
</div></div><div class="tab-pane" id="variabletypes-5"><p>所有的类型均继承自object类。object类有一种特殊的值，定义为null（空值）。使用__proto__可以查看变量类型的父类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">114514</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;father of b is &quot;</span> + (<span class="keyword">typeof</span> b.<span class="property">__proto__</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;father of c is &quot;</span> + (<span class="keyword">typeof</span> c.<span class="property">__proto__</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;father of d is &quot;</span> + (<span class="keyword">typeof</span> d.<span class="property">__proto__</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">type of a is object</span><br><span class="line">father of b is object</span><br><span class="line">father of c is object</span><br><span class="line">father of d is object</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="3-显式类型转换"><a href="#3-显式类型转换" class="headerlink" title="(3) 显式类型转换"></a><strong>(3) 显式类型转换</strong></h3><div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>检验变量</strong></div>

<div style="color:goldenrod;">在对变量进行操作前，你应该确保你的变量是正确的类型或正确的值。</div>
</div>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>关于比较</strong></div>

<div style="color:royalblue;">在JavaScript中，存在“===”与“!==”。它们与“==”和“!=”的功能类似，只不过前者禁止了隐式类型转换，类型不一致时会直接返回false；而后者会做隐式类型转换，转换完之后的值再进行比较。</div>
</div>

<p>使用typeof关键字可以查询某个变量的类型。上文的代码样例已经描述了如何使用typeof，此处就不再赘述。</p>
<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>NaN的判断</strong></div>

<div style="color:darkred;">NaN是一个特殊的number值，而它是很危险的：用variable == NaN检查变量是否为NaN时永远会返回false。你应该使用isNaN(variable)来检查变量是否为NaN。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a == NaN is &quot;</span> + (a == <span class="title class_">NaN</span>));  <span class="comment">//反面教材</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;isNaN(a) is &quot;</span> + <span class="built_in">isNaN</span>(a));  <span class="comment">//正面教材</span></span><br></pre></td></tr></table></figure>

<div style="color:darkred;">输出结果为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a == NaN is false  &lt;===“NaN不等于NaN”</span><br><span class="line">isNaN(a) is true</span><br></pre></td></tr></table></figure>
</div>

<div class="tabs" id="variabletypeconvert"><ul class="nav-tabs"><li class="tab active"><a href="#variabletypeconvert-1">转换为string</a></li><li class="tab"><a href="#variabletypeconvert-2">转换为number</a></li><li class="tab"><a href="#variabletypeconvert-3">转换为boolean</a></li></ul><div class="tab-content"><div class="tab-pane active" id="variabletypeconvert-1"><p>有两种方式可以将变量转换为string类型。</p>
<ol>
<li>.toString()函数</li>
<li>String()函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">114514</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">toString</span>();</span><br><span class="line"><span class="keyword">var</span> c = <span class="title class_">String</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of b is &quot;</span> + (<span class="keyword">typeof</span> b));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of c is &quot;</span> + (<span class="keyword">typeof</span> c));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c = &quot;</span> + c);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">type of a is number</span><br><span class="line">a = 114514</span><br><span class="line">type of b is string</span><br><span class="line">b = 114514</span><br><span class="line">type of c is string</span><br><span class="line">c = 114514</span><br></pre></td></tr></table></figure>

<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>.toString()是不安全的</strong></div>

<div style="color:darkred;">.toString()存在缺陷。如果变量为null或者undefined，.toString()会直接导致运行时报错。String()虽然是基于.toString()的，但String()会提前检测变量类型与值，如果为null则赋值“null”，如果为undefined则赋值“undefined”。</div>
</div></div><div class="tab-pane" id="variabletypeconvert-2"><p>有三种方式可以将变量转换为number类型。</p>
<ol>
<li>Number()函数：含有非数字的字符、变量为undefined则转换为NaN；空字符串、null转换为0。true转换为1，false转换为0。</li>
<li>parseInt()函数：遇到第一个非数字字符则停止转换。字符串第一个字符非数字、true和false均转换为NaN。</li>
<li>parseFloat()函数：遇到除了“.”以外的第一个非数字字符则停止转换，第二次遇到“.”也停止转换。字符串第一个字符非数字也非“.”、true和false均转换为NaN。</li>
</ol></div><div class="tab-pane" id="variabletypeconvert-3"><p>仅有一种方式能将变量转换为number类型。</p>
<ul>
<li>Boolean()函数：仅有0、NaN、null和空字符串会被转换为false，其余全为true。</li>
</ul></div></div></div>

<h2 id="三、控制流"><a href="#三、控制流" class="headerlink" title="三、控制流"></a><strong>三、控制流</strong></h2><p>不论是for、while还是switch、if，其基础语法均与C&#x2F;C++一致，也存在continue与break。不过JavaScript的for还可以用类似C#的foreach的语法，不过却略有不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Name</span> = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> output = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> temp <span class="keyword">in</span> <span class="title class_">Name</span>)</span><br><span class="line">&#123;</span><br><span class="line">    output += <span class="title class_">String</span>(temp);  <span class="comment">//直接使用temp</span></span><br><span class="line">    <span class="comment">//将输出加到一个字符串内再输出</span></span><br><span class="line">    <span class="comment">//因为屑JavaScript没有不换行的输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output);</span><br><span class="line">output = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> temp <span class="keyword">in</span> <span class="title class_">Name</span>)</span><br><span class="line">&#123;</span><br><span class="line">    output += <span class="title class_">String</span>(<span class="title class_">Name</span>[temp]);  <span class="comment">//使用temp作为索引</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">01234   &lt;===输出的并非Name中的字符</span><br><span class="line">Lacia</span><br></pre></td></tr></table></figure>

<p>不难看出temp只是Name的单个字符的索引值，而非Name内的字符。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>关于temp值的异常现象</strong></div>

<div style="color:royalblue;">关于为什么直接使用temp不会输出Name中的字符，面向对象章节将会解释。</div>
</div>

<p>本文假定读者有学习过其它编程语言的基础，关于控制流此处就不再过多赘述。</p>
<h2 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a><strong>四、函数</strong></h2><p>JavaScript中函数也属于一种类型——function类。因此函数也具有一些对象的特征。关于这部分将在面向对象章节中的方法一节详述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));  <span class="comment">//查看a的类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);  <span class="comment">//尝试直接输出a</span></span><br><span class="line"><span class="title function_">a</span>();  <span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">type of a is function   &lt;===a为function类</span><br><span class="line">a = function a()   &lt;===输出了a的定义</span><br><span class="line">&#123;</span><br><span class="line">    console.log(&quot;Hello, world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Hello, world!   &lt;===成功调用函数</span><br></pre></td></tr></table></figure>

<p>另一种定义函数的方式则有点像定义变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然你也可以在定义函数时在括号内写入参数，但请记得不要写变量类型——这是JavaScript，不是C&#x2F;C++。</p>
<p>JavaScript定义函数的其它基础部分也与C&#x2F;C++没有什么太大的差异，此处也不过多赘述。</p>
<h2 id="五、面向对象"><a href="#五、面向对象" class="headerlink" title="五、面向对象"></a><strong>五、面向对象</strong></h2><p>JavaScript中存在this。学过C&#x2F;C++&#x2F;C#的应该已经明白了。this指针（但JavaScript里不存在指针，此处仅仅是借用C&#x2F;C++&#x2F;C#中的概念）指向的是调用当前函数或方法的对象。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>面向对象与JavaScript的环境</strong></div>

<div style="color:royalblue;">在面向对象的编程思想中，变量被称为对象；对象的成员函数被称为方法；对象的成员变量被称为属性。在JavaScript中，用户编写的脚本将由运行环境定义的一个对象调用。在定义变量时，其实就是在给调用这段代码的对象添加属性。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this = &quot;</span> + <span class="variable language_">this</span>);  <span class="comment">//请注意这里会将this隐式转换为string类型</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">在Node.js环境下运行，结果为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">this = [object Object]   &lt;===调用代码的对象名为Object，属于object类</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">将代码嵌入html</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this = &quot;</span> + <span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">使用浏览器打开，查看控制台的输出</div>

<p><img src="/2022/01/27/JavaScriptGrammar/1.png" alt="1 1" title="1"></p>
<div style="color:royalblue;">调用代码的对象名为Window，属于object类。</div>
</div>

<p>JavaScript中的对象有三种类型</p>
<ol>
<li>内建对象，JavaScript标准下定义的对象，符合该标准的环境都自带，如Math、Function、String等。</li>
<li>宿主对象，由运行环境提供的对象，如浏览器提供了一个Window对象。</li>
<li>自定义对象：由用户定义的对象。</li>
</ol>
<h3 id="1-自定义对象"><a href="#1-自定义对象" class="headerlink" title="(1) 自定义对象"></a><strong>(1) 自定义对象</strong></h3><h4 id="Ⅰ-直接创建"><a href="#Ⅰ-直接创建" class="headerlink" title="Ⅰ. 直接创建"></a><strong>Ⅰ. 直接创建</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>,  <span class="comment">//请注意使用的是“:”而非“=”，是“,”而非“;”</span></span><br><span class="line">    <span class="title class_">Age</span>: <span class="number">17</span>,</span><br><span class="line">    <span class="title class_">Type</span>: <span class="string">&quot;Type-005&quot;</span>  <span class="comment">//最后一项可以不加“,”，加了也是正确的语法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要想追加、删除或查询对象中的属性，可以直接使用如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.<span class="property">NewItem0</span> = <span class="number">114514</span>;  <span class="comment">//新增属性NewItem0</span></span><br><span class="line">a[<span class="string">&quot;NewItem1&quot;</span>] = <span class="number">1919810</span>;  <span class="comment">//新增属性NewItem1，不推荐使用这种方式</span></span><br><span class="line"><span class="keyword">delete</span> a.<span class="property">Type</span>;  <span class="comment">//删除Type属性</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;NewItem0&quot;</span> <span class="keyword">in</span> a;  <span class="comment">//如果NewItem0是a已有的属性则返回true，否则返回false</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;Type&quot;</span> <span class="keyword">in</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;NewItem0 in a is &quot;</span> + b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Type in a is &quot;</span> + c);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = [object Object]</span><br><span class="line">&#123; Name: &#x27;Lacia&#x27;, Age: 17, NewItem0: 114514, NewItem1: 1919810 &#125;  &lt;===输出了a的所有属性及其值</span><br><span class="line">NewItem0 in a is true     &lt;===属性NewItem0被添加进了对象a中</span><br><span class="line">Type in a is false     &lt;===Type属性被删除了</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>JavaScript对象的特点</strong></div>

<div style="color:royalblue;">JavaScript中对象的属性与值类似于C++的STL中的map、C#与Python的字典。属性名只能有一个同名，值则可以任意。在添加新的属性与检查属性时，属性名需要打双引号，以字符串的形式传入，代表这是一个属性名；或者将属性名保存至变量中，直接传入变量。使用for in循环时，临时变量的值将会是属性名而非其值。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>,</span><br><span class="line">    <span class="title class_">Age</span>: <span class="number">17</span>,</span><br><span class="line">    <span class="title class_">Type</span>: <span class="string">&quot;Type-005&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> temp <span class="keyword">in</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(temp);  <span class="comment">//直接输出temp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Name     &lt;===输出了a的属性名</span><br><span class="line">Age</span><br><span class="line">Type</span><br></pre></td></tr></table></figure>
</div>

<p>调用对象内的属性的语法与C++&#x2F;C#一致，此处不再赘述。</p>
<h4 id="Ⅱ-构造函数"><a href="#Ⅱ-构造函数" class="headerlink" title="Ⅱ. 构造函数"></a><strong>Ⅱ. 构造函数</strong></h4><p>利用上文提到的this指针、与JavaScript的关键字new，就能创建一个新的对象。一般构造函数的名字，就是该类的名字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HIE</span>(<span class="params">name,age,type</span>)  <span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Type</span> = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="number">17</span>, <span class="string">&quot;Type-005&quot;</span>);</span><br><span class="line"><span class="comment">//新建对象</span></span><br></pre></td></tr></table></figure>

<p>新建对象的方式非常像C#。具体过程为：</p>
<ol>
<li>new关键字，给Lacia创建一个新的空对象。</li>
<li>HIE()构造函数，Lacia将会调用它。</li>
<li>HIE()中的this指针，指向了调用这个代码的对象——Lacia。</li>
<li>使用this指针为Lacia新建对象。</li>
</ol>
<h4 id="Ⅲ-判断类型"><a href="#Ⅲ-判断类型" class="headerlink" title="Ⅲ. 判断类型"></a><strong>Ⅲ. 判断类型</strong></h4><p>判断某个对象是否属于某个类，可以用instanceof关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HIE</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">temp</span> = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">HIE</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="variable constant_">HIE</span>);</span><br><span class="line"><span class="comment">//判断a是否为HIE的一个对象（实例）</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h4 id="Ⅳ-判断对象是否含有属性"><a href="#Ⅳ-判断对象是否含有属性" class="headerlink" title="Ⅳ. 判断对象是否含有属性"></a><strong>Ⅳ. 判断对象是否含有属性</strong></h4><p>判断对象中是否有属性，可以使用hasOwnProperty()方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HIE</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">temp</span> = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">HIE</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;temp&quot;</span>));</span><br><span class="line"><span class="comment">//检查对象a是否含有属性temp</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line"><span class="comment">//检查对象a是否含有属性Name</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">true  &lt;===含有属性temp</span><br><span class="line">false  &lt;===不含属性Name</span><br></pre></td></tr></table></figure>

<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>不要使用in关键字或检查undefined</strong></div>

<div style="color:darkred;">虽然未定义的属性，其值确实为undefined；用in关键字检查也会返回false。但是定义在原型对象中却没定义在对象中的属性不会返回undefined，in关键字也会返回true。关于原型对象，下面即将介绍。</div>
</div>

<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="(2) 方法"></a><strong>(2) 方法</strong></h3><p>有属性（成员变量），自然也就有方法（成员函数）。根据上文的描述，不难推测出方法可以有如下的添加方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式：像属性一样添加</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Call</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">a.<span class="property">Call</span> = <span class="title class_">Call</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式：通过构造函数添加</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Constructor0</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Call</span> = <span class="title class_">Call</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Constructor0</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式：构造函数内定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Constructor1</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Call</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">Constructor1</span>();</span><br></pre></td></tr></table></figure>

<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>没有正确答案</strong></div>

<div style="color:darkred;">以上三种方式均不合适。第一种方式每新建一个对象就得添加一次；第二种方式将方法的定义放在了外部，污染了变量名/函数名空间；第三种方式每创建一个变量就得创建一个新的函数，浪费内存空间。下文将详述解决方法</div>
</div>

<h4 id="Ⅰ-原型对象"><a href="#Ⅰ-原型对象" class="headerlink" title="Ⅰ. 原型对象"></a><strong>Ⅰ. 原型对象</strong></h4><p>要想解决方法的问题，首先要理解原型对象。<br>JavaScript的function类中，含有一个名为prototype的属性，这个属性指向了函数的原型对象：如果将这个函数作为构造函数新建对象，那么新建对象的原型对象就是函数的原型对象。</p>
<div style="color:red;">原型对象只有一个。</div>

<pre class="mermaid">
classDiagram
对象1 --|&gt; 原型对象 : __proto__
对象2 --|&gt; 原型对象 : __proto__
对象3 --|&gt; 原型对象 : __proto__
构造函数 --|&gt; 原型对象 : prototype
构造函数 .. 对象1
构造函数 .. 对象2
构造函数 .. 对象3
class 构造函数{
    prototype
}
class 原型对象
class 对象1{
    __proto__
}
class 对象2{
    __proto__
}
class 对象3{
    __proto__
}
</pre>

<p>上面的图很好地解释了原型对象、对象、构造函数的关系。不论对象有多少个，原型对象和构造函数只有一个，对象的__proto__属性永远指向原型对象，构造函数的prototype属性永远指向原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Constructor</span>(<span class="params"></span>)  <span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">temp</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Constructor</span>();  <span class="comment">//新建对象a</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Constructor</span>();  <span class="comment">//新建对象b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span> == <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">//a的原型对象与构造函数的原型对象是否为同一个？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span> == b.<span class="property">__proto__</span>);</span><br><span class="line"><span class="comment">//a的原型对象与b的原型对象是否为同一个？</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">true</span><br><span class="line">true   &lt;===均为同一个</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ-对象寻找属性的机制"><a href="#Ⅱ-对象寻找属性的机制" class="headerlink" title="Ⅱ. 对象寻找属性的机制"></a><strong>Ⅱ. 对象寻找属性的机制</strong></h4><p>当对象寻找属性的时候，首先会访问自身的属性列表。如果自身的属性列表不存在此属性，那么就在原型对象属性列表中寻找。原型对象的属性列表中不存在，那么就会在原型对象的原型对象中寻找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Constructor</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">temp</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line"><span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">Item</span> = <span class="number">114514</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a.Item = &quot;</span> + a.<span class="property">Item</span>);</span><br><span class="line"><span class="comment">//只在原型对象中定义了Item</span></span><br><span class="line">a.<span class="property">Item</span> = <span class="string">&quot;1919810&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a.Item = &quot;</span> + a.<span class="property">Item</span>);</span><br><span class="line"><span class="comment">//在a中定义了Item，输出时不会访问到原型对象中的Item</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b.Item = &quot;</span> + b.<span class="property">Item</span>);</span><br><span class="line"><span class="comment">//b中未定义Item，仍然访问原型中的Item</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a.Item = 114514  &lt;===原型对象中的Item</span><br><span class="line">a.Item = 1919810  &lt;===a的Item</span><br><span class="line">b.Item = 114514  &lt;===原型对象中的Item并未被覆盖</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>原型对象的原型对象</strong></div>

<div style="color:royalblue;">原型对象也存在原型对象</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Constructor</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">temp</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>.<span class="property">__proto__</span>);</span><br><span class="line"><span class="comment">//查看原型对象的原型对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>.<span class="property">__proto__</span> == <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">[Object: null prototype] &#123;&#125;</span><br><span class="line">[Object: null prototype] &#123;&#125;</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
</div>

<h4 id="Ⅲ-正确地定义方法"><a href="#Ⅲ-正确地定义方法" class="headerlink" title="Ⅲ. 正确地定义方法"></a><strong>Ⅲ. 正确地定义方法</strong></h4><p>知道了原型对象，那么也就方便定义方法了。<br>单刀直入地讲，就是将方法定义到原型对象中。当执行对象的方法时，在成员本身中没有找到这个函数名，就会到原型对象中寻找。原型对象只有一个，因此也就不存在浪费内存的问题了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HIE</span>(<span class="params">name,age</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">Age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable constant_">HIE</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">Speak</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">Name</span> + <span class="string">&quot;, and I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">Age</span> + <span class="string">&quot;years old.&quot;</span>);</span><br><span class="line">&#125;;<span class="comment">//将方法定义到原型对象中</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Lacia</span> = <span class="keyword">new</span> <span class="title function_">HIE</span>(<span class="string">&quot;Lacia&quot;</span>, <span class="number">17</span>);</span><br><span class="line"><span class="title class_">Lacia</span>.<span class="title class_">Speak</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">My name is Lacia, and I&#x27;m 17years old.</span><br></pre></td></tr></table></figure>

<p>对于一些需要共享某个属性的、属于同一类的自定义对象，也可以将属性定义到原型对象中。比如这个用类创建了多少个对象等。</p>
<h3 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="(3) 垃圾回收"></a><strong>(3) 垃圾回收</strong></h3><p>与Java、C#类似，JavaScript创建的对象占用的内存空间并不会自动回收。但浏览器已经非常智能化了，只要你给对象赋值null，浏览器就知道这个是不需要的变量，会自动清理它所占用的内存空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="literal">null</span>;  <span class="comment">//垃圾回收</span></span><br></pre></td></tr></table></figure>

<h3 id="4-内建对象"><a href="#4-内建对象" class="headerlink" title="(4) 内建对象"></a><strong>(4) 内建对象</strong></h3><p>只要是符合相应标准的环境，就都会存在相应的内建对象。</p>
<h4 id="Ⅰ-数组（Array）"><a href="#Ⅰ-数组（Array）" class="headerlink" title="Ⅰ. 数组（Array）"></a><strong>Ⅰ. 数组（Array）</strong></h4><h5 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a><strong>数组的创建</strong></h5><p>与C&#x2F;C++&#x2F;C#的数组概念很接近，但JavaScript的数组能存储任意类型的值，包括函数。它的使用方式像Python一样非常简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];  <span class="comment">//创建数组</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">114.514</span>;  <span class="comment">//a[0]没有赋值</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1919810</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type of a is &quot;</span> + (<span class="keyword">typeof</span> a));</span><br><span class="line"><span class="comment">//查看a的类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a[2] = &quot;</span> + a[<span class="number">2</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a[0] = &quot;</span> + a[<span class="number">0</span>]);  <span class="comment">//检查a[0]的值</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">type of a is object   &lt;===a为object类型</span><br><span class="line">a = ,114.514,1919810,Lacia</span><br><span class="line">a[2] = 1919810</span><br><span class="line">a[0] = undefined   &lt;===a[0]的值为undefined</span><br></pre></td></tr></table></figure>

<p>也可以在创建的时候就进行初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114.514</span>, <span class="string">&quot;Lacia&quot;</span>];  <span class="comment">//创建时初始化</span></span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>另一种创建方式</strong></div>

<div style="color:royalblue;">Array也存在构造函数，你也可以用构造函数来创建Array对象。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>();  <span class="comment">//创建空数组</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">Array</span>(<span class="number">10</span>);  <span class="comment">//创建长度为10的空数组</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="title class_">Array</span>(<span class="number">10</span>, <span class="number">20</span>);  <span class="comment">//创建数组并初始化为[10,20]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c = &quot;</span> + c);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a =</span><br><span class="line">b = ,,,,,,,,,   &lt;===undefined的值将不会输出，因此只有逗号</span><br><span class="line">c = 10,20</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">虽然并不推荐这种创建方法，但还是需要知道这样写也能创建一个Array对象。</div>
</div>

<h5 id="数组的方法与属性"><a href="#数组的方法与属性" class="headerlink" title="数组的方法与属性"></a><strong>数组的方法与属性</strong></h5><p>数组对象也是通过构造函数构造的，因此数组的构造函数具有prototype属性，数组对象具有__proto__属性。上文已经阐述过这些概念了，此处不再赘述。</p>
<div class="tabs" id="arraymethods"><ul class="nav-tabs"><li class="tab active"><a href="#arraymethods-1">length</a></li><li class="tab"><a href="#arraymethods-2">push(···)</a></li><li class="tab"><a href="#arraymethods-3">pop()</a></li><li class="tab"><a href="#arraymethods-4">unshift(···)</a></li><li class="tab"><a href="#arraymethods-5">shift()</a></li><li class="tab"><a href="#arraymethods-6">forEach(function)</a></li><li class="tab"><a href="#arraymethods-7">slice(i,j)</a></li><li class="tab"><a href="#arraymethods-8">splice(i,j,···)</a></li><li class="tab"><a href="#arraymethods-9">contact(···)</a></li><li class="tab"><a href="#arraymethods-10">join(string)</a></li><li class="tab"><a href="#arraymethods-11">reverse()</a></li><li class="tab"><a href="#arraymethods-12">sort(function)</a></li><li class="tab"><a href="#arraymethods-13">filter(function)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="arraymethods-1"><p>在JavaScript中，数组的长度为数组中所有元素索引值的最大值，即：最后一个元素的序号+1（从0开始计数）。</p>
<p>length属性为数组的长度，且这个值可以被修改。如果大于原值，则会在数组末尾增加undefined的元素；如果小于原值，则会将数组末尾多余的元素全部删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">114514</span>;  <span class="comment">//未定义0~9的元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a[0] = &quot;</span> + a[<span class="number">0</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a[10] = &quot;</span> + a[<span class="number">10</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a.length = &quot;</span> + a.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a[0] = undefined</span><br><span class="line">a[10] = 114514</span><br><span class="line">a.length = 11    &lt;===length的值不是数组中有多少元素</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>永远向末尾添加元素</strong></div>

<div style="color:royalblue;">最好不要让数组中存在undefined的元素。你可以巧妙地利用length属性以向数组中添加元素。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a[a.<span class="property">length</span>] = <span class="number">114514</span>;</span><br><span class="line">a[a.<span class="property">length</span>] = <span class="number">1919810</span>;</span><br><span class="line">a[a.<span class="property">length</span>] = <span class="string">&quot;Lacia&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114514,1919810,Lacia</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">当然也有其它方式能够永远向数组末尾添加元素——使用push()方法。</div>
</div></div><div class="tab-pane" id="arraymethods-2"><p>向原数组末尾添加一个或多个元素，并返回添加元素后数组的长度。</p>
<div style="color:red;">会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Kouka&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">push</span>(<span class="number">114514</span>, <span class="number">19.19</span>, <span class="string">&quot;Lacia&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = Method,Kouka,114514,19.19,Lacia</span><br><span class="line">b = 5</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-3"><p>删除原数组的最后一个元素，并返回这个元素的值。</p>
<div style="color:red;">会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114514</span>, <span class="number">19.19</span>, <span class="string">&quot;Lacia&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114514,19.19</span><br><span class="line">b = Lacia</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-4"><p>向原数组开头添加一个或多个元素，并返回添加元素后数组的长度。</p>
<div style="color:red;">会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Kouka&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">unshift</span>(<span class="number">114514</span>, <span class="number">19.19</span>, <span class="string">&quot;Lacia&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114514,19.19,Lacia,Method,Kouka</span><br><span class="line">b = 5</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-5"><p>删除原数组的第一个元素，并返回这个元素的值。</p>
<div style="color:red;">会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114514</span>, <span class="number">19.19</span>, <span class="string">&quot;Lacia&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">shift</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 19.19,Lacia</span><br><span class="line">b = 114514</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-6"><p>将数组中的每个元素都分别作为参数之一，调用作为参数的function函数。有多少个非undefined的元素，就调用多少次。<br>function函数参数的顺序为(元素，元素的索引值，原数组)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114514</span>, <span class="number">19.19</span>, <span class="string">&quot;Lacia&quot;</span>];</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">2</span>;   <span class="comment">//索引值为3~9的元素未定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a, b, c</span>)  <span class="comment">//定义要作为参数的函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot;, b = &quot;</span> + b + <span class="string">&quot;, c = &quot;</span> + c);</span><br><span class="line">&#125;</span><br><span class="line">a.<span class="title function_">forEach</span>(fun);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114514, b = 0, c = 114514,19.19,Lacia,,,,,,,,2</span><br><span class="line">a = 19.19, b = 1, c = 114514,19.19,Lacia,,,,,,,,2</span><br><span class="line">a = Lacia, b = 2, c = 114514,19.19,Lacia,,,,,,,,2</span><br><span class="line">a = 2, b = 10, c = 114514,19.19,Lacia,,,,,,,,2</span><br><span class="line">//函数只调用了4次，而非调用11次</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-7"><p>返回原数组中，从索引值为i（包含）到索引值为j（不包含）的元素组成的数组。参数j省略时则默认取到数组尾部最后一个元素。<br>像Python一样，i、j的值可以为负数。-1代表最后一个元素，-2代表倒数第二个元素，以此类推。</p>
<div style="color:red;">不会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114514</span>, <span class="number">1919810</span>, <span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Kouka&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">slice</span>(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">b = 1919810,Lacia,Method</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-8"><p>删除原数组中从索引为i的元素（包含）以及其之后的一共j个元素，并将它们返回。j为0时则不删除，返回空数组。<br>在这之后向原数组中从索引为i之前的位置插入新的元素。</p>
<div style="color:red;">会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114514</span>, <span class="number">1919810</span>, <span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Kouka&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">114</span>);</span><br><span class="line"><span class="comment">//删除索引为1的元素和其之后的元素，一共删2个</span></span><br><span class="line"><span class="comment">//也就是删除第2和第3个元素</span></span><br><span class="line"><span class="comment">//并在第二个元素之前插入后续的参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114514,A,B,114,Method,Kouka</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-9"><p>将原数组与作为参数的元素或数组连接成新的数组，并返回。</p>
<div style="color:red;">不会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Kouka&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">114</span>, <span class="number">514</span>];</span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1919</span>, <span class="number">810</span>];</span><br><span class="line"><span class="keyword">var</span> d = a.<span class="title function_">concat</span>(b, c, <span class="number">114514</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;d = &quot;</span> + d);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = Lacia,Method,Kouka</span><br><span class="line">d = Lacia,Method,Kouka,114,514,1919,810,114514</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-10"><p>将原数组的元素转换为字符串并拼接在一起，元素之间以string连接，并返回。<br>默认以“,”连接。</p>
<div style="color:red;">不会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Kouka&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c = &quot;</span> + c);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">b = 114|514|Lacia|Method|Kouka</span><br><span class="line">c = 114514LaciaMethodKouka</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-11"><p>反转原数组。</p>
<div style="color:red;">会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Kouka&quot;</span>];</span><br><span class="line">a.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = Kouka,Method,Lacia,514,114</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-12"><p>对原数组进行排序。默认以字符串、Unicode字符顺序来排序。<br>可以传入一个函数参数来修改其排序行为。作为参数的函数有两个参数，前者的索引值比后者小。如果函数返回值为正数则交换两个元素的位置，如果为负数则不交换两个元素的位置。等于0时默认不交换。</p>
<div style="color:red;">会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>, <span class="number">114514</span>, <span class="number">1919810</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun0</span>(<span class="params">a, b</span>)  <span class="comment">//从小到大排序</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params">a, b</span>)  <span class="comment">//从大到小排序</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;</span><br><span class="line">a.<span class="title function_">sort</span>(fun0);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">a.<span class="title function_">sort</span>(fun1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a = 114,514,810,1919,114514,1919810</span><br><span class="line">a = 1919810,114514,1919,810,514,114</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="arraymethods-13"><p>该方法对数组内的元素进行过滤，返回过滤的结果。传入的参数是一个函数。作为参数的函数应当有一个参数，它是数组内的元素，其返回值是 <code>boolean</code> 类型，为 <code>true</code> 则会保留该元素，为 <code>false</code> 则不保留。</p>
<div style="color:red;">不会影响原数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组，其存储的元素是对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">HIE</span> = [</span><br><span class="line">    &#123; <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-005&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="title class_">Name</span>: <span class="string">&quot;Kouka&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-001&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="title class_">Name</span>: <span class="string">&quot;Method&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-004&quot;</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行过滤</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="variable constant_">HIE</span>.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">element</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 若名字中含有字符“a”则保留</span></span><br><span class="line">    <span class="comment">// string类型的方法，indexOf()，传入一个子串</span></span><br><span class="line">    <span class="comment">// 若不含子串则返回-1，否则返回第一个子串的开始索引</span></span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">Name</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;a&quot;</span>) !== -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;temp =&quot;</span>, temp);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HIE =&quot;</span>, <span class="variable constant_">HIE</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">temp = [</span><br><span class="line">  &#123; Name: &#x27;Lacia&#x27;, Type: &#x27;Type-005&#x27; &#125;,</span><br><span class="line">  &#123; Name: &#x27;Kouka&#x27;, Type: &#x27;Type-001&#x27; &#125;</span><br><span class="line">]</span><br><span class="line">HIE = [</span><br><span class="line">  &#123; Name: &#x27;Lacia&#x27;, Type: &#x27;Type-005&#x27; &#125;,</span><br><span class="line">  &#123; Name: &#x27;Kouka&#x27;, Type: &#x27;Type-001&#x27; &#125;,</span><br><span class="line">  &#123; Name: &#x27;Method&#x27;, Type: &#x27;Type-004&#x27; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以看到原数组并未被改变，并且成功过滤掉了姓名中不含有“a”的元素。</p></div></div></div>

<h4 id="Ⅱ-函数（function）"><a href="#Ⅱ-函数（function）" class="headerlink" title="Ⅱ. 函数（function）"></a><strong>Ⅱ. 函数（function）</strong></h4><p>上文已经说明了，在JavaScript中，函数也是一种类。因此函数对象也有方法。</p>
<div class="tabs" id="functionmethods"><ul class="nav-tabs"><li class="tab active"><a href="#functionmethods-1">call(object,···)</a></li><li class="tab"><a href="#functionmethods-2">apply(object,Array)</a></li><li class="tab"><a href="#functionmethods-3">arguments</a></li></ul><div class="tab-content"><div class="tab-pane active" id="functionmethods-1"><p>函数对象不传参数直接调用call()时，与直接调用函数没有差异。<br>call()方法的第一个参数为对象。函数执行时，将会设置为由这个对象调用函数。之后的参数为函数本身的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Name</span>: <span class="string">&quot;Method&quot;</span>,</span><br><span class="line">    <span class="title class_">Speak</span>: <span class="keyword">function</span> (<span class="params">a, b</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">Name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot;, b = &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Speak函数为对象a的方法，定义在对象a下</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span> &#125;;</span><br><span class="line">a.<span class="property">Speak</span>.<span class="title function_">call</span>(b, <span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line"><span class="comment">//将Speak方法的调用对象修改为b</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">my name is Lacia   &lt;===输出的Name值为b的值“Lacia”</span><br><span class="line">a = 114, b = 514</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="functionmethods-2"><p>apply()与call()的功能一致，不过参数有所不同。Array为原函数的参数所构成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">Name</span>: <span class="string">&quot;Method&quot;</span>,</span><br><span class="line">    <span class="title class_">Speak</span>: <span class="keyword">function</span> (<span class="params">a, b</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;my name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">Name</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot;, b = &quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span> &#125;;</span><br><span class="line">a.<span class="property">Speak</span>.<span class="title function_">apply</span>(b, [<span class="number">114</span>, <span class="number">514</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">my name is Lacia</span><br><span class="line">a = 114, b = 514</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="functionmethods-3"><p>arguments是一个类似数组但不是数组的对象。它保存了所有传进函数的参数。</p>
<p>同时它本身也有两个属性：①length，保存了参数个数；②callee，指向函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a, b</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数个数为：&quot;</span> + <span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> temp <span class="keyword">in</span> <span class="variable language_">arguments</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[temp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">参数个数为：4</span><br><span class="line">114</span><br><span class="line">514</span><br><span class="line">1919</span><br><span class="line">810</span><br><span class="line">[Function: fun]</span><br></pre></td></tr></table></figure></div></div></div>

<h4 id="Ⅲ-Math"><a href="#Ⅲ-Math" class="headerlink" title="Ⅲ. Math"></a><strong>Ⅲ. Math</strong></h4><p>Math本身就是一个对象，不是一个类，也没有构造函数。与它的名字相符，这个对象中的方法就是专门用来处理数学运算的。</p>
<p>Math中保存了一些数学上常用的常量。</p>
<ul>
<li>PI，圆周率π</li>
<li>E，自然常数</li>
<li>······</li>
</ul>
<p>Math中还含有很多常用的数学函数，其中某些函数名称在C&#x2F;C++中也很常见。</p>
<ul>
<li>abs()，求绝对值</li>
<li>ceil()，将小数向上取整</li>
<li>floor()，将小数向下取整</li>
<li>round()，将小数四舍五入</li>
<li>random()，产生0~1之间的随机数</li>
<li>max()，返回多个数的最大值</li>
<li>min()，返回多个数的最小值</li>
<li>pow(i,j)，返回i的j次方</li>
<li>sqrt()，开方</li>
<li>······</li>
</ul>
<p>此外还有一些Math的属性与方法，详情请参见 <a class="btn" href="https://www.runoob.com/jsref/jsref-obj-math.html">菜鸟教程</a> 。</p>
<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">JavaScript还能再更深入的学习。但如果只是写网页行为的话，目前的知识储备已经足够了。当然JavaScript不止能写网页行为，不过至于这部分的知识，本文就不再深入。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>JavaScript基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Promise技术</title>
    <url>/2022/05/19/JavaScriptPromise/</url>
    <content><![CDATA[<img src="/2022/05/19/JavaScriptPromise/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有JavaScript基础</div>
</div>

<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p><code>Promise</code>类是在ES6标准下规定的一个类，使用该类可以达到类似于同步编程的执行语句，从而规避异步执行造成的回调地狱，尤其是在进行文件流与Ajax的时候。<code>Promise</code>技术还允许绑定多个回调函数。因此很有必要详细了解<code>Promise</code>的基本原理与API。</p>
<h2 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a><strong>二、基本使用</strong></h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="(1) 基础"></a><strong>(1) 基础</strong></h3><p><code>Promise</code>类可以在任意的支持ES6标准的环境下直接使用，其构造函数为<code>Promise()</code> 。该构造函数的参数为一个回调函数。作为参数的回调函数又应当有两个回调函数作为形参，其形参名字可以按你的喜好命名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在外部定义一个变量，并在 Promise 内部修改它</span></span><br><span class="line"><span class="comment">// 从而确定Promise究竟是同步阻塞还是异步并行</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Random</span> = <span class="number">114514</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为构造函数的参数的回调函数应当有两个形参</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, Reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟，查看是否存在同步阻塞</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Random</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Random =&quot;</span>, <span class="title class_">Random</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Random</span> &gt;= <span class="number">60</span>)</span><br><span class="line">            <span class="title class_">Resolve</span>(<span class="title class_">Random</span>);    <span class="comment">// 成功时调用第一个回调函数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="title class_">Reject</span>(<span class="title class_">Random</span>);     <span class="comment">// 失败时调用第二个回调函数</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印在 Promise 外部，刚创建 Promise 对象时 Random 的值，以判定是否存在阻塞</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Outside Random =&quot;</span>, <span class="title class_">Random</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>Promise</code>的实例对象被创建时，作为构造函数参数的回调函数就已经开始以异步并行的方式执行了。当成功执行时，应当调用第一个回调函数<code>Resolve()</code> ，而失败时则应调用<code>Reject()</code> 。前者会将<code>Promise</code>实例对象的状态设置为成功，后者会设置为失败。</p>
<p>当执行完构造函数中的回调函数时，<code>Promise</code>实例对象会自动调用<code>then()</code>方法绑定的回调函数。<code>then()</code>方法接受两个回调函数作为参数，前者是成功状态下会执行的回调函数，后者是失败状态下会执行的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的参数的值，就是调用 Resolve 或 Reject 函数时的参数值</span></span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;及格，分数 =&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside Random =&quot;</span>, <span class="title class_">Random</span>);     <span class="comment">// 检查在 Promise 执行完毕后的 Random 的值</span></span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;不及格，分数 =&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Inside Random =&quot;</span>, <span class="title class_">Random</span>);     <span class="comment">// 检查在 Promise 执行完毕后的 Random 的值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Outside Random = 114514</span><br><span class="line">Random = 36.8096285637177</span><br><span class="line">不及格，分数 = 36.8096285637177</span><br><span class="line">Inside Random = 36.8096285637177</span><br></pre></td></tr></table></figure>

<p>很明显，<code>Promise</code>的底层是异步并行的，但写起来它很像同步阻塞。另外，如果不需要成功时的返回值而只想要失败时的返回值，可以使用<code>catch()</code>方法代替<code>then()</code>方法。<code>catch()</code>方法只接受一个回调函数作为参数，该回调函数将被绑定为失败是执行的函数。</p>
<p>当存在多个绑定的函数时，所有绑定的函数都会被执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个不同状态的 Promise 对象</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, _</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Resolve</span>();      <span class="comment">// 状态为成功</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reject</span>();       <span class="comment">// 状态为失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试给 a 绑定多个成功时的回调函数</span></span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第一次调用 a 的 then()&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第二次调用 a 的 then()&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试给 b 绑定多个失败时的回调函数</span></span><br><span class="line">b.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第一次调用 b 的 then()&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">b.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第二次调用 b 的 then()&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 catch() 方法绑定</span></span><br><span class="line">b.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第一次调用 b 的 catch()&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">第一次调用 a 的 then()</span><br><span class="line">第二次调用 a 的 then()</span><br><span class="line">第一次调用 b 的 then()</span><br><span class="line">第二次调用 b 的 then()</span><br><span class="line">第一次调用 b 的 catch()</span><br></pre></td></tr></table></figure>

<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="(2) 封装"></a><strong>(2) 封装</strong></h3><p>对于文件流等需要进行I&#x2F;O操作的代码，可以使用<code>Promise</code>技术将其封装为一个函数，该函数的返回值就是一个<code>Promise</code>对象，在调用函数后对返回值执行<code>then()</code>方法即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 载入文件流模块</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">File</span> = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ReadFile</span> = (<span class="params">Path</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 返回值是一个 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, Reject</span>) =&gt;</span> [</span><br><span class="line">        <span class="title class_">File</span>.<span class="title function_">readFile</span>(<span class="title class_">Path</span>, <span class="function">(<span class="params"><span class="built_in">Error</span>, Data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Error</span> !== <span class="literal">null</span>)</span><br><span class="line">                <span class="title class_">Reject</span>(<span class="title class_">Error</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="title class_">Resolve</span>(<span class="title class_">Data</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    ]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 then() 方法，设置成功与失败状态的回调函数</span></span><br><span class="line"><span class="title class_">ReadFile</span>(<span class="string">&quot;./1.txt&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">1145141919810</span><br></pre></td></tr></table></figure>

<p>对于像文件流的<code>readFile()</code>函数一样，其回调函数参数为<code>(err,data)</code>这种错误在前数据在后的函数，可以直接使用<code>util.promisify()</code>方法进行封装。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 fs 模块与 util 模块</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">File</span> = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Util</span> = <span class="built_in">require</span>(<span class="string">&quot;util&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装 readFile() 函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReadFile</span> = <span class="title class_">Util</span>.<span class="title function_">promisify</span>(<span class="title class_">File</span>.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReadFile</span>(<span class="string">&quot;./1.txt&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Data</span>.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于使用了<code>util</code>模块，因此上述代码的封装仅限Node.js环境下使用。</p>
<h2 id="三、Promise对象的状态"><a href="#三、Promise对象的状态" class="headerlink" title="三、Promise对象的状态"></a><strong>三、<code>Promise</code>对象的状态</strong></h2><p>上文提到了<code>Promise</code>对象会根据调用<code>Resolve()</code>函数、调用<code>Reject()</code>函数或抛出异常而改变状态。<code>Promise</code>对象一般有三种状态：</p>
<ul>
<li><code>pending</code> ，未定状态（还在执行中）</li>
<li><code>resolved</code> &#x2F; <code>fulfilled</code> ，成功状态</li>
<li><code>rejected</code> ，失败状态</li>
</ul>
<p><code>Promise</code>对象的初始状态为<code>pending</code> ，其状态只能被改变一次且只会变为成功状态或失败状态。<code>Promise</code>对象状态的改变与使用<code>then()</code>方法绑定处理用的回调函数的先后顺序是不确定的。可以是先改变状态再绑定回调函数（例如当<code>Promise</code>对象要执行的函数很简单时），也可以先绑定回调函数再改变状态（例如当要执行文件流时）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接执行 Reject()</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reject</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 状态已改变&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定回调函数</span></span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 已处理&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 已绑定回调函数&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟执行 Reject()</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Reject</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 状态已改变&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定回调函数</span></span><br><span class="line">b.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 已处理&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 已绑定回调函数&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a 状态已改变</span><br><span class="line">a 已绑定回调函数</span><br><span class="line">b 已绑定回调函数</span><br><span class="line">a 已处理</span><br><span class="line">b 状态已改变</span><br><span class="line">b 已处理</span><br></pre></td></tr></table></figure>

<p>由于Node.js环境下，控制台打印的<code>Promise</code>对象不会显示其状态，因此采用浏览器作为运行环境，执行下述代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title class_">Random</span> = <span class="number">114514</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, Reject</span>) =&gt;</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span></span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Random</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (<span class="title class_">Random</span> &gt;= <span class="number">60</span>)</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Resolve</span>(<span class="title class_">Random</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Reject</span>(<span class="title class_">Random</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);         <span class="comment">// 查看 a 的状态</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    a.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;及格，分数 =&quot;</span>, <span class="title class_">Data</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);     <span class="comment">// 查看 a 的状态</span></span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;不及格，分数 =&quot;</span>, <span class="title class_">Error</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a);     <span class="comment">// 查看 a 的状态</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<p><img src="/2022/05/19/JavaScriptPromise/1.png" alt="1" title="1"></p>
<p>可以看到此处执行成功的状态为<code>fulfilled</code> 。</p>
<p><code>[[PromiseState]]</code>一项显示的是状态，而<code>[[PromiseResult]]</code>一项显示的是调用<code>Resolve()</code>或<code>Reject()</code>函数时传入的值，又或者是抛出的异常的信息。该值就是<code>Promise</code>对象成功或失败的结果值。</p>
<h2 id="四、Promise的其他方法"><a href="#四、Promise的其他方法" class="headerlink" title="四、Promise的其他方法"></a><strong>四、<code>Promise</code>的其他方法</strong></h2><p>在<code>Promise</code>下还定义了一些其他方法。</p>
<div class="tabs" id="promisefunction"><ul class="nav-tabs"><li class="tab active"><a href="#promisefunction-1"><code>resolve()</code></a></li><li class="tab"><a href="#promisefunction-2"><code>reject()</code></a></li><li class="tab"><a href="#promisefunction-3"><code>all()</code></a></li><li class="tab"><a href="#promisefunction-4"><code>race()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="promisefunction-1"><p>该方法可以快速生成一个成功或失败状态的<code>Promise</code>对象。该函数接受一个参数，返回值的状态将由这个参数值决定。</p>
<ul>
<li>当传入非<code>Promise</code>对象时，无论是什么值（包含<code>null</code> 、<code>undefined</code>等），都会返回一个成功状态的<code>Promise</code>对象，其值为该参数的值。</li>
<li>当传入<code>Promise</code>对象时，返回的<code>Promise</code>对象的值与作为参数的<code>Promise</code>对象的值与状态相同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入 undefined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 Promise 对象的状态</span></span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 成功&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 失败&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个失败状态的 Promise 对象</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reject</span>(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看 Promise 对象的状态</span></span><br><span class="line">b.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 成功&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 失败&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a 成功</span><br><span class="line">a = undefined</span><br><span class="line">b 失败</span><br><span class="line">b = 测试</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="promisefunction-2"><p>该方法可以快速生成一个失败状态的<code>Promise</code>对象。该函数接受一个参数，不论参数是什么值，是什么类型，返回值都是一个失败状态的<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="literal">undefined</span>);</span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 成功&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 失败&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a =&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, _</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Resolve</span>(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">b.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 成功&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 失败&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a 失败</span><br><span class="line">a = undefined</span><br><span class="line">b 失败</span><br><span class="line">b = Promise &#123; &#x27;测试&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>请注意，当参数为一个<code>Promise</code>对象时，返回值为一个失败状态<code>Promise</code>对象，该<code>Promise</code>对象的<span style="color:red;">值</span>为作为参数的<code>Promise</code>对象。这一点与<code>resolve()</code>方法不同。</p></div><div class="tab-pane" id="promisefunction-3"><p>该方法的参数为一个数组，该数组的每一个元素都应当为<code>Promise</code>对象。该方法的返回值为一个<code>Promise</code>对象，该对象的状态会根据数组中的<code>Promise</code>对象的状态决定。</p>
<ul>
<li>全为成功：返回成功状态的<code>Promise</code>对象，其值为所有成功<code>Promise</code>对象的值组成的数组。</li>
<li>不全为成功：返回失败状态的<code>Promise</code>对象，其值为第一个失败的<code>Promise</code>对象的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成器，返回值是一个函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Executer</span> = (<span class="params">Code</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">Resolve, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 设置执行延迟</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="number">10</span>)</span><br><span class="line">                <span class="title class_">Resolve</span>(<span class="string">`<span class="subst">$&#123;Code&#125;</span> : <span class="subst">$&#123;temp&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="title class_">Reject</span>(<span class="string">`<span class="subst">$&#123;Code&#125;</span> : <span class="subst">$&#123;temp&#125;</span>`</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 4 个 Promise 对象</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 all() 方法</span></span><br><span class="line"><span class="keyword">let</span> temp = <span class="title class_">Promise</span>.<span class="title function_">all</span>([a, b, c, d]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看结果</span></span><br><span class="line">temp.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`成功，Data = <span class="subst">$&#123;Data&#125;</span>`</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`失败，Data = <span class="subst">$&#123;<span class="built_in">Error</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">失败，Data = d : 8.652314556017803</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">成功，Data = a : 52.52405919011045,b : 71.84232482586259,c : 82.63641456437509,d : 28.093864189149187</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="promisefunction-4"><p>该方法的参数为一个数组，该数组的每一个元素都应当为<code>Promise</code>对象。该方法的返回值为一个<code>Promise</code>对象，该对象的状态为<span style="color:red;:">数组中第一个完成的</span> <code>Promise</code>对象的状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Executer</span> = (<span class="params">Code</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">Resolve, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="number">50</span>)</span><br><span class="line">                <span class="title class_">Resolve</span>(<span class="string">`<span class="subst">$&#123;Code&#125;</span> : <span class="subst">$&#123;temp&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="title class_">Reject</span>(<span class="string">`<span class="subst">$&#123;Code&#125;</span> : <span class="subst">$&#123;temp&#125;</span>`</span>);</span><br><span class="line">        &#125;, temp);   <span class="comment">// 此处设置为随机毫秒的时延</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;b&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="title class_">Executer</span>(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 race() 方法</span></span><br><span class="line"><span class="keyword">let</span> temp = <span class="title class_">Promise</span>.<span class="title function_">race</span>([a, b, c, d]);</span><br><span class="line"></span><br><span class="line">temp.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`成功，Data = <span class="subst">$&#123;Data&#125;</span>`</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`失败，Data = <span class="subst">$&#123;<span class="built_in">Error</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">成功，Data = d : 57.77071664225848</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">失败，Data = b : 6.342981472527809</span><br></pre></td></tr></table></figure></div></div></div>

<p>此处需要单独说明一下<code>then()</code>方法，因为该方法非常重要，是规避回调地狱不可或缺的一环。</p>
<p><code>then()</code>方法的返回值也是一个<code>Promise</code>对象，只不过上文没有使用过这个返回值。该<code>Promise</code>对象的状态由执行哪一个绑定的回调函数以及其返回值决定。</p>
<ul>
<li>当返回非<code>Promise</code>对象时，无论是什么值（包含<code>null</code> 、<code>undefined</code>等），都会返回一个成功状态的<code>Promise</code>对象，其值为该返回值。</li>
<li>当处理的回调函数返回<code>Promise</code>对象时，<code>then()</code>方法会返回状态与值相同的<code>Promise</code>对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个失败状态的 Promise 对象</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reject</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 then() 方法的返回值</span></span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;114514&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看是成功状态还是失败状态，并打印 Promise 对象的值</span></span><br><span class="line">b.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 成功&quot;</span>, <span class="title class_">Data</span>);;</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 失败&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">a 失败</span><br><span class="line">b 成功 114514</span><br></pre></td></tr></table></figure>

<p>因此<code>then()</code>方法可以链式调用。链式调用在有多个需要同步阻塞执行的函数时非常有用。例如：</p>
<ul>
<li>文件批处理：从一个文件读取数据，根据读取的数据向另一个文件写入数据</li>
<li>爬虫：请求网页，根据获取的网页内容分析其中的资源并保存至本地</li>
<li>······</li>
</ul>
<p>对于 “必须先淘米再煮饭” 的这种因存在先后顺序而不能并发执行的操作，使用<code>then()</code>方法相比使用回调函数更加舒畅。</p>
<p>对于链式调用的<code>then()</code>方法，其失败状态的<code>Promise</code>对象会层层传递。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个失败状态的 Promise 对象</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Reject</span>(<span class="string">&quot;总是就是失败了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用 then() 时，只指定成功的回调函数，失败的回调函数在最后用  catch() 指定。</span></span><br><span class="line">a.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第一步&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第二步&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;第三步&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`错误原因：<span class="subst">$&#123;<span class="built_in">Error</span>&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">错误原因：总是就是失败了</span><br></pre></td></tr></table></figure>

<p>可以看见所有绑定的成功的回调函数均未执行，失败状态的<code>Promise</code>对象连带其结果被层层传递直到绑定了处理失败状态的回调函数。如果想要中断链式<code>then()</code>的执行，只需要返回一个未定状态的<code>Promise</code>对象即可（即返回的<code>Promise</code>对象既不调用<code>Resolve()</code>也不调用<code>Reject()</code> ）。</p>
<h2 id="五、-async与await"><a href="#五、-async与await" class="headerlink" title="五、 async与await"></a><strong>五、 <code>async</code>与<code>await</code></strong></h2><h3 id="1-async函数"><a href="#1-async函数" class="headerlink" title="(1) async函数"></a><strong>(1) <code>async</code>函数</strong></h3><p><code>async</code>修饰符用于修饰函数。被<code>async</code>修饰的函数，返回值永远是一个<code>Promise</code>对象，即便该函数内不写<code>return</code>关键字也一样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个空的 async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">a</span>();</span><br><span class="line"></span><br><span class="line">b.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">成功 undefined</span><br></pre></td></tr></table></figure>

<p>当返回非<code>Promise</code>对象时，无论是什么值（包含<code>null</code> 、<code>undefined</code>等），都会返回一个成功状态的<code>Promise</code>对象，其值为该返回值；当返回<code>Promise</code>对象时，返回值的<code>Promise</code>对象的状态、值与该对象一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">    c = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Reject</span>(<span class="string">&quot;1919810&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 成功&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a 失败&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="title function_">b</span>();</span><br><span class="line">d.<span class="title function_">then</span>(<span class="function">(<span class="params">Data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 成功&quot;</span>, <span class="title class_">Data</span>);</span><br><span class="line">&#125;, <span class="function">(<span class="params"><span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b 失败&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;d === c is&quot;</span>, d === c);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">d === c is false</span><br><span class="line">a 成功 114514</span><br><span class="line">b 失败 1919810</span><br></pre></td></tr></table></figure>

<p>如果在<code>async</code>函数中抛出了异常，则该函数的返回值的<code>Promise</code>对象的状态将为失败，其值将为错误信息。</p>
<h3 id="2-await修饰符"><a href="#2-await修饰符" class="headerlink" title="(2) await修饰符"></a><strong>(2) <code>await</code>修饰符</strong></h3><p><code>await</code>修饰符只能出现在<code>async</code>函数中。该修饰符一般修饰一个<code>Promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">Resolve, _</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 延时执行 Resolve()</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Resolve</span>(<span class="number">114514</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">await</span> <span class="number">1919810</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">114514</span><br><span class="line">1919810</span><br></pre></td></tr></table></figure>

<p>可以看出<code>await</code>关键字修饰<code>Promise</code>对象时，其返回值为该对象的执行器函数调用<code>Resolve()</code>函数时传入的参数，即成功状态下的值，并且该语句是同步阻塞执行的（底层实现仍然是异步，但表现得像同步一样）。</p>
<p>当<code>await</code>关键字修饰非<code>Promise</code>对象时，其返回值就是该变量本身。</p>
<p>当<code>await</code>关键字修饰的<code>Promise</code>对象是失败状态时，将抛出异常，异常信息为该<code>Promise</code>对象的执行器函数调用<code>Reject()</code>函数时传入的参数，即失败状态下的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, Reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Reject</span>(<span class="number">114514</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="title class_">Error</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;错误：&quot;</span>, <span class="title class_">Error</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b =&quot;</span>, b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">错误： 114514</span><br><span class="line">b = null</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>JavaScript进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua基础</title>
    <url>/2022/05/24/LuaGrammar/</url>
    <content><![CDATA[<img src="/2022/05/24/LuaGrammar/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有一门编程语言的基础再学习Lua。</div>
</div>

<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>Lua是一门解释型语言，但它具有很强的扩展性——它是由C语言编写的，可以很方便地调用C&#x2F;C++的函数，也可以很方便地被C&#x2F;C++调用。因为这个特性，Lua常用于游戏开发。虽然这个编程语言很小众，但腾讯在Visual Studio Code上发布了一个Lua的Debug插件就足以说明，该语言在实际开发中有广泛的应用场景。</p>
<p>关于Lua解释器的安装，请参照网络上的其他文章，或者前往Lua官网 <a class="btn" href="http://www.lua.org/ ">Lua官网</a> 。</p>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a><strong>二、基础语法</strong></h2><h3 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="(1) 变量声明"></a><strong>(1) 变量声明</strong></h3><p>Lua与其他的解释型语言类似，变量的声明非常简单：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">A = <span class="number">114514</span>;</span><br></pre></td></tr></table></figure>

<p>按照上述方式声明的变量是全局变量。全局变量建议首字母大写，但不强制要求。要想声明局部变量，在变量名之前添加<code>local</code>修饰符即可。对于未被声明的变量，其值为<code>nil</code> 。这个值类似于C&#x2F;C++&#x2F;C#等语言的<code>null</code> 。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Lacia);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>Lua可以像Python一样一次性给多个变量赋值：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a, b, c = <span class="number">114</span>, <span class="number">514</span>, <span class="string">&quot;1919&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上述方式声明的变量均为局部变量。</p>
<h3 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="(2) 基本数据类型"></a><strong>(2) 基本数据类型</strong></h3><p>Lua中的变量虽然没有显式声明其类型，但所有变量都是有类型的。可以使用<code>type()</code>函数来查看变量的类型：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">114514</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">number</span><br></pre></td></tr></table></figure>

<div class="tabs" id="datatype"><ul class="nav-tabs"><li class="tab active"><a href="#datatype-1"><code>number</code></a></li><li class="tab"><a href="#datatype-2"><code>string</code></a></li><li class="tab"><a href="#datatype-3"><code>boolean</code></a></li><li class="tab"><a href="#datatype-4"><code>function</code></a></li><li class="tab"><a href="#datatype-5"><code>nil</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="datatype-1"><p><code>number</code>类型用于表示浮点数，其底层实现为<code>double</code>类型。Lua中不存在专为整数设计的类型，因为浮点数可以表示整数。</p>
<p>Lua支持基本的四则运算，支持十六进制表示法，也支持逻辑移位运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code> 、科学计数法<code>e</code> ，但不支持次方运算符<code>**</code> ，次方运算符以<code>^</code>代替。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分别使用科学计数法与十六进制表示法</span></span><br><span class="line"><span class="keyword">local</span> a, b = <span class="number">-16e5</span>, <span class="number">0xFE</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a =&quot;</span>, a);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b =&quot;</span>, b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a &gt;&gt; 3 is&quot;</span>, a &gt;&gt; <span class="number">3</span>);     <span class="comment">-- 输出的值将会很奇怪</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b &lt;&lt; 4 is&quot;</span>, b &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">lua Hello.lua &#125;</span><br><span class="line">a =     -1600000.0</span><br><span class="line">b =     254</span><br><span class="line">a &gt;&gt; 3 is       2305843009213493952</span><br><span class="line">b &lt;&lt; 4 is       4064</span><br></pre></td></tr></table></figure>

<p>第三行输出的a的值有点怪异，这和移位运算符有关。接下来解释移位运算符的部分需要一点计算机组成原理的知识。</p>
<p>Lua的移位运算符与C&#x2F;C++的不一样，C&#x2F;C++的默认移位运算符是算数移位运算符（即当最高位为1时，执行左移位时左侧补1而不是补0）。由于Lua左移运算符是逻辑左移运算符，因此可以推算Lua中<code>number</code>类型占用的字节数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a &gt;&gt; 1 is&quot;</span>, a &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">a &gt;&gt; 1 is       9223372036854775807</span><br></pre></td></tr></table></figure>

<p>9223372036854775807转换为十六进制为：</p>
<p><img src="/2022/05/24/LuaGrammar/1.png" alt="1" title="1"></p>
<p>据此可以推算出Lua中，<code>number</code>类型占用8字节，并且<code>number</code>类型存在精度问题与溢出风险。</p></div><div class="tab-pane" id="datatype-2"><p><code>string</code>类型用于表示字符串。Lua中的字符串既可以使用单引号也可以使用双引号。还有一种表示字符串的方式，这种方式可以保留换行符并<span style="color:red;">禁用转义字符</span>：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> b = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span>;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="built_in">print</span>(b);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">114514</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在别的语言中使用<code>+</code>对字符串进行运算的时候，会尝试将其他数据类型转换为字符串类型并进行字符串拼接。但Lua则会尝试将字符串转换为<code>number</code>类型并进行四则运算。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a + 1919810 =&quot;</span>, a + <span class="number">1919810</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a + 1919810 =   2034324</span><br></pre></td></tr></table></figure>

<p>当字符串不可被转换为<code>number</code>类型时，将会抛出异常。Lua中字符串拼接需要通过 <code>..</code>运算符进行。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a .. 1919810 =&quot;</span>, a .. <span class="number">1919810</span>);      <span class="comment">-- 此处存在隐式类型转换，number 类型转换为 string 类型</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a .. 1919810 =  1145141919810</span><br></pre></td></tr></table></figure>

<p>获取字符串的长度，只需要在该字符串前加 <code>#</code> 运算符即可。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="string">&quot;114514&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(#(a .. <span class="number">1919810</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">13</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="datatype-3"><p>与其它多数语言类似，Lua的<code>boolean</code>类型只有<code>true</code>与<code>false</code>两种值。</p>
<p>在Lua中，<code>nil</code>与<code>false</code>在逻辑运算中会被隐式类型转换为<code>false</code>，而其余的值都会被隐式类型转换为<code>true</code> ，包括<code>number</code>类型的0。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义三个局部变量</span></span><br><span class="line"><span class="keyword">local</span> a, b, c = <span class="literal">nil</span>, <span class="number">0</span>, <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 虽然还没讲到控制流，但有编程语言基础的话应该能看懂</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试 nil 的隐式类型转换</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is true&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a is false&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试 0 的隐式类型转换</span></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b is true&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b is false&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试 &quot;0&quot; 的隐式类型转换</span></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c is true&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c is false&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a is false</span><br><span class="line">b is true</span><br><span class="line">c is true</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="datatype-4"><p>与JavaScript类似，Lua的函数被视为是变量的一种类型。Lua中定义函数时，函数体必须以<code>end</code>关键字作为结尾。定义函数有两种方式：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 最普通的函数定义方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plus</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x + y =&quot;</span>, x + y);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个匿名函数，然后将其赋值给变量</span></span><br><span class="line">Multiply = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x * y =&quot;</span>, x * y);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line">Plus(<span class="number">114</span>, <span class="number">514</span>);</span><br><span class="line">Multiply(<span class="number">1919</span>, <span class="number">810</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">lua Hello.lua</span><br><span class="line">x + y = 628</span><br><span class="line">x * y = 1554390</span><br></pre></td></tr></table></figure>

<p>Lua的函数可以赋值给变量，这一点与JavaScript类似，也因此Lua可以通过写匿名函数的方式将函数作为参数传入另一个函数。</p>
<p>此外，Lua的函数可以使用<code>return</code>关键字来返回值，并且可以像Python一样一次性返回多个值，接收的时候可以使用多个值来接受。</p></div><div class="tab-pane" id="datatype-5"><p>在Lua中，<code>nil</code>值只属于<code>nil</code>类型，<code>nil</code>类型也只有<code>nil</code>这一个值。这个值与其它语言的<code>null</code>类似。</p></div></div></div>

<p><code>number</code>类型可以与<code>string</code>类型互相转换，使用内置的<code>tostring()</code>函数与<code>tonumber()</code>函数即可。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a, b, c = <span class="number">114.514</span>, <span class="string">&quot;114.514&quot;</span>, <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试将 a 转换为 string 类型，将 b, c 转换为 number 类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(a), <span class="built_in">tonumber</span>(b), <span class="built_in">tonumber</span>(c));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">114.514 114.514 ABCDE</span><br><span class="line">114.514 114.514 nil</span><br></pre></td></tr></table></figure>

<p>当<code>string</code>类型无法被转换为<code>number</code>类型时，将返回<code>nil</code> 。</p>
<h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="(3) 数据结构"></a><strong>(3) 数据结构</strong></h3><p>可以认为，Lua里只有一种通用的数据结构——表。集合、顺序表、哈希表、树等数据结构，都可以通过表来实现。声明一个表很简单：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    <span class="number">114</span>,</span><br><span class="line">    <span class="string">&quot;514&quot;</span>,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    <span class="literal">nil</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> x + y, x * y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a><strong>1. 数组</strong></h4><p>与JavaScript的数组类似，上述方式定义的Lua的表中可以存放任意类型的数据，可以通过索引来访问元素，并且当索引越界时，返回值将为<code>nil</code> ，因此这种方式定义的表一般称为数组。Lua的数组独特之处在于，其索引是从1开始而不是从0开始的。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ······</span></span><br><span class="line"><span class="comment">-- 省略上方的代码</span></span><br><span class="line"><span class="comment">-- ······</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a);                   <span class="comment">-- 尝试打印数组</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">5</span>](<span class="number">114</span>, <span class="number">514</span>));      <span class="comment">-- 尝试调用数组中的匿名函数</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">5</span>]);                <span class="comment">-- 尝试打印函数</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">6</span>]);          <span class="comment">-- 尝试打印不存在的元素</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">table: 0000000000f598a0</span><br><span class="line">628     58596</span><br><span class="line">function: 0000000000f5d4c0</span><br><span class="line">nil     nil</span><br></pre></td></tr></table></figure>

<p>其中，第一行与第三行分别是尝试打印数组本身与函数，其结果应该是该变量在栈中的值，即一个指向堆的地址。第二行成功调用了函数并正确地输出了值，第四行则是索引越界的返回值。</p>
<p>在Lua中，可以直接通过索引来修改或添加数组的元素值，并且可以使用 <code>#</code> 运算符来获取数组长度。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ······</span></span><br><span class="line"><span class="comment">-- 省略上方的代码</span></span><br><span class="line"><span class="comment">-- ······</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#a =&quot;</span>, #a);</span><br><span class="line">a[<span class="number">8</span>] = <span class="number">1919810</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[8] =&quot;</span>, a[<span class="number">8</span>]);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[6] =&quot;</span>, a[<span class="number">6</span>]);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#a =&quot;</span>, #a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a =    5</span></span><br><span class="line">a[8] =  1919810</span><br><span class="line">a[6] =  nil</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a =    8</span></span><br></pre></td></tr></table></figure>

<p>Lua也为表封装了一些函数，这些函数都位于<code>table</code>库下。调用时，应当形如下述代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    <span class="number">114</span>,</span><br><span class="line">    <span class="string">&quot;514&quot;</span>,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引为 2 的元素值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[2] = &quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用 table 库下的 inset() 函数</span></span><br><span class="line"><span class="comment">-- 向索引为 2 处插入元素 1919</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(a, <span class="number">2</span>, <span class="number">1919</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引为 2, 3 的元素值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[2] = &quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[3] = &quot;</span>, a[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a[2] =  514</span><br><span class="line">a[2] =  1919</span><br><span class="line">a[3] =  514</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>insert()</code></td>
<td align="center">表，元素</td>
<td align="center">向数组末尾插入元素</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>insert()</code></td>
<td align="center">表，索引值，元素</td>
<td align="center">向数组的指定索引值元素之前插入元素</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>remove()</code></td>
<td align="center">表，索引值</td>
<td align="center">删除数组中的指定索引值的元素</td>
<td align="center">被删除的元素值</td>
</tr>
</tbody></table>
<p>需要注意的是，使用上述函数时若指定的索引越界，则会抛出异常。另外，根据 <a class="btn" href="http://www.lua.org/manual/5.4/manual.html#6.6 ">Lua官方文档</a> 的声明：</p>
<blockquote>
<p><strong style="color:royalblue;">table.insert (list, [pos,] value)</strong><br>Inserts element value at position pos in list, shifting up the elements list[pos], list[pos+1], ···, list[#list]. The default value for pos is #list+1, so that a call table.insert(t,x) inserts x at the end of the list t.</p>
</blockquote>
<p>使用<code>table.insert()</code>时，若参数只有两个，则第二个参数将被默认为待插入的元素，插入位置默认为 <code>#list+1</code> ，即使用 <code>#</code> 运算符计算得到的数组长度+1。这将是一个坑。</p>
<h4 id="2-字典与类"><a href="#2-字典与类" class="headerlink" title="2. 字典与类"></a><strong>2. 字典与类</strong></h4><p>将Lua的表以字典形式声明也很简单，和JavaScript的对象声明有点类似：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    a = <span class="number">114</span>,                    <span class="comment">-- 第一种声明方式</span></span><br><span class="line">    [<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;1919&quot;</span>,             <span class="comment">-- 第二种声明方式</span></span><br><span class="line">    c = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">        <span class="keyword">return</span> x + y, x * y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.a =&quot;</span>, a.a);            <span class="comment">-- 第一种访问方式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.b =&quot;</span>, a.b);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a.d = &quot;</span>, a.d);           <span class="comment">-- 尝试访问不存在的成员</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[&#x27;a&#x27;] =&quot;</span>, a[<span class="string">&quot;a&quot;</span>]);      <span class="comment">-- 第二种访问方式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a[&#x27;b&#x27;] =&quot;</span>, a[<span class="string">&quot;b&quot;</span>]);</span><br><span class="line"><span class="built_in">print</span>(a.c(<span class="number">114</span>, <span class="number">514</span>));           <span class="comment">-- 尝试调用成员函数</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;c&quot;</span>](<span class="number">114</span>, <span class="number">514</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 承接上文的坑</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;#a =&quot;</span>, #a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a.a =   114</span><br><span class="line">a.b =   1919</span><br><span class="line">a.d =   nil</span><br><span class="line">a[&#x27;a&#x27;] =        114</span><br><span class="line">a[&#x27;b&#x27;] =        1919</span><br><span class="line">628     58596</span><br><span class="line">628     58596</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a =    0</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>字典长度</strong></div>

<div style="color:goldenrod;">使用 <code>#</code> 运算符获取的字典的长度为0，这意味着如果使用<code>table.insert()</code>函数向字典中插入元素，那么只能向索引为1的位置插入元素。</div>
</div>

<p>不难看出这种方式声明的表，只不过是把索引换成了字符串。但使用 <code>.</code> 运算符访问元素的方式不禁让人想起C++&#x2F;C#的类。利用上述声明表的方法，既可以实现类，也可以实现字典。</p>
<p>另外，数组形式的表可以看作是字典形式的表的简写：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">114</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">514</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="number">1919</span>,</span><br><span class="line">    [<span class="number">19</span>] = <span class="number">810</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(#a);      <span class="comment">-- 将输出 3，这也算个坑</span></span><br></pre></td></tr></table></figure>

<h4 id="3-全局表"><a href="#3-全局表" class="headerlink" title="3. 全局表"></a><strong>3. 全局表</strong></h4><p>在Lua的运行环境中，有一个名为<code>_G</code>的全局表。所有的全局变量均存放在该表中。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">A, B, C = <span class="number">114</span>, <span class="string">&quot;514&quot;</span>, <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_G.A =&quot;</span>, <span class="built_in">_G</span>.A);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_G.A =&quot;</span>, <span class="built_in">_G</span>.B);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;_G.A =&quot;</span>, <span class="built_in">_G</span>.C);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">_G</span>.<span class="built_in">table</span>.<span class="built_in">insert</span> == <span class="built_in">table</span>.<span class="built_in">insert</span>);     <span class="comment">-- 判断是否指向同一地址，即是否为同一函数</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">_G.A =  114</span><br><span class="line">_G.A =  514</span><br><span class="line">_G.A =  true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h3 id="4-控制流"><a href="#4-控制流" class="headerlink" title="(4) 控制流"></a><strong>(4) 控制流</strong></h3><p>Lua的与或非操作通过<code>and</code> 、<code>or</code>和<code>not</code>关键字实现，比较则通过<code>==</code>（等于）、<code>~=</code>（不等于）、<code>&lt;</code>（小于）、<code>&lt;=</code>（小于等于）、<code>&gt;</code>（大于）、<code>&gt;=</code>（大于等于）运算符实现。</p>
<p>需要注意的是不等于运算符，其他语言一般是<code>!=</code>而Lua是<code>~=</code> <del>不知道作者怎么想的要这么规定</del>。另外，<code>and</code>和<code>or</code>关键字的返回值不一定是<code>true</code>或者<code>false</code> 。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nil and 114:&quot;</span>, <span class="literal">nil</span> <span class="keyword">and</span> <span class="number">114</span>);     <span class="comment">-- 将打印 nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;114 and 514:&quot;</span>, <span class="number">114</span> <span class="keyword">and</span> <span class="number">514</span>);     <span class="comment">-- 将打印 514</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nil or nil:&quot;</span>, <span class="literal">nil</span> <span class="keyword">or</span> <span class="literal">nil</span>);       <span class="comment">-- 将打印 nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nil or 114:&quot;</span>, <span class="literal">nil</span> <span class="keyword">or</span> <span class="number">114</span>);       <span class="comment">-- 将打印 114</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;not nil:&quot;</span>, <span class="keyword">not</span> <span class="literal">nil</span>);             <span class="comment">-- 将打印 true</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;not 114:&quot;</span>, <span class="keyword">not</span> <span class="number">114</span>);             <span class="comment">-- 将打印 false</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">nil and 114:    nil</span><br><span class="line">114 and 514:    514</span><br><span class="line">nil or nil:     nil</span><br><span class="line">nil or 114:     114</span><br><span class="line">not nil:        true</span><br><span class="line">not 114:        false</span><br></pre></td></tr></table></figure>

<p>虽然<code>not</code>关键字的返回值一定为<code>boolean</code>类型，但<code>and</code>和<code>or</code>关键字则遵从短路运算规则，并且返回值将保留原参数值。可以利用这一特性构造三目运算符：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">114</span> == <span class="number">514</span> <span class="keyword">and</span> <span class="string">&quot;True&quot;</span> <span class="keyword">or</span> <span class="string">&quot;False&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h4 id="1-if"><a href="#1-if" class="headerlink" title="1. if"></a><strong>1. <code>if</code></strong></h4><p>Lua的<code>if</code>语句也需要以<code>end</code>关键字作为结束的标志<del>越写越像VHDL，这就是Lua被用作嵌入式开发的原因吗</del>。Lua的<code>if</code>语句结构如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">--[[ 条件 ]]</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- ······</span></span><br><span class="line">    <span class="comment">-- 代码块</span></span><br><span class="line">    <span class="comment">-- ······</span></span><br><span class="line"><span class="keyword">elseif</span> <span class="comment">--[[ 条件 ]]</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- ······</span></span><br><span class="line">    <span class="comment">-- 代码块</span></span><br><span class="line">    <span class="comment">-- ······</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- ······</span></span><br><span class="line">    <span class="comment">-- 代码块</span></span><br><span class="line">    <span class="comment">-- ······</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Lua的<code>if</code>语句中，<code>if</code>和<code>elseif</code>关键字都需要<code>then</code>关键字作为条件结束的分隔符。需要注意的是。在Lua的逻辑运算中，<span style="color:red;">0会被隐式类型转换为<code>true</code>而不是<code>false</code> 。</span></p>
<h4 id="2-循环"><a href="#2-循环" class="headerlink" title="2. 循环"></a><strong>2. 循环</strong></h4><p>Lua的循环有三种：<code>for</code>循环、<code>while</code>循环、<code>repeat</code>循环。其中<code>while</code>循环与<code>repeat</code>循环比较相似。</p>
<div class="tabs" id="loops"><ul class="nav-tabs"><li class="tab active"><a href="#loops-1"><code>for</code>循环</a></li><li class="tab"><a href="#loops-2"><code>for in</code>循环</a></li><li class="tab"><a href="#loops-3"><code>while</code>循环</a></li><li class="tab"><a href="#loops-4"><code>repeat</code>循环</a></li></ul><div class="tab-content"><div class="tab-pane active" id="loops-1"><p>Lua的<code>for</code>循环语法大体如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span> <span class="keyword">do</span>         <span class="comment">-- 参数分别为：初始值、结束值、步长</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i);            <span class="comment">-- 检测循环外能否继续使用变量 i</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">i =     1</span><br><span class="line">i =     4</span><br><span class="line">i =     7</span><br><span class="line">i =     10</span><br><span class="line">i =     nil</span><br></pre></td></tr></table></figure>

<p>可以看出上述代码中变量<code>i</code>的作用范围仅限于<code>for</code>循环内部。上述Lua代码的循环转换为C语言的循环，应该如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lua的<code>for</code>循环的步长可以为负，初始值也可以比结束值大。因此需要注意你的<code>for</code>循环可能因为步长正负问题而导致死循环。</p>
<p>另外，Lua的<code>for</code>循环中使用的计数变量（例如上述代码中的变量<code>i</code> ）是<span style="color:red;">不允许</span>在循环中被重新赋值的。如果程序员这么做了，那么Lua将会新建一个同名局部变量，原计数变量并不会被更改。</p></div><div class="tab-pane" id="loops-2"><p><code>for in</code>循环常用于遍历表。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    a = <span class="number">114</span>,</span><br><span class="line">    b = <span class="number">514</span>,</span><br><span class="line">    [<span class="number">1</span>] = <span class="string">&quot;1919&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;c&quot;</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;810&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key =&quot;</span>, key, <span class="string">&quot;value =&quot;</span>, value);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">key =   b       value = 514</span><br><span class="line">key =   a       value = 114</span><br><span class="line">key =   1       value = 1919</span><br><span class="line">key =   c       value = function: 0000000000ecd640</span><br></pre></td></tr></table></figure>

<p><code>pairs()</code>函数将在下文详述。此处需要知道的是，上述方式的遍历是随即遍历，即每次输出键值对的顺序都有可能不一样。</p></div><div class="tab-pane" id="loops-3"><p><code>while</code>循环的大体语法如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) <span class="keyword">do</span>        <span class="comment">-- 没有括号也可以</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i);</span><br><span class="line">    i = i + <span class="number">1</span>;          <span class="comment">-- Lua不支持 ++ 和 += 运算符</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">i =     1</span><br><span class="line">i =     2</span><br><span class="line">i =     3</span><br><span class="line">i =     4</span><br></pre></td></tr></table></figure>

<p>当<code>while</code>循环的条件不被满足时将会跳出循环。</p></div><div class="tab-pane" id="loops-4"><p>Lua的<code>repeat</code>循环与C&#x2F;C++的<code>do while</code>循环有点类似。其大体语法如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i);</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">until</span> i == <span class="number">5</span>;           <span class="comment">-- 结束条件</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">i =     1</span><br><span class="line">i =     2</span><br><span class="line">i =     3</span><br><span class="line">i =     4</span><br></pre></td></tr></table></figure>

<p>当<code>until</code>关键字后的条件满足时，将退出循环。</p></div></div></div>

<p>Lua的循环中也有<code>break</code>关键字，但很可惜的是没有<code>continue</code>关键字。在循环中使用<code>break</code>关键字可以立即跳出循环。</p>
<h2 id="三、部分库函数"><a href="#三、部分库函数" class="headerlink" title="三、部分库函数"></a><strong>三、部分库函数</strong></h2><p>在了解库函数之前，应当先了解Lua的一个语法糖。以<code>string.byte()</code>函数为例，以下两种写法是等价的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(a, <span class="number">4</span>));       <span class="comment">-- 不使用语法糖</span></span><br><span class="line"><span class="built_in">print</span>(a:<span class="built_in">byte</span>(<span class="number">4</span>));               <span class="comment">-- 使用语法糖</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">68</span><br><span class="line">68</span><br></pre></td></tr></table></figure>

<p>该语法糖相当于将第一个参数前置，作为 “调用此函数的对象” 来处理。<span style="color:red;">只有部分函数可以使用该语法糖。</span></p>
<h3 id="1-基础库"><a href="#1-基础库" class="headerlink" title="(1) 基础库"></a><strong>(1) 基础库</strong></h3><p>位于基础库内的函数可以直接调用。</p>
<div class="tabs" id="basicfunction"><ul class="nav-tabs"><li class="tab active"><a href="#basicfunction-1"><code>next()</code></a></li><li class="tab"><a href="#basicfunction-2"><code>pairs()</code>与<code>ipairs()</code></a></li><li class="tab"><a href="#basicfunction-3"><code>type()</code></a></li><li class="tab"><a href="#basicfunction-4"><code>select()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="basicfunction-1"><p><code>next()</code>函数用于遍历表。该函数接受两个参数：表、键。</p>
<ul>
<li>只传入表时，将默认传入的索引为<code>nil</code> 。</li>
<li>传入的键为<code>nil</code>时，将返回第一对键值对。</li>
<li>传入的键不为<code>nil</code>时，将返回下一对键值对。</li>
<li>传入的键位最后一个键时，将返回<code>nil</code> 。</li>
</ul>
<p>该函数常用于遍历表（但这种遍历对于字典形式的表而言是随机遍历），也可以用于判断一个表是否为空表。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    a = <span class="number">114</span>,</span><br><span class="line">    b = <span class="number">514</span>,</span><br><span class="line">    [<span class="number">1</span>] = <span class="string">&quot;1919&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;c&quot;</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;810&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 next() 函数遍历表</span></span><br><span class="line"><span class="keyword">local</span> k, v = <span class="built_in">next</span>(a)</span><br><span class="line"><span class="keyword">while</span> v <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, v);</span><br><span class="line">    k, v = <span class="built_in">next</span>(a, k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看 next() 函数的参数为空表时的返回值</span></span><br><span class="line"><span class="keyword">local</span> b = &#123;&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;next(b) =&quot;</span>, <span class="built_in">next</span>(b));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">1       1919</span><br><span class="line">a       114</span><br><span class="line">b       514</span><br><span class="line">c       function: 00000000001bd6a0</span><br><span class="line">next(b) =       nil</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="basicfunction-2"><p><code>pairs()</code>与<code>ipairs()</code>函数也是用于遍历表的函数，但需要搭配<code>for in</code>循环。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    a = <span class="number">114</span>,</span><br><span class="line">    b = <span class="number">514</span>,</span><br><span class="line">    [<span class="number">1</span>] = <span class="string">&quot;1919&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;c&quot;</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;810&quot;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试查看 pairs() 函数的返回值</span></span><br><span class="line"><span class="keyword">local</span> b, c, d = <span class="built_in">pairs</span>(a);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b == next :&quot;</span>, b == <span class="built_in">next</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c == a :&quot;</span>, c == a);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试查看 ipairs() 函数的返回值</span></span><br><span class="line">b, c, d = <span class="built_in">ipairs</span>(a);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b == next :&quot;</span>, b == <span class="built_in">next</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c == a :&quot;</span>, c == a);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;d =&quot;</span>, d);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">b == next :     true</span><br><span class="line">c == a :        true</span><br><span class="line">d =     nil</span><br><span class="line">b == next :     false</span><br><span class="line">c == a :        true</span><br><span class="line">d =     0</span><br></pre></td></tr></table></figure>

<p>不难看出<code>pairs()</code>函数的返回值就是迭代器函数（此处为<code>next()</code>函数）、表本身和<code>nil</code> ，其底层原理就是利用了<code>next()</code>函数进行遍历，但是<code>pairs()</code>函数返回的迭代器函数是可以自定义的，此处不深入涉及自定义迭代器函数。</p>
<p>与<code>pairs()</code>函数不同之处在于，<code>ipairs()</code>函数的返回值是另一种迭代器函数，并且初始的索引是0。也因此<code>ipairs()</code>函数仅能用于遍历数组形式的表。</p></div><div class="tab-pane" id="basicfunction-3"><p><code>type()</code>函数用于查看变量的类型。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a, b, c, d, e = &#123;&#125;, <span class="number">114</span>, <span class="string">&quot;514&quot;</span>, <span class="literal">true</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">table</span><br><span class="line">number</span><br><span class="line">string</span><br><span class="line">boolean</span><br><span class="line">function</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="basicfunction-4"><p><code>select()</code>函数的参数个数可变，它常用于获取可变长度参数函数的参数个数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 可变长度参数函数</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>, ...));</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">select</span>(<span class="number">2</span>, ...));</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">select</span>(<span class="number">3</span>, ...));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">a(<span class="number">114</span>, <span class="string">&quot;514&quot;</span>, <span class="number">1919</span>, <span class="string">&quot;810&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">4</span><br><span class="line">514     1919    810</span><br><span class="line">1919    810</span><br></pre></td></tr></table></figure>

<p>当第一个参数为 <code>#</code> 时，返回值为参数的长度，当第一个参数为整数时，返回值为从该索引（包含）开始直到参数末尾的所有参数。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>处理可变长度参数的另一种方式</strong></div>

<div style="color:royalblue;">可以使用<code>&#123;&#125;</code>将可变长度参数直接转换为数组形式的表。</div>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> b = &#123;...&#125;;</span><br><span class="line">    <span class="built_in">print</span>(#b);</span><br><span class="line">    <span class="built_in">print</span>(b[<span class="number">1</span>], b[<span class="number">2</span>], b[<span class="number">3</span>], b[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">a(<span class="number">114</span>, <span class="string">&quot;514&quot;</span>, <span class="number">1919</span>, <span class="string">&quot;810&quot;</span>);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">4</span><br><span class="line">114     514     1919    810</span><br></pre></td></tr></table></figure>
</div></div></div></div>

<h3 id="2-string库"><a href="#2-string库" class="headerlink" title="(2) string库"></a><strong>(2) <code>string</code>库</strong></h3><p><code>string</code>库下的函数都是对字符串进行操作的函数。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>char()</code></td>
<td align="center">任意个0~255的整数</td>
<td align="center">将这些整数按ASCII码转换为字符，并拼接</td>
<td align="center"><code>string</code></td>
</tr>
<tr>
<td align="center"><code>byte()</code></td>
<td align="center"><code>string</code> ，整数</td>
<td align="center">取出指定索引的字符，并按ASCII码转换为整数</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>format()</code></td>
<td align="center">格式化字符串，参数</td>
<td align="center">根据格式化字符串生成字符串</td>
<td align="center"><code>string</code></td>
</tr>
<tr>
<td align="center"><code>len()</code></td>
<td align="center"><code>string</code></td>
<td align="center">获取字符串长度</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>reverse()</code></td>
<td align="center"><code>string</code></td>
<td align="center">返回反转的字符串</td>
<td align="center"><code>string</code></td>
</tr>
<tr>
<td align="center"><code>sub()</code></td>
<td align="center"><code>string</code> ，起始索引，结束索引</td>
<td align="center">返回从起始索引（包含）到结束索引（包含）的子串</td>
<td align="center"><code>string</code></td>
</tr>
<tr>
<td align="center"><code>upper()</code></td>
<td align="center"><code>string</code></td>
<td align="center">返回字母全大写的字符串</td>
<td align="center"><code>string</code></td>
</tr>
<tr>
<td align="center"><code>lower()</code></td>
<td align="center"><code>string</code></td>
<td align="center">返回字母全小写的字符串</td>
<td align="center"><code>string</code></td>
</tr>
</tbody></table>
<p>在Lua中，ASCII码为0的字符（即<code>\0</code> ）并不表示字符串的结尾。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="string">&quot;Lacia\0Kouka&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用格式化字符串输出 a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;a = %s&quot;</span>, a));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出 a 的长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;#a = %d&quot;</span>, #a));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;string.len(a) = %d&quot;</span>, <span class="built_in">string</span>.<span class="built_in">len</span>(a)));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试取出第 6 个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;string.byte(a, 6) = 0x%x&quot;</span>, <span class="built_in">string</span>.<span class="built_in">byte</span>(a, <span class="number">6</span>)));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a = LaciaKouka</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a = 11</span></span><br><span class="line">string.len(a) = 11</span><br><span class="line">string.byte(a, 6) = 0x0</span><br></pre></td></tr></table></figure>

<p><code>string</code>库中还有其他的函数，此处不做赘述，详情请查看 <a class="btn" href="http://www.lua.org/manual/5.4/manual.html#6.4 ">Lua官方文档</a> 。</p>
<h3 id="2-io库"><a href="#2-io库" class="headerlink" title="(2) io库"></a><strong>(2) <code>io</code>库</strong></h3><p>Lua将文件流与标准输入输出流全都封装到了<code>io</code>库中。与C一样，Lua也将标准输入输出视为文件流的一种。更严格地说，Lua其实就是使用了C的标准输入输出。在Lua的<code>io</code>库下定义了三个变量：<code>stdin</code> ，<code>stdout</code>和<code>stderr</code> 。这三个文件是默认打开且不可关闭的。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">io</span>.<span class="built_in">stdin</span>));      <span class="comment">-- 查看标准输入流的类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">io</span>.<span class="built_in">stdout</span>));     <span class="comment">-- 查看标准输出流的类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">io</span>.<span class="built_in">stderr</span>));     <span class="comment">-- 查看标准错误流的类型</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">userdata</span><br><span class="line">userdata</span><br><span class="line">userdata</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>数据类型<code>userdata</code></strong></div>

<div style="color:royalblue;"><code>userdata</code>也是Lua中的一种数据类型，用于表示由C/C++所创建的类型。程序员可以将任意C/C++的任意数据类型的数据存储到Lua的<code>userdata</code>类型变量中并调用。此处不做过多赘述。</div>
</div>

<p>Lua的文件流分为两种：一种是隐式的对默认文件进行操作的文件流，一种是显式指定要操作的文件的文件流。以下是<code>io</code>库中常见的函数：</p>
<div class="tabs" id="iofunction"><ul class="nav-tabs"><li class="tab active"><a href="#iofunction-1"><code>io.open()</code></a></li><li class="tab"><a href="#iofunction-2"><code>io.input()</code></a></li><li class="tab"><a href="#iofunction-3"><code>io.output()</code></a></li><li class="tab"><a href="#iofunction-4"><code>io.close()</code></a></li><li class="tab"><a href="#iofunction-5"><code>io.type()</code></a></li><li class="tab"><a href="#iofunction-6"><code>io.write()</code></a></li><li class="tab"><a href="#iofunction-7"><code>io.read()</code></a></li><li class="tab"><a href="#iofunction-8"><code>file:flush()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="iofunction-1"><p><code>io.open()</code>函数用于打开文件并返回文件描述符（也叫文件句柄）。该函数接受两个参数，前者为待打开的文件的路径，后者为打开的模式（ <code>string</code>类型）。常见的打开模式如下：</p>
<ul>
<li><code>"r"</code> ：只读，保留文件原内容（默认）</li>
<li><code>"w"</code> ：只写，清除文件原内容</li>
<li><code>"a"</code> ：只写，保留文件原内容，从文件末尾开始写入（追加模式）</li>
<li><code>"r+"</code> ：读写，保留文件原内容（增强读）</li>
<li><code>"w+"</code> ：读写，清除文件原内容（增强写）</li>
<li><code>"a+"</code> ：读写，保留文件原内容，从文件末尾开始写入（增强追加）</li>
</ul>
<p>当打开失败时，将返回<code>nil</code> 。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以只读模式打开文件</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果打开失败将会返回 nil</span></span><br><span class="line"><span class="comment">-- 如果尝试对 nil 进行文件流，则会抛出异常</span></span><br><span class="line"><span class="comment">-- 建议先检查变量是否为 nil</span></span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">file (00007ffe6fc44a90)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="iofunction-2"><p><code>io.input()</code>函数用于指定默认的输入文件或返回当前默认输入文件。当不传入参数时，该函数返回默认的输入文件；当传入文件描述符时，该函数将该文件设置为默认输入，并返回该文件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">input</span>() == <span class="built_in">io</span>.<span class="built_in">stdin</span>);      <span class="comment">-- 查看初始的默认输入文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">input</span>(a) == a);            <span class="comment">-- 尝试修改默认输入文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">input</span>() == a);             <span class="comment">-- 查看修改后的默认输入文件</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="iofunction-3"><p><code>io.output()</code>函数与<code>io.input()</code>函数类似，只不过前者是用于指定默认的输出文件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">output</span>() == <span class="built_in">io</span>.<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">output</span>(a) == a);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">output</span>() == a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="iofunction-4"><p><code>io.close()</code>函数用于关闭文件，指定的参数应当为待关闭的文件描述符。若不给定参数，则会尝试关闭默认的输出文件。关闭成功将返回<code>true</code> 。</p>
<p>尝试关闭已经关闭的文件时，该函数将抛出异常。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a:<span class="built_in">close</span>());</span><br><span class="line"><span class="built_in">print</span>(a);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">true</span><br><span class="line">file (closed)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="iofunction-5"><p><code>io.type()</code>函数用于检查文件的状态。</p>
<ul>
<li>已打开的文件：返回<code>string</code>类型的<code>"file"</code> 。</li>
<li>已关闭的文件：返回<code>string</code>类型的<code>"closed file"</code> 。</li>
<li>其他：返回<code>nil</code> 。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a, b = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">&quot;./1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> <span class="keyword">or</span> b == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a:<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">type</span>(a));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">type</span>(b));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">type</span>(<span class="string">&quot;114514&quot;</span>));</span><br><span class="line"></span><br><span class="line">b:<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">closed file</span><br><span class="line">file</span><br><span class="line">nil</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="iofunction-6"><p><code>io.write()</code>用于向默认输出文件写入内容。若使用<code>file:write()</code> ，则会向指定的文件写入内容。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 默认输出文件是标准输出流</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;114&quot;</span>, <span class="string">&quot;514&quot;</span>, <span class="number">1919</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"> lua Hello.lua</span></span><br><span class="line">1145141919</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="iofunction-7"><p><code>io.read()</code>用于从默认输入文件读取内容。若使用<code>file:read()</code> ，则会从指定的文件读取内容。该函数接受可变长度的参数，这些参数用于控制读取的内容或读取的长度。可用的选项有：</p>
<ul>
<li><code>"n"</code> ：读取一个数字</li>
<li><code>"a"</code> ：从当前位置开始读取整个文件，若在文件末尾则返回空字符串。</li>
<li><code>"l"</code> ：（默认）读取一行并忽略行结束标记，若在文件末尾则返回<code>nil</code> 。</li>
<li><code>"L"</code> ：读取一行并保留行结束标记，若在文件末尾则返回<code>nil</code> 。</li>
<li>整数：读取一个不超过这个数量字节数的字符串，若在文件末尾则返回<code>nil</code> 。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 依次读取 4 个字符、数字（尽可能长）、读取至行末</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Input = %s, %d, %s&quot;</span>, <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="number">4</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;l&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">ABCD114514A1919810</span><br><span class="line">Input = ABCD, 114514, A1919810</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="iofunction-8"><p>Lua的文件流是有缓存的。默认是每次写入换行符时再执行真正的写入（这个默认行为可以改变，但此处不做赘述）。在写入文件后关闭文件前，建议先执行<code>file:flush()</code>函数以立即写入缓存的数据。</p></div></div></div>

<h3 id="3-math库"><a href="#3-math库" class="headerlink" title="(3) math库"></a><strong>(3) <code>math</code>库</strong></h3><p><code>math</code>库是一个用于数学计算的库。其中所有的函数均不会改变参数的值。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>abs()</code></td>
<td align="center"><code>number</code></td>
<td align="center">求绝对值</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>ceil()</code></td>
<td align="center"><code>number</code></td>
<td align="center">向上取整</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>floor()</code></td>
<td align="center"><code>number</code></td>
<td align="center">向下取整</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>modf()</code></td>
<td align="center"><code>number</code></td>
<td align="center">分别返回参数的整数部分与小数部分</td>
<td align="center"><code>number</code> ，<code>number</code></td>
</tr>
<tr>
<td align="center"><code>randomseed()</code></td>
<td align="center"><code>number</code> ，<code>number</code>（默认为0）</td>
<td align="center">设置随机数生成器的种子</td>
<td align="center">当前生效的两个种子</td>
</tr>
<tr>
<td align="center"><code>random()</code></td>
<td align="center"><code>number</code>（默认为1） ，<code>number</code></td>
<td align="center">生成给定区间内的随机数，<br>不给定参数时则生成[0,1)之间的浮点数，<br>当两个参数均为整数时，<br>生成的随机数也是整数且生成范围<span style="color:red;">包含</span>第二个参数</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>tointeger()</code></td>
<td align="center">任意变量</td>
<td align="center">尝试将参数转换为整数，转换失败则返回<code>nil</code></td>
<td align="center">整数或者<code>nil</code></td>
</tr>
<tr>
<td align="center"><code>type()</code></td>
<td align="center"><code>number</code></td>
<td align="center">返回数字的类型（ <code>"integer"</code> 、<code>"float"</code>或<code>nil</code> ）</td>
<td align="center"><code>string</code>或<code>nil</code></td>
</tr>
</tbody></table>
<p>下面介绍<code>math</code>库中的一些常量。</p>
<table>
<thead>
<tr>
<th align="center">常量名</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>huge</code></td>
<td align="center">无限大，任何数字均比其小</td>
</tr>
<tr>
<td align="center"><code>maxinteger</code></td>
<td align="center"><code>number</code>所能表示的最大的整数</td>
</tr>
<tr>
<td align="center"><code>mininteger</code></td>
<td align="center"><code>number</code>所能表示的最小的整数</td>
</tr>
<tr>
<td align="center"><code>pi</code></td>
<td align="center">圆周率 $\pi$</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;math.huge = %f&quot;</span>, <span class="built_in">math</span>.<span class="built_in">huge</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;math.maxinteger = %d&quot;</span>, <span class="built_in">math</span>.maxinteger));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;math.mininteger = %d&quot;</span>, <span class="built_in">math</span>.mininteger));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;math.pi = %f&quot;</span>, <span class="built_in">math</span>.<span class="built_in">pi</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">math.huge = inf</span><br><span class="line">math.maxinteger = 9223372036854775807</span><br><span class="line">math.mininteger = -9223372036854775808</span><br><span class="line">math.pi = 3.141593</span><br></pre></td></tr></table></figure>

<p>下述函数是与数学运算相关性非常强的函数：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>exp()</code></td>
<td align="center"><code>number</code></td>
<td align="center">e的次方运算</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>log()</code></td>
<td align="center"><code>number</code> ，<code>number</code>（默认为e）</td>
<td align="center">求对数，第二个参数为底</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>rad()</code></td>
<td align="center"><code>number</code></td>
<td align="center">将角度制转换为弧度制</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>deg()</code></td>
<td align="center"><code>number</code></td>
<td align="center">将弧度制转换为角度制</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>sqrt()</code></td>
<td align="center"><code>number</code></td>
<td align="center">开方运算</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>sin()</code></td>
<td align="center"><code>number</code></td>
<td align="center">弧度制的正弦函数</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>cos()</code></td>
<td align="center"><code>number</code></td>
<td align="center">弧度制的余弦函数</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>tan()</code></td>
<td align="center"><code>number</code></td>
<td align="center">弧度制的正切函数</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>asin()</code></td>
<td align="center"><code>number</code></td>
<td align="center">弧度制的反正弦函数</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>acos()</code></td>
<td align="center"><code>number</code></td>
<td align="center">弧度制的反余弦函数</td>
<td align="center"><code>number</code></td>
</tr>
<tr>
<td align="center"><code>atan()</code></td>
<td align="center"><code>number</code></td>
<td align="center">弧度制的反正切函数</td>
<td align="center"><code>number</code></td>
</tr>
</tbody></table>
<h2 id="四、面向对象"><a href="#四、面向对象" class="headerlink" title="四、面向对象"></a><strong>四、面向对象</strong></h2><p>Lua中提到面向对象，就绕不开 “元表” 和 “元方法” 这两个概念。元表其实就是表，只不过它是作为实例对象的表的原型，或者说作为 “类” 使用。要想设置元表，就需要使用<code>setmetatable()</code>函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建元表</span></span><br><span class="line">HIE = &#123;&#125;;</span><br><span class="line">HIE[<span class="string">&quot;__index&quot;</span>] = HIE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 构造函数</span></span><br><span class="line">HIE.New = <span class="function"><span class="keyword">function</span><span class="params">(Name, Type)</span></span></span><br><span class="line">    <span class="keyword">local</span> temp = &#123;&#125;;</span><br><span class="line">    <span class="built_in">setmetatable</span>(temp, HIE);</span><br><span class="line">    temp.Name = Name;           <span class="comment">-- 设置成员变量</span></span><br><span class="line">    temp.Type = Type;           <span class="comment">-- 设置成员变量</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 成员函数，建议第一个参数为该类的实例对象</span></span><br><span class="line">HIE.Say = <span class="function"><span class="keyword">function</span><span class="params">(This)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;This : Name = %s, Type = %s.&quot;</span>, This.Name, This.Type));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建两个实例对象</span></span><br><span class="line"><span class="keyword">local</span> Lacia = HIE.New(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>);</span><br><span class="line"><span class="keyword">local</span> Kouka = HIE.New(<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Type-001&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用语法糖调用成员函数</span></span><br><span class="line">Lacia:Say();</span><br><span class="line">Kouka:Say();</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">This : Name = Lacia, Type = Type-005.</span><br><span class="line">This : Name = Kouka, Type = Type-001.</span><br></pre></td></tr></table></figure>

<p>上述代码使用了Lua的表中的一个特殊属性—— <code>__index</code>属性。它就是元方法的一种（虽然叫方法，但它可以不是函数）。元方法一般定义在作为元表使用的表中。当某一个表要执行某些特定的操作时，会触发该表的元表中定义的元方法。例如上述代码中，当使用索引<code>Say</code>寻找<code>Lacia</code>表中的元素时，由于<code>Lacia</code>表中并未定义该属性，因此会触发元表的<code>__index</code>元方法。若该元方法为函数，则会将<code>Lacia</code>表与索引传入该方法，索引值即为函数的返回值；若该元方法为表，则会在该表中寻找该索引。</p>
<pre class="mermaid">
graph TD

A[&lt;code&gt;Lacia&lt;&#x2F;code&gt;] --&gt;|寻找属性 &lt;code&gt;Say&lt;&#x2F;code&gt;| B{存在该属性?}
B --&gt;|存在该属性| C(返回该属性)
B --&gt;|不存在该属性| D(访问元表的 &lt;code&gt;__index&lt;&#x2F;code&gt;)
D --&gt; E{元方法是函数还是表?}
E --&gt;|函数| F(调用函数)
E --&gt;|表| G(在该表中查找 &lt;code&gt;Say&lt;&#x2F;code&gt;)

</pre>

<p>元表，就是用于规定一般表的一些特殊行为的表；元方法，就是当执行特定行为时会触发的方法。下述列表列出了一些常用的元方法：</p>
<table>
<thead>
<tr>
<th align="center">元方法名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__add</code></td>
<td align="center">重载<code>+</code>（加法）运算符</td>
</tr>
<tr>
<td align="center"><code>__sub</code></td>
<td align="center">重载<code>-</code>（减法）运算符</td>
</tr>
<tr>
<td align="center"><code>__mul</code></td>
<td align="center">重载<code>*</code>（乘法）运算符</td>
</tr>
<tr>
<td align="center"><code>__div</code></td>
<td align="center">重载<code>/</code>（除法）运算符</td>
</tr>
<tr>
<td align="center"><code>__mod</code></td>
<td align="center">重载<code>%</code>（求余）运算符</td>
</tr>
<tr>
<td align="center"><code>__pow</code></td>
<td align="center">重载<code>^</code>（次方）运算符</td>
</tr>
<tr>
<td align="center"><code>__unm</code></td>
<td align="center">重载<code>-</code>（取负）运算符</td>
</tr>
<tr>
<td align="center"><code>__idiv</code></td>
<td align="center">重载<code>//</code>（整除）运算符</td>
</tr>
<tr>
<td align="center"><code>__band</code></td>
<td align="center">重载<code>&</code>（按位与）运算符</td>
</tr>
<tr>
<td align="center"><code>__bor</code></td>
<td align="center">重载<code>|</code>（按位或）运算符</td>
</tr>
<tr>
<td align="center"><code>__bxor</code></td>
<td align="center">重载<code>~</code>（按位异或）运算符</td>
</tr>
<tr>
<td align="center"><code>__bnot</code></td>
<td align="center">重载<code>~</code>（按位非）运算符</td>
</tr>
<tr>
<td align="center"><code>__shl</code></td>
<td align="center">重载<code><<</code>（逻辑左移）运算符</td>
</tr>
<tr>
<td align="center"><code>__shr</code></td>
<td align="center">重载<code>>></code>（逻辑右移）运算符</td>
</tr>
<tr>
<td align="center"><code>__concat</code></td>
<td align="center">重载 <code>..</code>（连接）运算符</td>
</tr>
<tr>
<td align="center"><code>__len</code></td>
<td align="center">重载 <code>#</code>（求长度）运算符</td>
</tr>
<tr>
<td align="center"><code>__eq</code></td>
<td align="center">重载 <code>==</code>（相等）运算符</td>
</tr>
<tr>
<td align="center"><code>__lt</code></td>
<td align="center">重载 <code>&lt;</code>（小于）运算符</td>
</tr>
<tr>
<td align="center"><code>__le</code></td>
<td align="center">重载 <code>&lt;=</code>（小于等于）运算符</td>
</tr>
<tr>
<td align="center"><code>__index</code></td>
<td align="center">定义查找不存在的索引值时的行为</td>
</tr>
<tr>
<td align="center"><code>__newindex</code></td>
<td align="center">定义为不存在的索引赋值的操作</td>
</tr>
<tr>
<td align="center"><code>__call</code></td>
<td align="center">定义调用不存在的函数的操作</td>
</tr>
</tbody></table>
<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong><code>__newindex</code>元方法的坑</strong></div>

<div style="color:darkred;"><code>__newindex</code>元方法会在为不存在的索引赋值时触发。如果在该函数内以通常的方式为该索引赋值，将引起循环调用（即 <code>__newindex</code>元方法自己触发自己）。</div>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">HIE = &#123;</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(This, Key, Value)</span></span></span><br><span class="line">        <span class="comment">-- 危险的操作！将导致栈溢出</span></span><br><span class="line">        This[Key] = Value;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">setmetatable</span>(a, HIE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 危险的操作</span></span><br><span class="line">a.b = <span class="number">114514</span>;</span><br></pre></td></tr></table></figure>

<div style="color:darkred;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">D:\LUA\bin\lua.exe: Hello.lua:3: C stack overflow</span><br><span class="line">stack traceback:</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        ...     (skipping 177 levels)</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:3: in metamethod &#x27;newindex&#x27;</span><br><span class="line">        Hello.lua:9: in main chunk</span><br><span class="line">        [C]: in ?</span><br></pre></td></tr></table></figure>

<div style="color:darkred;">正确的在 <code>__newindex</code>元方法内定义新索引值的方法应该是调用<code>rawset()</code>函数。</div>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">HIE = &#123;</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(This, Key, Value)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 使用该方法新定义索引值不会触发元方法</span></span><br><span class="line">        <span class="built_in">rawset</span>(This, Key, Value);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">setmetatable</span>(a, HIE);</span><br><span class="line">a.b = <span class="number">114514</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;a.b = %d&quot;</span>, a.b));</span><br></pre></td></tr></table></figure>

<div style="color:darkred;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a.b = 114514</span><br></pre></td></tr></table></figure>
</div>

<p>Lua的面向对象的最重要部分就是元表与元方法部分。元方法不必全部记住，忘记怎么使用的时候，可以看看 <a class="btn" href="http://www.lua.org/manual/5.4/manual.html#2.4 ">官方文档</a> 。</p>
<h2 id="五、协程"><a href="#五、协程" class="headerlink" title="五、协程"></a><strong>五、协程</strong></h2><p>Lua是单线程的，但Lua可以使用协程。关于协程的定义请参考 <a class="btn" href="https://baike.baidu.com/item/%E5%8D%8F%E7%A8%8B ">百度百科</a> 。协程是非抢占式的，读者需要知道这一点。Lua的协程需要通过<code>coroutine</code>库实现。</p>
<p>新建一个协程，使用<code>coroutine.create()</code>函数即可。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">thread: 00000000007b88d8</span><br><span class="line">thread</span><br></pre></td></tr></table></figure>

<p>可以看出协程虽然被创建了但是并没有被执行。另外，<code>coroutine.create()</code>函数的返回值是一个<code>thread</code>类型的变量。<code>thread</code>类型也是Lua的基础类型之一，代表了一个协程。要开始执行一个协程并传入参数，应当使用<code>coroutine.resume()</code>函数。在协程中调用<code>coroutine.yield()</code>，可以返回值并挂起协程。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 第一块</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;x = %d, y = %d&quot;</span>, x, y));</span><br><span class="line">    <span class="keyword">local</span> a, b = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x + y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 第二块</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;a = %d, b = %d&quot;</span>, a, b));</span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a * b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 第三块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">114514</span>;</span><br><span class="line"><span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试多次调用协程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(a, <span class="number">114</span>, <span class="number">514</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(a, <span class="number">1919</span>, <span class="number">810</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(a, <span class="number">114</span>, <span class="number">514</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(a, <span class="number">114</span>, <span class="number">514</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">x = 114, y = 514</span><br><span class="line">true    628</span><br><span class="line">a = 1919, b = 810</span><br><span class="line">true    1554390</span><br><span class="line">true    114514</span><br><span class="line">false   cannot resume dead coroutine</span><br></pre></td></tr></table></figure>

<p>可以看出第一次调用协程时，传入的参数即为函数的参数，返回值为协程中第一次调用<code>coroutine.yield()</code>的参数。第二次调用协程时，传入的参数将作为<code>coroutine.yield()</code>的返回值。第三次调用时则返回了<code>return</code>关键字定义的返回值。第四次调用则提示，该携程已执行完毕，不可再执行。</p>
<p>在<code>coroutine</code>库下还有一些其他的函数。</p>
<div class="tabs" id="coroutinefunction"><ul class="nav-tabs"><li class="tab active"><a href="#coroutinefunction-1"><code>coroutine.close()</code></a></li><li class="tab"><a href="#coroutinefunction-2"><code>coroutine.status()</code></a></li><li class="tab"><a href="#coroutinefunction-3"><code>coroutine.wrap()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="coroutinefunction-1"><p><code>coroutine.close()</code>用于彻底终止一个挂起的协程。其参数应当为一个<code>thread</code>类型的变量。当终止协程成功时，将返回<code>true</code> ，否则返回<code>false</code>和错误原因。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">yield</span>();          <span class="comment">-- 保证协程挂起但不会结束</span></span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">yield</span>();          <span class="comment">-- 保证协程挂起但不会结束</span></span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">yield</span>();          <span class="comment">-- 保证协程挂起但不会结束</span></span><br><span class="line"><span class="keyword">end</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(a));     <span class="comment">-- 第一次调用协程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">close</span>(a));      <span class="comment">-- 结束协程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(a));     <span class="comment">-- 尝试再次调用协程</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">Hello, world!</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false   cannot resume dead coroutine</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="coroutinefunction-2"><p><code>coroutine.status()</code>函数用于查看指定的协程的状态。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">A = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Inside = %s&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">status</span>(A)));</span><br><span class="line">    <span class="built_in">coroutine</span>.<span class="built_in">yield</span>();</span><br><span class="line"><span class="keyword">end</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Before First = %s&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">status</span>(A)));</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(A);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;After Yield = %s&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">status</span>(A)));</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">close</span>(A);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;After Dead = %s&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">status</span>(A)));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">Before First = suspended</span><br><span class="line">Inside = running</span><br><span class="line">After Yield = suspended</span><br><span class="line">After Dead = dead</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="coroutinefunction-3"><p><code>coroutine.wrap()</code>函数用于把函数 “封装” 成协程。该函数与<code>coroutine.create()</code>函数大同小异。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;a = %s, b = %s&quot;</span>, a, b));</span><br><span class="line">    <span class="keyword">local</span> c, d = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a + b);</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;c = %s, d = %s&quot;</span>, c, d));</span><br><span class="line">    <span class="keyword">local</span> e, f = <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(c * d);</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;e = %s, f = %s&quot;</span>, e, f));</span><br><span class="line">    <span class="keyword">return</span> e ^ f;</span><br><span class="line"><span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;First: %d&quot;</span>, a(<span class="number">114</span>, <span class="number">514</span>)));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Second: %d&quot;</span>, a(<span class="number">114</span>, <span class="number">514</span>)));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Third: %d&quot;</span>, a(<span class="number">2</span>, <span class="number">8</span>)));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua</span></span><br><span class="line">a = 114, b = 514</span><br><span class="line">First: 628</span><br><span class="line">c = 114, d = 514</span><br><span class="line">Second: 58596</span><br><span class="line">e = 2, f = 8</span><br><span class="line">Third: 256</span><br></pre></td></tr></table></figure>

<p><code>coroutine.wrap()</code>函数的返回值是一个函数，调用该返回的函数相当于调用<code>coroutine.resume()</code> ，但不需要传入协程参数。</p></div></div></div>

<h2 id="六、模块化"><a href="#六、模块化" class="headerlink" title="六、模块化"></a><strong>六、模块化</strong></h2><p>Lua可以支持模块化。使用<code>require()</code>函数可以引入其他的 <code>.lua</code>文件。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Main.lua 文件</span></span><br><span class="line"><span class="keyword">local</span> a = <span class="built_in">require</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;a = %d&quot;</span>, a));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hello.lua 文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;This is Hello.lua.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">114514</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Main.lua</span></span><br><span class="line">This is Hello.lua.</span><br><span class="line">a = 114514</span><br></pre></td></tr></table></figure>

<p>上述代码中的<code>Main.lua</code>文件和<code>Hello.lua</code>文件均存放于同一文件夹下。当要加载的模块与当前模块所处的路径不同时，使用相对路径即可（但似乎<span style="color:red;">不能</span>通过相对路径加载上级目录中的模块）。使用<code>require()</code>函数加载的模块不需要加后缀名 <code>.lua</code> ，并且在加载中会执行模块所含有的所有代码，该函数的返回值即为模块的<code>return</code>关键字所返回的值。</p>
<p>在模块化下，局部变量与全局变量就有了明显的不同。被<code>require()</code>函数载入的模块中定义的全局变量，可以在<code>require()</code>函数之后被使用，而局部变量则不行。另外，被<code>require()</code>函数载入过的模块，再次载入时不会重新执行代码，并且返回值将会沿用第一次载入后的返回值。</p>
<p>与<code>require()</code>函数类似的基础库函数还有两个：<code>load()</code>函数与<code>loadfile()</code>函数。这两个函数都是将字符串形式的Lua代码打包，并作为一个函数返回。不同之处在于前者是从<code>string</code>类型的变量中加载代码，后者则是直接从 <code>.lua</code>文件中加载代码。具体详情请参考 <a class="btn" href="http://www.lua.org/manual/5.4/manual.html#pdf-load ">官方文档</a> 。</p>
<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">本文目前只讲解了Lua的基础语法。不论是用于嵌入式开发还是嵌入到C/C++环境中执行，目前的知识储备仍然不够。关于Lua与C/C++的交互，将在其他文章中讲解。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua与C语言交互</title>
    <url>/2022/05/29/LuaWithC/</url>
    <content><![CDATA[<img src="/2022/05/29/LuaWithC/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有C/C++与Lua的基础，并且本文默认读者有良好的计算机组成原理（尤其是堆栈分析）基础。</div>
</div>

<span id="more"></span>

<h2 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a><strong>一、环境配置</strong></h2><p>快速与C&#x2F;C++交互是Lua的特色，不能不品尝。但是配置C调用Lua的环境又很麻烦，此处就顺带记录一下我配置环境时使用的方法。</p>
<h3 id="1-Visual-Studio-Code"><a href="#1-Visual-Studio-Code" class="headerlink" title="(1) Visual Studio Code"></a><strong>(1) Visual Studio Code</strong></h3><p>VS Code本身是一个编辑器而不是IDE ，因此其环境配置相对麻烦。首先使用VS Code编写C ，就一定需要gcc或者clang的某个Windows实现版本。不论是MinGW还是TDM-GCC还是LLVM都可以。因此这一部分也适用于Vim或者其他非集成开发环境下的环境配置。</p>
<p>首先需要在 <a class="btn" href="http://luabinaries.sourceforge.net/ ">官方文档</a> 处下载Lua的库文件。</p>
<p><img src="/2022/05/29/LuaWithC/1.png" alt="1" title="1"></p>
<p>官方的下载地址将会跳转到SourceForge网站。请注意选择的目录应当是Windows Libraries（Windows库文件）和Dynamic（动态编译）。图中展示的文件名是以 “lua-版本号_平台_编译器_lib.zip” 格式命名的。其中，dllw6指的是使用MinGW编译的dll，dll16、dll15、dll14指的是使用微软的C&#x2F;C++编译器编译的dll。具体详情可以搜索 <a class="btn" href="https://cn.bing.com/search?q=MSVC%E7%BC%96%E8%AF%91%E5%99%A8 ">MSVC编译器</a> 。如果还是不明白，选择第二个（下载量最多的那个）就行了。</p>
<p>解压后，将<code>include</code>文件夹<span style="color:red;">内</span>的所有文件放到：</p>
<ul>
<li>MinGW &#x2F; TDM-GCC安装目录的<code>x86_64-w64-mingw32/include</code>目录下</li>
<li>LLVM安装目录的<code>lib/clang/14.0.0/include</code>目录下。其中14.0.0是版本号，可能会因为LLVM的版本不同而有所改变。</li>
</ul>
<p>然后是一个 <code>.dll</code>文件和一个 <code>.lib</code>文件。MinGW &#x2F; TDM-GCC需要 <code>.dll</code>文件，LLVM需要 <code>.lib</code>文件。将需要的文件放到你要编写C语言的文件目录下。然后编写如下代码进行测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lauxlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lua.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lualib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lua_State *Lua = luaL_newstate();       <span class="comment">// 创建新 Lua 环境</span></span><br><span class="line">    lua_close(Lua);                         <span class="comment">// 关闭 Lua 环境</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译命令需要特殊指定：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc Hello.c -o Hello.exe -llua54</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">clang Hello.c -o Hello.exe -llua54</span></span><br></pre></td></tr></table></figure>

<p>其中<code>-l</code>命令是指定额外的动态链接库。gcc默认动态链接库的后缀是 <code>.dll</code>而clang则默认为 <code>.lib</code> 。尝试执行编译后的文件，将会输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./Hello.exe</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>即说明环境配置成功。由于需要手敲命令行，这种编译方式显得繁琐。若不想手敲命令行，那就得使用重火力——Visual Studio 。</p>
<h3 id="2-Visual-Studio"><a href="#2-Visual-Studio" class="headerlink" title="(2) Visual Studio"></a><strong>(2) Visual Studio</strong></h3><p>Visual Studio的环境配置那就相对简单了许多。首先创建一个C++控制台程序的工程。还是按照上述方法下载好Lua的库文件，然后<span style="color:red;">保存到</span>你喜欢的目录下。然后打开工程的属性页面：</p>
<p><img src="/2022/05/29/LuaWithC/2.png" alt="2" title="2"></p>
<p>在C&#x2F;C++ –&gt; 常规 –&gt; 附加包含目录 下添加 <code>.h</code>头文件所在目录。</p>
<p><img src="/2022/05/29/LuaWithC/3.png" alt="3" title="3"></p>
<p>在 链接器 –&gt; 常规 –&gt; 附加库目录 下添加 <code>.dll</code> 和 <code>.lib</code>文件所在目录。</p>
<p><img src="/2022/05/29/LuaWithC/4.png" alt="4" title="4"></p>
<p>在 链接器 –&gt; 输入 –&gt; 附加依赖项 下添加 <code>.lib</code>文件的<span style="color:red;">完整文件名</span>。</p>
<p><img src="/2022/05/29/LuaWithC/5.png" alt="5" title="5"></p>
<p>然后就可以编写C调用Lua的代码了。</p>
<h2 id="二、基础部分"><a href="#二、基础部分" class="headerlink" title="二、基础部分"></a><strong>二、基础部分</strong></h2><p>为什么是C而不是C++？因为Lua是用标准C语言实现的，其为C&#x2F;C++提供的头文件也是标准C语言实现的。用C++去兼容C语言，不如直接使用原生的C语言。</p>
<h3 id="1-命令行参数"><a href="#1-命令行参数" class="headerlink" title="(1) 命令行参数"></a><strong>(1) 命令行参数</strong></h3><p>在讲C调用Lua之前，应该先了解Lua的<code>arg</code>表。<code>arg</code>表是Lua环境下的一个数组形式的表，它存储了从命令行传入的参数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 直接打印参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;arg[0] = %s, arg[1] = %s, arg[2] = %s.&quot;</span>, <span class="built_in">arg</span>[<span class="number">0</span>], <span class="built_in">arg</span>[<span class="number">1</span>], <span class="built_in">arg</span>[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将参数视为可变长度参数，用表进行封装</span></span><br><span class="line"><span class="keyword">local</span> a = &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;a[0] = %s, a[1] = %s, a[2] = %s.&quot;</span>, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>]));</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">lua Hello.lua 114 514</span></span><br><span class="line">arg[0] = Hello.lua, arg[1] = 114, arg[2] = 514.</span><br><span class="line">a[0] = nil, a[1] = 114, a[2] = 514.</span><br></pre></td></tr></table></figure>

<p><del>你终于还是漏出了马脚啊！</del>可以看出<code>arg</code>表的索引为0的值代表了这个文件的名称。虽然C调用的Lua代码中由于缺失解释器而导致不能使用<code>arg</code>表，但用表封装可变长度参数的方法依然可行。接下来就到了痛苦的时刻了。</p>
<h3 id="2-第一个C调用Lua的程序"><a href="#2-第一个C调用Lua的程序" class="headerlink" title="(2) 第一个C调用Lua的程序"></a><strong>(2) 第一个C调用Lua的程序</strong></h3><p>搞不清楚C调用Lua的原理，就没法上手写C调用Lua的代码。</p>
<p>C调用Lua的基本原理，就是先用C为Lua环境分配一个堆空间，这个堆将作为Lua的栈模拟Lua的运行环境。调用Lua文件的基本思路，就是先把Lua文件中的代码作为一个函数入栈，再把参数入栈，然后调用函数时将会自动出栈参数，函数结束时返回的值会自动入栈。这一点与C语言调用函数类似（除了将函数本身入栈以外）。</p>
<p>Lua库文件提供的头文件中，分别声明了原生的C语言的API和使用上述API封装的一些常用函数，后者位于辅助库内，辅助库内的函数前缀均为<code>luaL</code> 。要加载Lua代码，有两种辅助库的函数可供选择：<code>luaL_loadbuffer()</code>和<code>luaL_loadfile()</code> 。前者是直接加载字符串形式的代码，后者是加载 <code>.lua</code>文件。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>luaL_loadfile()</code></td>
<td align="center"><code>lua_State*</code> ，字符串形式的代码，<br>代码长度，这段代码的名称（调试用）</td>
<td align="center">从指定的字符数组中加载代码，命名后压入栈中</td>
</tr>
<tr>
<td align="center"><code>luaL_loadbuffer()</code></td>
<td align="center"><code>lua_State*</code> ，文件路径</td>
<td align="center">从指定的路径下加载文件中的Lua代码到栈中</td>
</tr>
</tbody></table>
<p>要将数据压入栈，得使用原生库的一些函数。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>lua_pushboolean()</code></td>
<td align="center"><code>lua_State*</code> ，<code>int</code></td>
<td align="center">将一个布尔值压入栈中</td>
</tr>
<tr>
<td align="center"><code>lua_pushnil()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">将一个<code>nil</code>压入栈中</td>
</tr>
<tr>
<td align="center"><code>lua_pushstring()</code></td>
<td align="center"><code>lua_State*</code> ，<code>const char*</code></td>
<td align="center">将一个以<code>\0</code>结尾的字符串压入栈中</td>
</tr>
<tr>
<td align="center"><code>lua_pushnumber()</code></td>
<td align="center"><code>lua_State*</code> ，<code>lua_Number</code></td>
<td align="center">将一个Lua中的<code>number</code>型变量压入栈中</td>
</tr>
</tbody></table>
<p><del>我真的搞不懂为什么写C&#x2F;C++的这帮人这么喜欢<code>typedef</code> 。</del>Lua库文件中将<code>lua_Number</code>声明为了<code>double</code>类型的别名。还记得Lua中的<code>number</code>类型占用8个字节吗？C语言中的<code>double</code>类型也占8个字节，且这二者都是浮点数。</p>
<p>另外，在C中调用Lua，若要使用Lua的库函数，需要显式声明要用哪个库。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>luaopen_base()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">显式声明要使用基础库</td>
</tr>
<tr>
<td align="center"><code>luaopen_coroutine()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">显式声明要使用<code>coroutine</code>库</td>
</tr>
<tr>
<td align="center"><code>luaopen_io()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">显式声明要使用<code>io</code>库</td>
</tr>
<tr>
<td align="center"><code>luaopen_math()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">显式声明要使用<code>math</code>库</td>
</tr>
<tr>
<td align="center"><code>luaopen_string()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">显式声明要使用<code>string</code>库</td>
</tr>
<tr>
<td align="center"><code>luaopen_table()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">显式声明要使用<code>table</code>库</td>
</tr>
<tr>
<td align="center"><code>luaL_openlibs()</code></td>
<td align="center"><code>lua_State*</code></td>
<td align="center">显式声明使用Lua自带的所有库</td>
</tr>
</tbody></table>
<p>讲了这么多API ，不动手写写代码是没法掌握如何运用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lauxlib.h&gt;</span>                    <span class="comment">// Lua 的三个库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lua.h&gt;</span>                        <span class="comment">// Lua 的三个库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lualib.h&gt;</span>                     <span class="comment">// Lua 的三个库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> Buffer[<span class="number">256</span>] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;;           <span class="comment">// 声明缓冲区，暂存从控制台输入的字符</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;                          <span class="comment">// 计数变量</span></span><br><span class="line">    lua_State *Lua = luaL_newstate();   <span class="comment">// 新建 Lua 环境</span></span><br><span class="line"></span><br><span class="line">    luaL_openlibs(Lua);                 <span class="comment">// 声明要加载所有的 Lua库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]: &quot;</span>, i);</span><br><span class="line">        fgets(Buffer, <span class="number">256</span>, <span class="built_in">stdin</span>);      <span class="comment">// 从控制台读取输入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将输入的命令作为函数压入 Lua 栈中</span></span><br><span class="line">        luaL_loadbuffer(Lua, Buffer, <span class="built_in">strlen</span>(Buffer), <span class="string">&quot;Line&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行调用命令，调用结束后会把函数出栈</span></span><br><span class="line">        lua_call(Lua, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_close(Lua);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc Hello.c -o Hello.exe -llua54</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./Hello.exe</span></span><br><span class="line">[1]: a=114514;b=1919810;</span><br><span class="line">[2]: print(string.format(&quot;a = %d, b = %d.&quot;,a,b));</span><br><span class="line">a = 114514, b = 1919810.</span><br><span class="line">[3]:</span><br></pre></td></tr></table></figure>

<p>上述代码实现了一个简陋的交互式开发的Lua控制台。原生的交互式要比上述代码复杂得多，且更加精妙。另外，由于API众多，本文将不会逐个详解，并有可能完全省略一些函数的使用方法。因此，按需阅读 <a class="btn" href="http://www.lua.org/manual/5.4/">Lua官方文档</a> 是必要的。</p>
<h3 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="(3) 错误处理"></a><strong>(3) 错误处理</strong></h3><p>上一小节的代码中并未进行错误处理，一旦Lua代码有问题，整个程序将会因抛出异常而退出。<code>luaL_loadbuffer()</code>这类函数是有返回值的。如果加载成功则返回0 ，否则返回错误代号，并将错误信息压入栈中。因此追加错误处理的版本应该是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lauxlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lua.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lualib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> Buffer[<span class="number">256</span>] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, ReturnValue = <span class="number">0</span>;</span><br><span class="line">    lua_State *Lua = luaL_newstate();</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ErrorCheck</span><span class="params">(lua_State * Lua, <span class="type">int</span> ReturnValue)</span>;      <span class="comment">// 声明错误处理函数</span></span><br><span class="line"></span><br><span class="line">    luaL_openlibs(Lua);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]: &quot;</span>, i);</span><br><span class="line">        fgets(Buffer, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        ReturnValue = luaL_loadbuffer(Lua, Buffer, <span class="built_in">strlen</span>(Buffer), <span class="string">&quot;Line&quot;</span>);</span><br><span class="line">        ErrorCheck(Lua, ReturnValue);           <span class="comment">//错误处理</span></span><br><span class="line"></span><br><span class="line">        ReturnValue = lua_pcall(Lua, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        ErrorCheck(Lua, ReturnValue);           <span class="comment">//错误处理</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_close(Lua);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorCheck</span><span class="params">(lua_State *Lua, <span class="type">int</span> ReturnValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ReturnValue == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Error Code]: %d\n&quot;</span>, ReturnValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_isstring(Lua, <span class="number">-1</span>))      <span class="comment">// 检查栈顶是否为字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将 Lua 栈中的错误信息转换为 C 中的字符串</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *ErrorMessage = lua_tostring(Lua, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Error Info]: %s\n&quot;</span>, ErrorMessage);</span><br><span class="line">        lua_pop(Lua, <span class="number">1</span>);            <span class="comment">// 将错误信息出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应当注意的是，将Lua栈中将某个值转换为C中的数据后，该值并不会出栈。对于默认至于栈顶的错误信息，读取之后需要手动出栈。在执行完代码后清空使用的栈是个好习惯，因为C分配给Lua的栈是有限的。</p>
<h3 id="4-获取函数返回值"><a href="#4-获取函数返回值" class="headerlink" title="(4) 获取函数返回值"></a><strong>(4) 获取函数返回值</strong></h3><p>有时载入的Lua代码中定义了函数，但是执行载入的代码只是执行了一次定义函数的过程，并没有调用函数本身。要想在C中调用Lua的函数，必须将函数定义为全局变量。下述代码为Lua代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Pow = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">return</span> x ^ y;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>在C中调用上述Lua函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lauxlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lua.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;lualib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ReturnValue = <span class="number">0</span>;</span><br><span class="line">    lua_State *Lua = luaL_newstate();</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ErrorCheck</span><span class="params">(lua_State * Lua, <span class="type">int</span> ReturnValue)</span>;</span><br><span class="line"></span><br><span class="line">    luaL_openlibs(Lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 载入代码</span></span><br><span class="line">    ReturnValue = luaL_loadfile(Lua, <span class="string">&quot;./Main.lua&quot;</span>);</span><br><span class="line">    ErrorCheck(Lua, ReturnValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行代码，也就是执行定义函数的过程</span></span><br><span class="line">    ReturnValue = lua_pcall(Lua, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ErrorCheck(Lua, ReturnValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到名为 Pow 的函数，并将其压入栈中</span></span><br><span class="line">    lua_getglobal(Lua, <span class="string">&quot;Pow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压入参数</span></span><br><span class="line">    lua_pushnumber(Lua, <span class="number">11.4</span>);</span><br><span class="line">    lua_pushnumber(Lua, <span class="number">5.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行调用，参数有两个，返回值有一个</span></span><br><span class="line">    ReturnValue = lua_pcall(Lua, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ErrorCheck(Lua, ReturnValue);</span><br><span class="line">    <span class="keyword">if</span> (ReturnValue == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查栈顶是否为 number 型变量</span></span><br><span class="line">        <span class="keyword">if</span> (lua_isnumber(Lua, <span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Result is %.2lf&quot;</span>, lua_tonumber(Lua, <span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lua_close(Lua);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorCheck</span><span class="params">(lua_State *Lua, <span class="type">int</span> ReturnValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ReturnValue == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Error Code]: %d\n&quot;</span>, ReturnValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lua_isstring(Lua, <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *ErrorMessage = lua_tostring(Lua, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Error Info]: %s\n&quot;</span>, ErrorMessage);</span><br><span class="line">        lua_pop(Lua, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc Hello.c -o Hello.exe -llua54</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./Hello.exe</span></span><br><span class="line">Result is 270701.67</span><br></pre></td></tr></table></figure>

<p>上述代码在执行了 <code>.lua</code>中的代码之后，使用<code>lua_getglobal()</code>函数将<code>Pow()</code>函数放到压入栈顶，再压入两个参数后，调用该函数并得到返回值。</p>
<h3 id="5-创建Lua表"><a href="#5-创建Lua表" class="headerlink" title="(5) 创建Lua表"></a><strong>(5) 创建Lua表</strong></h3><p>由于创建表的操作与 “分包” 的操作有重叠之处，此处就一并讲解。加载Lua代码时，往往会载入许多Lua代码，甚至是不同模块的Lua代码。这些代码在本模块内或许可以正常工作，但是一旦一起载入至同一环境下，就很有可能出现命名空间污染的情况。因此， 程序员应当在全局表 <code>_G</code>下创建若干表，将载入的不同Lua代码分配到不同的表下。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>表的环境</strong></div>

<div style="color:goldenrod;">在上文中提到过，C调用Lua代码时需要显式声明要使用Lua的库。若将Lua代码加载到全局表的子表下，则不管是否显式声明使用Lua的库，均不能使用Lua库中的函数。要解决这个问题，需要为子表设置元表，元表的 <code>__index</code>属性值，应为全局表 <code>_G</code>本身。</div>
</div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lua_getglobal(Lua, <span class="string">&quot;_G&quot;</span>);               <span class="comment">// _G</span></span><br><span class="line">lua_pushstring(Lua, <span class="string">&quot;Hello&quot;</span>);           <span class="comment">// _G ; &quot;Hello&quot;</span></span><br><span class="line">lua_newtable(Lua);                      <span class="comment">// _G ; &quot;Hello&quot; ; Hello 表</span></span><br><span class="line">lua_newtable(Lua);                      <span class="comment">// _G ; &quot;Hello&quot; ; Hello 表 ; 元表</span></span><br><span class="line">lua_pushstring(Lua, <span class="string">&quot;__index&quot;</span>);         <span class="comment">// _G ; &quot;Hello&quot; ; Hello 表 ; 元表 ; &quot;__index&quot;</span></span><br><span class="line">lua_getglobal(Lua, <span class="string">&quot;_G&quot;</span>);               <span class="comment">// _G ; &quot;Hello&quot; ; Hello 表 ; 元表 ; &quot;__index&quot; ; _G</span></span><br><span class="line">lua_rawset(Lua, <span class="number">-3</span>);                    <span class="comment">// _G ; &quot;Hello&quot; ; Hello 表 ; 元表</span></span><br><span class="line">lua_setmetatable(Lua, <span class="number">-2</span>);              <span class="comment">// _G ; &quot;Hello&quot; ; Hello 表</span></span><br><span class="line">lua_rawset(Lua, <span class="number">-3</span>);                    <span class="comment">// _G</span></span><br><span class="line">lua_pop(Lua, <span class="number">1</span>);                        <span class="comment">// 空栈</span></span><br><span class="line">luaL_loadfile(Lua, <span class="string">&quot;./Main.lua&quot;</span>);       <span class="comment">// 代码块</span></span><br><span class="line">lua_getglobal(Lua, <span class="string">&quot;Hello&quot;</span>);            <span class="comment">// 代码块 ; Hello 表</span></span><br><span class="line">lua_setupvalue(Lua, <span class="number">-2</span>, <span class="number">1</span>);             <span class="comment">// 代码块</span></span><br><span class="line">lua_call(Lua, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><del>什么栈分析地狱</del>上述代码的注释模拟了Lua栈在执行完该行代码以后的部分栈内容。左侧为栈底，右侧为栈顶。</p>
<ul>
<li><code>lua_rawset()</code>函数用于为指定的表设置键值对。其中，参数指定的表在栈中的位置（若为负数则从栈底向栈顶数），此时的栈顶元素应当为值，栈顶元素下的第一个元素应当为键。设置完毕后，将键与值出栈；</li>
<li><code>lua_setmetatable()</code>函数用于设置指定表的元表。其中，参数指定的是表在栈中的位置，此时的栈顶元素应当为元表。设置完毕后，将元表出栈；</li>
<li><code>lua_setupvalue()</code>函数则用于设置代码块的运行环境。其中，参数指定的是代码块在栈中的位置和要设置为第几个运行环境，此时的栈顶元素应当为一个表。设置完毕后，将表出栈。</li>
</ul>
<p><del>我已经尽量做到生动形象并且简洁了。</del></p>
<p>将上述的代码打包为函数，并测试能代码否正常工作：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Lua 代码，文件名为 Main.lua</span></span><br><span class="line">Hello = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, This is Hello() !&quot;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C 语言的代码，尝试将 Main.lua 中的代码载入 Hello 表中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LoadFile</span><span class="params">(lua_State *Lua, <span class="type">const</span> <span class="type">char</span> *FilePath, <span class="type">const</span> <span class="type">char</span> *PackageName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 测试代码，载入完毕后将会尝试执行它</span></span><br><span class="line">    <span class="type">char</span> TestCode[] = <span class="string">&quot;Hello.Hello();&quot;</span>;</span><br><span class="line"></span><br><span class="line">    lua_State *Lua = luaL_newstate();</span><br><span class="line">    luaL_openlibs(Lua);</span><br><span class="line"></span><br><span class="line">    LoadFile(Lua, <span class="string">&quot;./Main.lua&quot;</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试载入是否成功</span></span><br><span class="line">    luaL_loadbuffer(Lua, TestCode, <span class="built_in">strlen</span>(TestCode), <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    lua_call(Lua, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    lua_close(Lua);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc Hello.c -o Hello.exe -llua54</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./Hello.exe</span></span><br><span class="line">Hello, This is Hello() !</span><br></pre></td></tr></table></figure>

<p><del>在经历了地狱般的栈分析后</del>代码调用成功了。</p>
<h3 id="6-C调用Lua调用C的函数"><a href="#6-C调用Lua调用C的函数" class="headerlink" title="(6) C调用Lua调用C的函数"></a><strong>(6) C调用Lua调用C的函数</strong></h3><p>有时在编写C调用Lua的代码时，希望让Lua调用C的函数（可以用于替换默认的Lua代码中的函数，从而变更Lua代码的行为）。Lua库文件中提供了一个函数用于让Lua调用C的函数—— <code>lua_pushcclosure()</code> 。该函数的参数列表如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_pushcclosure</span><span class="params">(lua_State*, lua_CFunction, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>int</code>型变量指的是这个函数将会有多少个运行环境。<code>lua_CFunction</code>为别名，其原型是一个指向了函数的指针。被指向的函数结构应当如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">a</span><span class="params">(lua_State*)</span>;</span><br></pre></td></tr></table></figure>

<p>其中返回值<code>int</code>类型的变量代表执行成功（1）还是执行失败（0）。即，要使用<code>lua_pushcclosure()</code>函数，只需要在C中构造一个形如上方代码的函数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待潜入 Lua 栈的代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PowToPlus</span><span class="params">(lua_State *Lua)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果栈顶（包含）与这个函数（不包含）之间的元素个数不为2，则返回错误代码 -1</span></span><br><span class="line">    <span class="keyword">if</span> (lua_gettop(Lua) != <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果栈顶的两个元素中存在不为 number 类型的变量</span></span><br><span class="line">    <span class="keyword">if</span> (!lua_isnumber(Lua, <span class="number">-1</span>) || !lua_isnumber(Lua, <span class="number">-2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个栈顶元素值</span></span><br><span class="line">    x = lua_tonumber(Lua, <span class="number">-1</span>);</span><br><span class="line">    y = lua_tonumber(Lua, <span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">    lua_pop(Lua, <span class="number">2</span>);        <span class="comment">// 弹出栈顶的两个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向栈中压入 x+y</span></span><br><span class="line">    lua_pushnumber(Lua, x + y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 Hello() 函数的 Lua 代码</span></span><br><span class="line">    <span class="type">char</span> TestCode[] = <span class="string">&quot;Hello(114,514);&quot;</span>;</span><br><span class="line"></span><br><span class="line">    lua_State *Lua = luaL_newstate();</span><br><span class="line">    luaL_openlibs(Lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 载入 Main.lua 代码</span></span><br><span class="line">    luaL_loadfile(Lua, <span class="string">&quot;./Main.lua&quot;</span>);</span><br><span class="line">    lua_call(Lua, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将全局表中的 &quot;Pow&quot; 命名分配给压入栈的 C 函数</span></span><br><span class="line">    lua_getglobal(Lua, <span class="string">&quot;_G&quot;</span>);</span><br><span class="line">    lua_pushstring(Lua, <span class="string">&quot;Pow&quot;</span>);</span><br><span class="line">    lua_pushcclosure(Lua, PowToPlus, <span class="number">0</span>);</span><br><span class="line">    lua_rawset(Lua, <span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试调用 Hello()</span></span><br><span class="line">    luaL_loadbuffer(Lua, TestCode, <span class="built_in">strlen</span>(TestCode), <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    lua_call(Lua, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    lua_close(Lua);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，位于<code>Main.lua</code>的代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这个函数将被改变</span></span><br><span class="line">Pow = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">return</span> x ^ y;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个函数保持不变，但调用的结果将会大幅改变</span></span><br><span class="line">Hello = <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Result is %.2f.&quot;</span>, Pow(x, y)));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码的输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">gcc Hello.c -o Hello.exe -llua54</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./Hello.exe</span></span><br><span class="line">Result is 628.00.</span><br></pre></td></tr></table></figure>

<p>Lua函数中原本执行次方运算的函数被成功替换为了执行加法的函数。</p>
<h3 id="7-面向对象"><a href="#7-面向对象" class="headerlink" title="(7) 面向对象"></a><strong>(7) 面向对象</strong></h3><p>由于C++的面向对象比较原汁原味，所以这一节将会使用C++与Lua交互。不用担心，本节将以C with class的理念来使用C++，尽可能减少使用C++特有的代码。Lua中面向对象依赖于元表，因此主要的算法思想为：</p>
<ol>
<li>将类的成员函数封装为符合<code>lua_CFunction</code>格式的一般函数，并将其注册在元表的 <code>__index</code>表中。再将该元表放在一个随时可取的 “位置” （直接定义在全局表 <code>_G</code>下并不是最佳方案，因为有可能造成命名空间污染）。</li>
<li>创建实例对象时，在Lua栈上分配该类大小的空间，并对该空间进行初始化。将该对象的元表设置为上一步的元表。</li>
<li>调用成员函数时，将实例对象的指针（若有参数则参数也一并）压入Lua栈，再找到上文定义的表并调用其中定义的函数。</li>
</ol>
<p>Lua库文件非常贴心地提供了能<del>轻松</del>实现上述算法思想的API。我成功调试完下述C++代码花了我6个多小时（绝望）。下文的栈分析将被省略，读者应当尝试<del>体会地狱</del>自行分析。</p>
<h4 id="1-HIE类"><a href="#1-HIE类" class="headerlink" title="1. HIE类"></a><strong>1. <code>HIE</code>类</strong></h4><p>下述代码实现了一个简单的类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>* name;                         <span class="comment">// 姓名</span></span><br><span class="line">        <span class="type">char</span>* type;                         <span class="comment">// 型号</span></span><br><span class="line">        <span class="type">int</span> age;                            <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> ID;                      <span class="comment">// 通过该变量的地址，唯一标识该类</span></span><br><span class="line">        <span class="built_in">HIE</span>();                              <span class="comment">// 构造函数</span></span><br><span class="line">        ~<span class="built_in">HIE</span>();                             <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;                        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span></span>;                 <span class="comment">// 获取对象姓名</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* NewName)</span></span>;     <span class="comment">// 设置对象姓名</span></span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Type</span><span class="params">()</span></span>;                 <span class="comment">// 获取对象型号</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Type</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* NewType)</span></span>;     <span class="comment">// 设置对象型号</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Age</span><span class="params">()</span></span>;                          <span class="comment">// 获取对象年龄</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Age</span><span class="params">(<span class="type">int</span> NewAge)</span></span>;               <span class="comment">// 设置对象年龄</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">SelfIntroduction</span><span class="params">()</span></span>;            <span class="comment">// 成员函数，自我介绍，打印该对象的姓名，型号与年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> HIE::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">HIE::<span class="built_in">HIE</span>()</span><br><span class="line">&#123;</span><br><span class="line">    name = <span class="literal">NULL</span>;</span><br><span class="line">    type = <span class="literal">NULL</span>;</span><br><span class="line">    age = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HIE::~<span class="built_in">HIE</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (type != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HIE::Name</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HIE::Name</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* NewName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(NewName) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(name);</span><br><span class="line">    name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; length - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        name[i] = NewName[i];</span><br><span class="line">    &#125;</span><br><span class="line">    name[length - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HIE::Type</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HIE::Type</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* NewType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(NewType) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (type != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">free</span>(type);</span><br><span class="line">    type = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; length - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        type[i] = NewType[i];</span><br><span class="line">    &#125;</span><br><span class="line">    type[length - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HIE::Age</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HIE::Age</span><span class="params">(<span class="type">int</span> NewAge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    age = NewAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HIE::SelfIntroduction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s, Type: %s, Age: %d\n&quot;</span>, name, type, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-编写NewHIE-函数"><a href="#2-编写NewHIE-函数" class="headerlink" title="2. 编写NewHIE()函数"></a><strong>2. 编写<code>NewHIE()</code>函数</strong></h4><p><code>NewHIE()</code>函数是在Lua代码中的名字。它在C++中的原型是一个可以被<code>lua_CFunction</code>指针指向的函数。其代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lua_New</span><span class="params">(lua_State* Lua)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若参数个数不为 3 个则执行失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lua_gettop</span>(Lua) != <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若参数顺序（左为栈底，右为栈顶）不为 “整数，字符串，字符串” 则执行失败</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">lua_isinteger</span>(Lua, <span class="number">-1</span>) || !<span class="built_in">lua_isstring</span>(Lua, <span class="number">-2</span>) || !<span class="built_in">lua_isstring</span>(Lua, <span class="number">-2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="type">int</span> age = <span class="built_in">lua_tointeger</span>(Lua, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* type = <span class="built_in">lua_tostring</span>(Lua, <span class="number">-2</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">lua_tostring</span>(Lua, <span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栈中新分配一块内存用于存放实例对象</span></span><br><span class="line">    <span class="type">void</span>* temp = <span class="built_in">lua_newuserdata</span>(Lua, <span class="built_in">sizeof</span>(HIE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下述写法是 C 语言 struct （结构体）的写法，C++中也能使用</span></span><br><span class="line">    <span class="comment">// 但更加标准的 C++ 的写法应该是：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  #include &lt;new&gt;      // 需要头文件</span></span><br><span class="line"><span class="comment">     *  ······</span></span><br><span class="line"><span class="comment">     *  HIE* Target = new(temp)HIE();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HIE* Target = (HIE*)temp;       <span class="comment">// 利用 Lua 栈上分配的空间创建类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于强制类型转换而没有调用构造函数，需要弥补</span></span><br><span class="line">    Target-&gt;<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给成员变量赋值</span></span><br><span class="line">    Target-&gt;<span class="built_in">Name</span>(name);</span><br><span class="line">    Target-&gt;<span class="built_in">Type</span>(type);</span><br><span class="line">    Target-&gt;<span class="built_in">Age</span>(age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下文将会讲述该函数与变量 LUA_REGISTRYINDEX</span></span><br><span class="line">    <span class="built_in">lua_rawgetp</span>(Lua, LUA_REGISTRYINDEX, &amp;HIE::ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为在 Lua 栈上的 HIE 类实例对象设置元表</span></span><br><span class="line">    <span class="built_in">lua_setmetatable</span>(Lua, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lua_rawgetp()</code>函数与<code>lua_rawget()</code>函数类似，也是从在Lua栈里的表中获取给定键的值。但前者的键被特定为了指针。它的参数分别为：Lua栈、要取出值的表在Lua栈中的索引、指针。它的返回值将被压入Lua栈，其值为该指针键对应的值。此处该函数取出的值为在Lua中为<code>HIE</code>类准备好的元表，该元表的 <code>__index</code>表中存放着<code>HIE</code>类的封装的成员函数。关于这个元表是如何注册的，下文将详述。</p>
<p>因为成员变量<code>HIE::ID</code>是该类特有的，且为<code>static</code>的，因此该静态成员变量的地址在整个程序运行时是唯一的，因此可以确保<code>HIE::ID</code>的地址必定唯一且不会污染命名空间。对于C语言，为<code>struct</code>创建一个全局静态变量即可。</p>
<p><code>LUA_REGISTRYINDEX</code>变量是Lua库中所规定的变量。它永远指向同一个表在Lua栈中的位置，且该表与<code>LUA_REGISTRYINDEX</code>变量均由Lua维护。从该常量的名字也可以看出，它所指向的表是专门用于注册函数、元表等值的。当然用户可以将元表注册在全局表 <code>_G</code>下，但是当用户要取出这个元表时，就不得不通过<code>lua_getglobal(Lua, "_G");</code>来获取全局表，再从全局表中取出元表。虽然不是很麻烦，但C++代码本来就够长了，再在各种细节上变长一点，后面的维护可怎么办啊（绝望）。</p>
<h4 id="3-封装成员函数"><a href="#3-封装成员函数" class="headerlink" title="3. 封装成员函数"></a><strong>3. 封装成员函数</strong></h4><p>此处只封装<code>SelfIntroduction()</code>成员函数作为示例。其他成员函数的封装同理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lua_SI</span><span class="params">(lua_State* Lua)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若参数个数不为 1 ，则执行失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lua_gettop</span>(Lua) != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若栈顶元素不为 userdata 类型，则执行失败</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">lua_isuserdata</span>(Lua, <span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 userdata 并强制类型转换为 HIE*</span></span><br><span class="line">    HIE* Target = (HIE*)<span class="built_in">lua_touserdata</span>(Lua, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 SelfIntroduction() 函数</span></span><br><span class="line">    Target-&gt;<span class="built_in">SelfIntroduction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>lua_touserdata()</code>函数将会取出指定位置的<code>userdata</code>型变量。此处将会分为两种情况：</p>
<ul>
<li>该<code>userdata</code>型变量是在Lua栈上分配的。即该<code>userdata</code>型变量不是指针，那么就返回一个指向该变量地址的指针。</li>
<li>该<code>userdata</code>型变量是 “light userdata” ，即该变量是一个指向了其他地方的指针，那么就返回这个指针的值。</li>
</ul>
<p>以下为官方文档对该函数的解释：</p>
<blockquote>
<p>If the value at the given index is a full userdata, returns its memory-block address. If the value is a light userdata, returns its value (a pointer). Otherwise, returns NULL.</p>
</blockquote>
<p>因此可以不在Lua栈上分配整个类的空间，尤其是这个类非常庞大的时候。可以先在C&#x2F;C++的堆上为该类分配空间，然后再仅仅将指向该空间的指针入栈作为返回值即可。执行结果一般不会有什么改变。但在C&#x2F;C++堆上分配的空间，自然是由C&#x2F;C++来维护，也就是用户来维护。当Lua环境被关闭时，在Lua栈上分配的空间将被自动回收，但在C&#x2F;C++堆上分配的空间，却只能由用户手动回收。</p>
<h4 id="4-创建HIE类的元表"><a href="#4-创建HIE类的元表" class="headerlink" title="4. 创建HIE类的元表"></a><strong>4. 创建<code>HIE</code>类的元表</strong></h4><p>下述代码将在Lua栈创建之后就被Lua环境调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lua_CreateMetatable</span><span class="params">(lua_State* Lua)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将 NewHIE() 函数注册到全局表上</span></span><br><span class="line">    <span class="built_in">lua_getglobal</span>(Lua, <span class="string">&quot;_G&quot;</span>);</span><br><span class="line">    <span class="built_in">lua_pushstring</span>(Lua, <span class="string">&quot;NewHIE&quot;</span>);</span><br><span class="line">    <span class="built_in">lua_pushcclosure</span>(Lua, Lua_New, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">lua_rawset</span>(Lua, <span class="number">-3</span>);</span><br><span class="line">    <span class="built_in">lua_pop</span>(Lua, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建元表</span></span><br><span class="line">    <span class="built_in">lua_newtable</span>(Lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 __index 表</span></span><br><span class="line">    <span class="built_in">lua_pushstring</span>(Lua, <span class="string">&quot;__index&quot;</span>);</span><br><span class="line">    <span class="built_in">lua_newtable</span>(Lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将函数 SelfIntroduction() 注册到 __index 表中</span></span><br><span class="line">    <span class="built_in">lua_pushstring</span>(Lua, <span class="string">&quot;SelfIntroduction&quot;</span>);</span><br><span class="line">    <span class="built_in">lua_pushcclosure</span>(Lua, Lua_SI, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">lua_rawset</span>(Lua, <span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 __index 表到元表中</span></span><br><span class="line">    <span class="built_in">lua_rawset</span>(Lua, <span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元表注册到上文所述的表中</span></span><br><span class="line">    <span class="built_in">lua_rawsetp</span>(Lua, LUA_REGISTRYINDEX, &amp;HIE::ID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-主函数"><a href="#5-主函数" class="headerlink" title="5. 主函数"></a><strong>5. 主函数</strong></h4><p>C++的主函数就简单许多了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lua_State* Lua = <span class="built_in">luaL_newstate</span>();</span><br><span class="line">    <span class="built_in">luaL_openlibs</span>(Lua);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 Lua_CreateMetatable() 函数</span></span><br><span class="line">    <span class="built_in">lua_pushcclosure</span>(Lua, Lua_CreateMetatable, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">lua_call</span>(Lua, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 载入 Main.lua 文件并执行</span></span><br><span class="line">    <span class="built_in">luaL_loadfile</span>(Lua, <span class="string">&quot;./Main.lua&quot;</span>);</span><br><span class="line">    <span class="built_in">lua_call</span>(Lua, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lua_close</span>(Lua);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下述代码为<code>Main.lua</code>中的Lua代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- NewHIE() 函数与 SelfIntroduction() 函数都将在 C++ 中注册</span></span><br><span class="line"><span class="keyword">local</span> Lacia = NewHIE(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>, <span class="number">17</span>);</span><br><span class="line">Lacia:SelfIntroduction();</span><br></pre></td></tr></table></figure>

<h4 id="6-执行结果"><a href="#6-执行结果" class="headerlink" title="6. 执行结果"></a><strong>6. 执行结果</strong></h4><p>上述代码的执行结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">g++ Hello.cpp -o Hello.exe -llua54</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">./Hello.exe</span></span><br><span class="line">Name: Lacia, Type: Type-005, Age: 17</span><br></pre></td></tr></table></figure>

<p>上述代码成功地使用Lua调用了C++为Lua准备的构造函数与成员函数。</p>
<p>需要注意的是，在Lua中并不推荐使用面向对象。因为使用 “轻” 的<code>userdata</code>会带来堆内存管理的问题，而使用一般的<code>userdata</code>则会带来更大的空间开销——使用<code>lua_newuserdata()</code>函数分配的空间将至少达到70个字节以上（5.3版本，5.4不知道有没有优化），这对于实例对象较多的大型代码相当不友好。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>交叉语言</category>
        <category>Lua+C</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>编程语言交互</tag>
        <tag>Lua与C交互</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习原理</title>
    <url>/2022/01/18/MachineLearningPrinciple/</url>
    <content><![CDATA[<img src="/2022/01/18/MachineLearningPrinciple/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要高等数学与线性代数基础。</div>
</div>

<span id="more"></span>

<h2 id="结点（Node）"><a href="#结点（Node）" class="headerlink" title="结点（Node）"></a><strong>结点（Node）</strong></h2><p>①每一个结点可以有多个输入，而仅有一个输出。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>结点内的运算</strong></div>

<div style="color:royalblue;">在结点内：

<ol>
<li>给定的输入向量和结点的参数向量做矩阵乘法与矩阵加法。</li>
<li>输入的形状决定了参数的形状。</li>
</ol>
<p>下图中$x$向量为输入，$w$向量为参数，而$b$为偏移量。</p>
<p>$$<br>output&#x3D;<br>\left[<br>    \begin{matrix}<br>    w_1 &amp; w_2 &amp; ··· &amp; w_n<br>    \end{matrix}<br>\right]<br>\times<br>\left[<br>    \begin{matrix}<br>    x_1\<br>    x_2\<br>    ···\<br>    x_n\<br>    \end{matrix}<br>\right]<br>+b<br>$$</p>
</div>
</div>

<p>②这个输出可以输入到下一层的多个节点内。<br>③同一层的结点内的计算模型相同，但是初始化的参数都是随机的。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>同一层的不同结点</strong></div>

<div style="color:royalblue;">例如：某层结点都是$y=wx+b$模型，其中$y$为输出$x$为输入，$a$、$b$均为参数，虽然计算模型都一致，但是$a$、$b$是不一致的。</div>
</div>

<p>在机器学习的相关框架中，结点并不常见。编程人员甚至不需要知道结点这个概念就能编写机器学习的代码。但是仍有必要知道结点的概念以及其工作原理。</p>
<h2 id="层（Layer）"><a href="#层（Layer）" class="headerlink" title="层（Layer）"></a><strong>层（Layer）</strong></h2><p><img src="/2022/01/18/MachineLearningPrinciple/LayerAndNode.png" alt="LayerAndNode 层与结点" title="层与结点"></p>
<p>每一层含可以有多个结点，所有的层均有输入，并会给出输出。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>层的输出</strong></div>

<div style="color:royalblue;">输出的形状与层中的结点个数有关。输出向量长度=结点个数。</div>
</div>

<p>对于用户而言可见的层只有输入层与输出层，中间参与运算的层是不可见的，通常称为隐藏层。</p>
<p>同一层的计算模型或者叫激活函数 <em>（如：ReLu，Sigmoid，Tanh）</em> 相同。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>激活函数的种类</strong></div>

<div style="color:royalblue;">

<ol>
<li>Relu（线性整流函数）<br>线性函数，计算简单快捷，训练时间更短。<br>⚠由于其输入为负数时结果恒为0，所以存在梯度消失情况。</li>
<li>Sigmoid（S型增长曲线）<br>非线性函数，存在指数运算。运算时间长。<br>常见于最后一层最终输出时用于计算概率。<br>⚠不推荐用于隐藏层的训练。</li>
<li>Tanh（双曲正切函数）<br>非线性函数，存在指数运算。运算时间比Sigmoid还长。<br>常见于RNN。<br>⚠不推荐用于隐藏层的训练。</li>
</ol>
</div>
</div>

<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><h3 id="基本条件："><a href="#基本条件：" class="headerlink" title="基本条件："></a><strong>基本条件：</strong></h3><p>给定输入，经过每一层的计算后得到的输出输入给下一层，最终会得到一个唯一的输出结果。</p>
<h3 id="反向传播："><a href="#反向传播：" class="headerlink" title="反向传播："></a><strong>反向传播：</strong></h3><p>①根据每一层的计算模型的函数，选取一个合适的损失评估函数$f$($x$<sub>真实</sub>，$x$<sub>估计</sub>)</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>损失评估函数</strong></div>

<div style="color:royalblue;">也叫做loss函数，它通常是类似$(x-y)^²$之类的评估两个结果相差大不大的函数。规定了loss函数之后，就能知道神经网络的运算结果与真实值的差距大不大。</div>
</div>

<p>②将最终计算的结果$x$<sub>估计</sub>与标准答案$x$<sub>真实</sub>比对，通过损失评估函数计算出差了多少 <em>（也可以不算，计算只是为了查看预测与真实值差了多少）</em>，并分别对每一层的每一个结点中的函数的每一个参数求它对损失评估函数的偏导数。有了偏导数以后就能知道如何修正参数使得损失函数降低，即$x$<sub>估计</sub>将渐渐接近$x$<sub>真实</sub>。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>数学推导过程</strong></div>

<div style="color:royalblue;">假定：

<ul>
<li>神经网络最终只有一个输出</li>
<li>$x_t$为真实值，$x$为预测值（即输出）</li>
<li>$f(x_t,x)$为loss函数</li>
<li>$w_i$为输出层的某个结点的某个参数。</li>
</ul>
<p>则$w_i$对loss函数的偏导数为</p>
<p>$$\frac{\partial f(x_t,x)}{\partial w_i}&#x3D;\frac{\partial f(x_t,x)}{\partial x}\times\frac{\partial x}{\partial w_i}$$</p>
<p>其中：</p>
<ul>
<li>$\frac{\partial f(x_t,x)}{\partial x}$为输出$x$对loss函数的偏导数，易求。</li>
<li>$\frac{\partial x}{\partial w_i}$为$w_i$对于输出$x$的偏导数。上文已经阐述了$w_i$与$x$的关系，这个结果也是容易求得的。</li>
</ul>
<p>对于上一层结点的参数的偏导数，则有如下计算式：</p>
<p>$$\frac{\partial f(x_t,x)}{\partial k_i}&#x3D;\frac{\partial f(x_t,x)}{\partial x}\times\frac{\partial x}{\partial y}\times\frac{\partial y}{\partial k_i}$$</p>
<p>其中：</p>
<ul>
<li>$k_i$为上一层结点的参数</li>
<li>y为上一层结点的输出。</li>
</ul>
<p>这样就能实现对每一层的每一个结点的每一个参数求偏导数，然后每个参数值都减去这个偏导数，就会使得参数逐渐让$x$<sub>估计</sub>接近$x$<sub>真实</sub>，从而实现神经网络的学习效果。</p></div><p></p>
<div style="color:royalblue;"><del>说白了还是基于统计学，丝毫没有人工智能的样子</del></div>
</div>

<p>对每一层的每个结点都如此处理，最终会让所有的参数都逐渐向拟合训练数据的方向靠拢。</p>
<h3 id="学习过程："><a href="#学习过程：" class="headerlink" title="学习过程："></a><strong>学习过程：</strong></h3><p>在大量的重复学习之下 <em>（每一个测试样例都会进行多次计算）</em>，每一次都会对每个参数做些许修正，最终使得在经过大量的训练集训练之后，神经网络的预测值与期望值能达到十分近似。<br><del>仅限线性相关度高的模型</del></p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>机器学习</tag>
        <tag>原理</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础（一）</title>
    <url>/2022/02/15/PythonGrammar01/</url>
    <content><![CDATA[<img src="/2022/02/15/PythonGrammar01/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p>Python语法很简单，以至于我从没系统地学过Python。所以今天打算系统性地边学边做笔记。</p>
<p>Python是一门在由C编写的解释器上运行的解释型语言，这意味着它的性能上限要比C&#x2F;C++低很多。但是Python的好处在于它只需要很少的代码就能实现很强大的功能，并且拥有强大的开源库，就像Linux的shell一样，只需要简短的语句就能安装需要的库，站在巨人的肩上。而C&#x2F;C++的开源库相对较少，配置起来相对麻烦，更要命的是C&#x2F;C++需要冗长的代码才能实现Python很短的代码就能实现的功能。</p>
<p>Python环境推荐使用Anaconda进行安装。</p>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a><strong>二、基础语法</strong></h2><p>Python不需要以 <code>;</code> 分隔语句，因为Python的解释器会将每一行代码看作一条语句，也因此，Python不能在同一行写多条语句。</p>
<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="(1) 变量"></a><strong>(1) 变量</strong></h3><p>Python的变量不需要写类型名，但这不代表Python中不存在变量类型，因为解释器会自己推断变量的类型。不过与JavaScript不同的是，Python好歹会报错，而JavaScript中由隐式类型转换引起的错误则真的令人困惑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">114514</span></span><br><span class="line">j = <span class="number">114.514</span></span><br><span class="line">k = <span class="string">&quot;114514&quot;</span></span><br><span class="line">m = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>上述的代码中，i为 <code>int</code> 类型，j为 <code>float</code> 类型，k为 <code>str</code>（string的简写）类型，m为 <code>bool</code> 类型。这些类型是Python中的基础数据类型。</p>
<p>在Python中，每个变量都至少有三个属性：</p>
<ul>
<li>id，它是变量存放的内存地址。使用内置函数 <code>id()</code> 可以获取它。</li>
<li>type，它是变量的类型。使用内置函数 <code>type()</code> 可以获取它。</li>
<li>value，它是变量的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of i is&quot;</span>, <span class="built_in">type</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of j is&quot;</span>, <span class="built_in">type</span>(j))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of k is&quot;</span>, <span class="built_in">type</span>(k))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;type of m is&quot;</span>, <span class="built_in">type</span>(m))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">type of i is &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">type of j is &lt;class &#x27;float&#x27;&gt;</span><br><span class="line">type of k is &lt;class &#x27;str&#x27;&gt;</span><br><span class="line">type of m is &lt;class &#x27;bool&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>Python中的变量不像C&#x2F;C++一旦规定了类型就不能再次更改。Python中的变量不但随时都能根据赋值的类型而转变类型，而且不会有溢出，并且可以使用 <code>del</code> 关键字来直接删除变量占用的内存，就像C++可以使用 <code>delete</code> 来清除指针指向的空间一样。</p>
<h3 id="2-标准输出流"><a href="#2-标准输出流" class="headerlink" title="(2) 标准输出流"></a><strong>(2) 标准输出流</strong></h3><p>在Python中，可以使用内建函数 <code>print()</code> 来输出至控制台。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-标准格式化字符串"><a href="#1-标准格式化字符串" class="headerlink" title="1. 标准格式化字符串"></a><strong>1. 标准格式化字符串</strong></h4><p>与C&#x2F;C++的 <code>printf()</code> 函数有点相似，Python的 <code>print()</code> 也支持格式化字符串，但语法细节略有差异：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Lacia = <span class="string">&quot;Lacia&quot;</span></span><br><span class="line">Age = <span class="number">17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Her name is %s and is %d years old&quot;</span> % (Lacia, Age))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Her name is Lacia and is 17 years old</span><br></pre></td></tr></table></figure>

<p>参数与格式化字符串之间需要用 <code>%</code> 分隔。这种方式也可以用于赋值字符串。格式化字符串的控制符与C&#x2F;C++&#x2F;C#等语言一致，此处不再赘述。</p>
<p>但不同之处在于，Python内置了基本类型向字符串类型的隐式类型转换。因此可以用 <code>%s</code> 来格式化输出非字符串基本类型变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">114</span></span><br><span class="line">j = <span class="number">114.514</span></span><br><span class="line">k = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i = %s, j = %s, k = %s&quot;</span> % (i, j, k))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = 114, j = 114.514, k = True</span><br></pre></td></tr></table></figure>

<h4 id="2-内插式格式化字符串"><a href="#2-内插式格式化字符串" class="headerlink" title="2. 内插式格式化字符串"></a><strong>2. 内插式格式化字符串</strong></h4><p>这一点与C#略微相似，但是需要在内插式格式化字符串前写上 <code>f</code> 以标记它是内插式的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Name = <span class="string">&quot;Lacia&quot;</span></span><br><span class="line">Age = <span class="number">17</span></span><br><span class="line"><span class="type">Type</span> = <span class="string">&quot;Type-005&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;I&#x27;m <span class="subst">&#123;Name&#125;</span>, <span class="subst">&#123;Age&#125;</span> years old and type is <span class="subst">&#123;<span class="type">Type</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">I&#x27;m Lacia, 17 years old and type is Type-005</span><br></pre></td></tr></table></figure>

<p>与标准格式化字符串一样，这种方式也可以用于赋值字符串，此处不再赘述。</p>
<h4 id="3-结束符"><a href="#3-结束符" class="headerlink" title="3. 结束符"></a><strong>3. 结束符</strong></h4><p>Python的 <code>print()</code> 函数有一个参数 <code>end</code> ，它默认是 <code>\n</code>，因此 <code>print()</code> 函数默认会换行。用户可以自定义这个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>, end=<span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Test Message.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Hello, world!!Test Message.</span><br></pre></td></tr></table></figure>

<p>要想不输出+结束符，那么将 <code>end</code> 参数设置为 <code>""</code> （空字符串）即可。</p>
<h3 id="3-标准输入流"><a href="#3-标准输入流" class="headerlink" title="(3) 标准输入流"></a><strong>(3) 标准输入流</strong></h3><p>Python的输入很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="built_in">input</span>(<span class="string">&quot;Give some input: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i, <span class="string">&quot;, type of i is&quot;</span>, <span class="built_in">type</span>(i))</span><br><span class="line"><span class="comment">#检查i的类型</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Give some input: 114514</span><br><span class="line">i = 114514 , type of i is &lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p><code>input()</code> 函数内的参数为向控制台的输出，该参数可忽略。该函数从控制台接收的输入，全部为 <code>str</code> 类型，因此要对输入的数据做处理，必须使用类型转换。</p>
<h3 id="4-显式类型转换"><a href="#4-显式类型转换" class="headerlink" title="(4) 显式类型转换"></a><strong>(4) 显式类型转换</strong></h3><div class="tabs" id="typeconvert"><ul class="nav-tabs"><li class="tab active"><a href="#typeconvert-1"><code>int()</code></a></li><li class="tab"><a href="#typeconvert-2"><code>float()</code></a></li><li class="tab"><a href="#typeconvert-3"><code>str()</code></a></li><li class="tab"><a href="#typeconvert-4"><code>eval()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="typeconvert-1"><p><code>int()</code> 函数可以将其他数据类型转换为 <code>int</code> 型变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="built_in">int</span>(<span class="string">&quot;16&quot;</span>, base=<span class="number">10</span>)   <span class="comment">#此处不指定也行，默认为10进制</span></span><br><span class="line">j = <span class="built_in">int</span>(<span class="string">&quot;FF&quot;</span>, base=<span class="number">16</span>)   <span class="comment">#指定源数据为16进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i, <span class="string">&quot;, type of i is&quot;</span>, <span class="built_in">type</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j, <span class="string">&quot;, type of j is&quot;</span>, <span class="built_in">type</span>(j))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = 16 , type of i is &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">j = 255 , type of j is &lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>请检查你的待转换变量</strong></div>

<div style="color:goldenrod;">如果待转换的变量不能转换为 <code>int</code> 型变量，将会引发程序异常，并且linter无法察觉这种错误。</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="built_in">int</span>(<span class="string">&quot;114514sodayo&quot;</span>, base=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i, <span class="string">&quot;, type of i is&quot;</span>, <span class="built_in">type</span>(i))</span><br></pre></td></tr></table></figure>

<div style="color:goldenrod;">报错信息为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\Files\Document\Visual Studio Code\Python\Hello.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    i = int(&quot;114514sodayo&quot;, base=10)</span><br><span class="line">ValueError: invalid literal for int() with base 10: &#x27;114514sodayo&#x27;</span><br></pre></td></tr></table></figure>
</div></div><div class="tab-pane" id="typeconvert-2"><p><code>float()</code> 函数可以将其他数据类型转换为 <code>float</code> 型变量。</p>
<p>基本用法与 <code>int()</code> 基本一致，但无法设置源数据的进制，源数据必须为10进制的，</p></div><div class="tab-pane" id="typeconvert-3"><p><code>str()</code> 函数可以将其他数据类型转换为 <code>str</code> 型变量。</p>
<p>Python中基本上所有的数据类型都能转换为 <code>str</code> 类型。</p></div><div class="tab-pane" id="typeconvert-4"><p><code>eval()</code> 函数会自动检测给定的字符串，并试图将其转换为非字符串类型。它也同样存在与 <code>int()</code> 一样的问题。</p></div></div></div>

<h3 id="5-算数运算符"><a href="#5-算数运算符" class="headerlink" title="(5) 算数运算符"></a><strong>(5) 算数运算符</strong></h3><p>Python中没有 <code>++</code> 、 <code>--</code> 运算符。与C&#x2F;C++相同的运算符此处不再赘述。</p>
<ul>
<li><code>//</code>，整除运算</li>
<li><code>**</code>，指数运算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">9</span></span><br><span class="line">j = <span class="number">4</span></span><br><span class="line">k = i / j</span><br><span class="line">m = i // j</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k =&quot;</span>, k, <span class="string">&quot;, m =&quot;</span>, m, <span class="string">&quot;, i**j =&quot;</span>, i**j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">k = 2.25 , m = 2 , i**j = 6561</span><br></pre></td></tr></table></figure>

<p>在Python中，<code>int</code> 型变量相除时，会将其自动隐式类型转换为 <code>float</code> 类型，因此不论是否整除，结果均为 <code>float</code> 类型。</p>
<p>Python中不允许 <code>int</code> 型变量与 <code>str</code> 型变量相加，但当 <code>str</code> 型变量与 <code>int</code> 型变量相乘时，会将 <code>str</code> 复制X次。X为 <code>int</code> 型变量的值，返回值类型为 <code>str</code> 。这个特性是通过运算符的重载实现的。</p>
<h2 id="三、控制流"><a href="#三、控制流" class="headerlink" title="三、控制流"></a><strong>三、控制流</strong></h2><p>Python中没有 <code>&#123;&#125;</code>，区分代码是否在函数或者控制流等语句块内，是用缩进来控制的。Python的一个缩进默认是4个空格，缩进相同的代码会被解释器认为处于同一代码块中。</p>
<h3 id="1-if"><a href="#1-if" class="headerlink" title="(1) if"></a><strong>(1) <code>if</code></strong></h3><p>Python并没有采用 <code>else if</code> 的写法，而是使用了 <code>elif</code> 。<del>C++人狂怒。</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">114514</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">1919</span>:   <span class="comment">#记得一定要写冒号！</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;810!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;114514&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> i == <span class="number">1919810</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1919810!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;114514&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1145141919810&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">1145141919810</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>逻辑运算符</strong></div>

<div style="color:royalblue;">在Python中， <code>114 &lt;= i &lt;= 514</code> 这种写法是符合规范的，并且Python中没有 <code>||</code> 和 <code>&&</code> 运算符，而是以 <code>or</code> 和 <code>and</code> 来代替。</div>
</div>

<p><code>if</code> 还可以简写，作为三目运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">114514</span></span><br><span class="line">j = <span class="number">191810</span></span><br><span class="line">k = i <span class="keyword">if</span> i &gt; j <span class="keyword">else</span> j</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k =&quot;</span>, k)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">k = 191810</span><br></pre></td></tr></table></figure>

<p>上述代码功能为：当 <code>i > j</code> 成立时，k赋值为i；否则赋值为j。</p>
<h3 id="2-while"><a href="#2-while" class="headerlink" title="(2) while"></a><strong>(2) <code>while</code></strong></h3><p>语法细节上虽然与C&#x2F;C++不同，但是大体框架上是一致的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = 1</span><br><span class="line">i = 2</span><br><span class="line">i = 3</span><br><span class="line">i = 4</span><br></pre></td></tr></table></figure>

<p>Python中 <code>break</code> 、 <code>continue</code> 的使用也与C&#x2F;C++几乎一致，但Python的 <code>while</code> 可以搭配 <code>else</code> 。</p>
<p>当 <code>while</code> 是因不满足循环进行条件而退出时，会执行 <code>else</code> 内的语句。而如果是因为 <code>break</code> 导致的退出，则不会执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码相当于C&#x2F;C++的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-for-in"><a href="#3-for-in" class="headerlink" title="(3) for in"></a><strong>(3) <code>for in</code></strong></h3><p>Python中的 <code>for in</code> 循环与C&#x2F;C++的 <code>for</code> 循环有很大差异。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = <span class="string">&quot;114514&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> temp:</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&quot;||&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">1||1||4||5||1||4||</span><br></pre></td></tr></table></figure>

<p><code>for in</code> 循环能遍历可迭代对象（能用形如 <code>[i]</code> 的索引查找元素的对象）中的所有元素。其中比较常见的有字符串、元组、列表、字典等。这些将在下文讲述。</p>
<p>要想让 <code>for in</code> 执行与 <code>while</code> 类似的功能，可以使用 <code>range()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">i = 2</span><br><span class="line">i = 3</span><br><span class="line">i = 4</span><br></pre></td></tr></table></figure>

<h2 id="四、复杂类型"><a href="#四、复杂类型" class="headerlink" title="四、复杂类型"></a><strong>四、复杂类型</strong></h2><p>Python中没有数组，但有三种内置的复杂数据类型：</p>
<ul>
<li>元组</li>
<li>列表</li>
<li>字典</li>
</ul>
<p>它们都能通过索引来查找位于其中的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义元组</span></span><br><span class="line">i = (<span class="number">114</span>, <span class="number">514</span>, <span class="number">19.19</span>, <span class="string">&quot;810&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义列表</span></span><br><span class="line">j = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">19.19</span>, <span class="string">&quot;810&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义字典</span></span><br><span class="line">k = &#123;<span class="number">1</span>: <span class="number">114</span>, <span class="number">2</span>: <span class="number">514</span>, <span class="number">3</span>: <span class="number">19.19</span>, <span class="number">1919</span>: <span class="string">&quot;810&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k =&quot;</span>, k)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i[1] =&quot;</span>, i[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j[2] =&quot;</span>, j[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k[1919] =&quot;</span>, k[<span class="number">1919</span>])</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = (114, 514, 19.19, &#x27;810&#x27;)</span><br><span class="line">j = [114, 514, 19.19, &#x27;810&#x27;]</span><br><span class="line">k = &#123;1: 114, 2: 514, 3: 19.19, 1919: &#x27;810&#x27;&#125;</span><br><span class="line">i[1] = 514</span><br><span class="line">j[2] = 19.19</span><br><span class="line">k[1919] = 810</span><br></pre></td></tr></table></figure>

<p>Python中的字典有点像C++的 <code>map</code> ，存储了一对键值对，键不允许重复但值可以，索引时根据键寻找值。</p>
<p>可迭代对象可以使用如下函数转换为复杂类型：</p>
<ul>
<li><code>tuple()</code>，转换为元组</li>
<li><code>list()</code>，转换为列表</li>
<li><code>dict()</code>，转换为字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;114514&quot;</span></span><br><span class="line">i = <span class="built_in">tuple</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = (&#x27;1&#x27;, &#x27;1&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;1&#x27;, &#x27;4&#x27;)</span><br></pre></td></tr></table></figure>

<p>关于 <code>dict()</code> 的详细使用说明，请参见 <a class="btn" href="https://www.runoob.com/python/python-func-dict.html ">菜鸟教程</a> 。</p>
<h2 id="五、切片"><a href="#五、切片" class="headerlink" title="五、切片"></a><strong>五、切片</strong></h2><p>此切片非Go的 <code>slice</code> 切片，而是截取某些可迭代的对象的一部分。语法大致为：</p>
<p><code>对象[开始:结束:步长]</code></p>
<p>其中对象为可迭代对象，开始是从第几个元素开始截取（包含），结束为截取到第几个元素为止（不包含），步长是截取时，取出某个元素后，再把“指针”向后移多少个元素。</p>
<p>不写开始，默认为0；不写结束，默认截取至尾部（包含）；步长可以忽略，不写步长，默认为1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;123456789&quot;</span></span><br><span class="line">j = i[<span class="number">0</span> : <span class="built_in">len</span>(i) : <span class="number">2</span>]</span><br><span class="line">k = i[<span class="number">4</span>:]</span><br><span class="line">m = i[:-<span class="number">2</span>]   <span class="comment">#截取至倒数第2个元素（不包含）</span></span><br><span class="line">n = i[<span class="built_in">len</span>(i) : <span class="number">0</span> : -<span class="number">2</span>]  <span class="comment">#从后往前截取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k =&quot;</span>, k)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;m =&quot;</span>, m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>, n)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = 13579</span><br><span class="line">k = 56789</span><br><span class="line">m = 1234567</span><br><span class="line">n = 97531</span><br></pre></td></tr></table></figure>

<h2 id="六、字符串函数"><a href="#六、字符串函数" class="headerlink" title="六、字符串函数"></a><strong>六、字符串函数</strong></h2><p>在Python中最常见的数据类型是 <code>str</code> 。因此有必要掌握一些常见的操作字符串的函数。</p>
<div class="tabs" id="stringfunction"><ul class="nav-tabs"><li class="tab active"><a href="#stringfunction-1"><code>find()</code></a></li><li class="tab"><a href="#stringfunction-2"><code>index()</code></a></li><li class="tab"><a href="#stringfunction-3"><code>count()</code></a></li><li class="tab"><a href="#stringfunction-4"><code>replace()</code></a></li><li class="tab"><a href="#stringfunction-5"><code>split()</code></a></li><li class="tab"><a href="#stringfunction-6"><code>join()</code></a></li><li class="tab"><a href="#stringfunction-7"><code>startswith()</code></a></li><li class="tab"><a href="#stringfunction-8"><code>endswith()</code></a></li><li class="tab"><a href="#stringfunction-9"><code>isalpha()</code></a></li><li class="tab"><a href="#stringfunction-10"><code>isdigit()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="stringfunction-1"><p><code>find()</code> 函数用于查找字符串的子串。它有3个参数：子串、开始查找的下标（可忽略）、结束查找的下标（可忽略）,返回值为 <code>int</code> 类型，代表子串第一次出现的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;1145141919810&quot;</span></span><br><span class="line">j = i.find(<span class="string">&quot;98&quot;</span>)</span><br><span class="line">k = i.find(<span class="string">&quot;111&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j, <span class="string">&quot;, k =&quot;</span>, k)</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = 9 , k = -1</span><br></pre></td></tr></table></figure>

<p><code>find()</code> 函数会从左向右查找，如果想从右向左查找，可以使用 <code>rfind()</code> 。</p></div><div class="tab-pane" id="stringfunction-2"><p><code>index()</code> 与 <code>find()</code> 功能一致，参数也一致。但当未找到子串时，<code>index()</code> 会直接引发报错而 <code>find()</code> 则会返回-1。</p>
<p><code>index()</code> 函数会从左向右查找，如果想从右向左查找，可以使用 <code>rindex()</code> 。</p>
<p>该函数也可以用于其它可迭代对象。</p></div><div class="tab-pane" id="stringfunction-3"><p><code>count()</code> 与 <code>find()</code> 参数一致，其返回值为子串出现的次数。如果没有子串则返回0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;1145141919810&quot;</span></span><br><span class="line">j = i.count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = 6</span><br></pre></td></tr></table></figure>

<p>该函数也可以用于其它可迭代对象。</p></div><div class="tab-pane" id="stringfunction-4"><p><code>replace()</code> 函数用于替换子串。它有3个参数：待替换的子串，用于替换的字符串，替换次数（可忽略）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;114514 1919 810 114514 114514&quot;</span></span><br><span class="line">j = i.replace(<span class="string">&quot;114514&quot;</span>, <span class="string">&quot;inm&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = inm 1919 810 inm 114514</span><br></pre></td></tr></table></figure>

<p>如果替换次数大于了子串出现的次数， <code>replace()</code> 将会忽略剩余的替换次数，也不会有报错发生。</p></div><div class="tab-pane" id="stringfunction-5"><p><code>split()</code> 函数用于分隔字符串，返回值是一个列表。它的参数有2个：作为分割符的字符串、分隔次数（可忽略）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;Lacia and Kouka and Method&quot;</span></span><br><span class="line">j = i.split(<span class="string">&quot; and &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = [&#x27;Lacia&#x27;, &#x27;Kouka&#x27;, &#x27;Method&#x27;]</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>split()</code> 函数在分隔时会丢弃分隔符。</p></div><div class="tab-pane" id="stringfunction-6"><p><code>join()</code> 函数与 <code>split()</code> 函数功能相反。参数为列表或元组，其中的所有元素会被调用这个函数的字符串按顺序连接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>]</span><br><span class="line">j = <span class="string">&quot;, &quot;</span>.join(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = Lacia, Kouka, Method</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="stringfunction-7"><p><code>startswith()</code> 用于判断字符串是否以指定的字符串开头。参数为字符串，返回值为 <code>True</code> 或 <code>False</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;1145141919810&quot;</span></span><br><span class="line">i = i.startswith(<span class="string">&quot;114&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = True</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="stringfunction-8"><p><code>endswith()</code> 用于判断字符串是否以指定的字符串结尾。参数与返回值均与 <code>startswith()</code> 一致。</p></div><div class="tab-pane" id="stringfunction-9"><p><code>isalpha()</code> 函数用于判断字符串是否均由字母组成。它没有参数，返回值为 <code>True</code> 或 <code>False</code> 。</p></div><div class="tab-pane" id="stringfunction-10"><p><code>isdigit()</code> 函数用于判断字符串是否均由数字组成。它没有参数，返回值为 <code>True</code> 或 <code>False</code> 。</p></div></div></div>

<p>关于更多字符串的函数，详情请参见 <a class="btn" href="https://www.runoob.com/python/python-strings.html ">菜鸟教程</a> 。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础（二）</title>
    <url>/2022/02/17/PythonGrammar02/</url>
    <content><![CDATA[<img src="/2022/02/17/PythonGrammar02/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="七、复杂类型的操作"><a href="#七、复杂类型的操作" class="headerlink" title="七、复杂类型的操作"></a><strong>七、复杂类型的操作</strong></h2><p>查找某个元素是否在可迭代对象内，可以使用 <code>in</code> 关键字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">145</span>, <span class="string">&quot;4&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;4 in i =&quot;</span>, <span class="number">4</span> <span class="keyword">in</span> i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;145 in i =&quot;</span>, <span class="number">145</span> <span class="keyword">in</span> i)</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">4 in i = False</span><br><span class="line">145 in i = True</span><br></pre></td></tr></table></figure>

<p>与该关键字相反的关键字为 <code>not in</code> 。</p>
<h3 id="1-列表"><a href="#1-列表" class="headerlink" title="(1) 列表"></a><strong>(1) 列表</strong></h3><p>Python中的列表是可变类型。列表类似于数据结构中的线性表，它内置了一些常用函数。</p>
<div class="tabs" id="listfunction"><ul class="nav-tabs"><li class="tab active"><a href="#listfunction-1"><code>append()</code></a></li><li class="tab"><a href="#listfunction-2"><code>extend()</code></a></li><li class="tab"><a href="#listfunction-3"><code>insert()</code></a></li><li class="tab"><a href="#listfunction-4"><code>pop()</code></a></li><li class="tab"><a href="#listfunction-5"><code>remove()</code></a></li><li class="tab"><a href="#listfunction-6"><code>clear()</code></a></li><li class="tab"><a href="#listfunction-7"><code>reverse()</code></a></li><li class="tab"><a href="#listfunction-8"><code>sort()</code></a></li><li class="tab"><a href="#listfunction-9"><code>copy()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="listfunction-1"><p><code>append()</code> 函数用于向列表尾部插入元素。传入的参数不论类型，均会被整体地认为是一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = []</span><br><span class="line">i.append(<span class="string">&quot;114514&quot;</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="listfunction-2"><p><code>extend()</code> 函数用于向列表尾部插入元素。与 <code>append()</code> 不同，传入的参数如果是一个可迭代对象，那么该对象将会被拆分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = []</span><br><span class="line">j = []</span><br><span class="line">i.append(<span class="string">&quot;114514&quot;</span>)</span><br><span class="line">j.extend(<span class="string">&quot;114514&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [&#x27;114514&#x27;]</span><br><span class="line">j = [&#x27;1&#x27;, &#x27;1&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;1&#x27;, &#x27;4&#x27;]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="listfunction-3"><p><code>insert()</code> 函数用于向列表的中间插入元素。该函数有两个参数：插入的位置，待插入的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Lacia&quot;</span>]</span><br><span class="line">i.insert(<span class="number">1</span>, <span class="string">&quot;Method&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [&#x27;Kouka&#x27;, &#x27;Method&#x27;, &#x27;Lacia&#x27;]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="listfunction-4"><p><code>pop()</code> 函数用于删除列表内的元素，并返回。它可以接收一个参数，该参数为待删除元素的索引。如果不传参数则默认删除最后一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Lacia&quot;</span>]</span><br><span class="line">j = i.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = Method</span><br><span class="line">i = [&#x27;Kouka&#x27;, &#x27;Lacia&#x27;]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="listfunction-5"><p>与 <code>pop()</code> 功能类似，但 <code>remove()</code> 接收的参数为一个元素而非索引。该函数会删除列表内的、与参数相等的一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Lacia&quot;</span>]</span><br><span class="line">i.remove(<span class="string">&quot;Method&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [&#x27;Kouka&#x27;, &#x27;Method&#x27;, &#x27;Lacia&#x27;]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="listfunction-6"><p><code>clear()</code> 函数用于清空列表内的所有元素。</p></div><div class="tab-pane" id="listfunction-7"><p><code>reverse()</code> 函数用于反转列表内所有元素的顺序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Lacia&quot;</span>]</span><br><span class="line">i.reverse()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [&#x27;Lacia&#x27;, &#x27;Method&#x27;, &#x27;Kouka&#x27;]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="listfunction-8"><p><code>sort()</code> 函数用于对列表内的元素进行排序。该函数有两个参数：</p>
<ul>
<li>key，是一个函数，用于对待排序的元素进行预处理</li>
<li>reverse，为 <code>True</code> 则从大到小排序，否则从小到大排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>, <span class="number">813</span>]</span><br><span class="line">i.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Key</span>(<span class="params">element</span>) -&gt; <span class="built_in">int</span>:   <span class="comment">#定义函数</span></span><br><span class="line">    <span class="keyword">return</span> element % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i.sort(key=Key, reverse=<span class="literal">False</span>)  <span class="comment">#按个位从小到大排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [1919, 813, 810, 514, 114]</span><br><span class="line">i = [810, 813, 514, 114, 1919]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="listfunction-9"><p><code>copy()</code> 函数用于复制列表。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>值拷贝与值引用</strong></div>

<div style="color:royalblue;">在很多没有指针的语言中，都存在值拷贝与值引用的问题。在Python中，所有的通过 <code>=</code> 运算符进行的变量赋值均为值引用，即复制地址而不是复制数据。</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>, <span class="number">813</span>]</span><br><span class="line">j = i</span><br><span class="line">k = i.copy()</span><br><span class="line">j[<span class="number">2</span>] = <span class="string">&quot;1919810&quot;</span>   <span class="comment">#j与i指向同一地址，因此会影响i</span></span><br><span class="line">k[<span class="number">1</span>] = <span class="string">&quot;114514&quot;</span>   <span class="comment">#k与i处于不同地址，互不影响</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k =&quot;</span>, k)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [114, 514, &#x27;1919810&#x27;, 810, 813]</span><br><span class="line">j = [114, 514, &#x27;1919810&#x27;, 810, 813]</span><br><span class="line">k = [114, &#x27;114514&#x27;, 1919, 810, 813]</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">对于基本变量类型的变量，如 <code>int</code> 型变量使用 <code>=</code> 在变量间赋值时，也是值引用。但是基本变量类型都是不可变类型，这意味着在对它们赋新值的时候会另开一个空间存放数据。</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">114514</span></span><br><span class="line">j = i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;实验一&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i的地址 = 0x%x&quot;</span> % <span class="built_in">id</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j的地址 = 0x%x&quot;</span> % <span class="built_in">id</span>(j))</span><br><span class="line"></span><br><span class="line">j = <span class="number">1919810</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;实验二&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i的地址 = 0x%x&quot;</span> % <span class="built_in">id</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j的地址 = 0x%x&quot;</span> % <span class="built_in">id</span>(j))</span><br><span class="line"></span><br><span class="line">i = <span class="number">813</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;实验三&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i的地址 = 0x%x&quot;</span> % <span class="built_in">id</span>(i))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">实验一</span><br><span class="line">i的地址 = 0x1dc0b036c10</span><br><span class="line">j的地址 = 0x1dc0b036c10</span><br><span class="line">实验二</span><br><span class="line">i的地址 = 0x1dc0b036c10</span><br><span class="line">j的地址 = 0x1dc0b2be650   &lt;===j的地址改变了</span><br><span class="line">实验三</span><br><span class="line">i的地址 = 0x1dc0b2be6b0   &lt;===i的地址改变了</span><br></pre></td></tr></table></figure>
</div></div></div></div>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>del</code> 的妙用</strong></div>

<div style="color:royalblue;">可以使用 <code>del</code> 关键字来只删除列表内的某一个元素，但不会删除列表整体：</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Method&quot;</span>, <span class="string">&quot;Lacia&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> i[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [&#x27;Kouka&#x27;, &#x27;Lacia&#x27;]</span><br></pre></td></tr></table></figure>
</div>

<h3 id="2-元组"><a href="#2-元组" class="headerlink" title="(2) 元组"></a><strong>(2) 元组</strong></h3><p>Python中的元组是不可变类型。这意味着要对元组进行修改，只能“写时复制”，否则将在运行时出现程序异常。</p>
<p>当要定义只有一个元素的元组时，必须要在元素末尾加上 <code>,</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = (<span class="number">114514</span>)   <span class="comment">#如果使用了Formatter，这对括号将被自动删除</span></span><br><span class="line">j = (<span class="number">114514</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Type of i is&quot;</span>, <span class="built_in">type</span>(i))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Type of j is&quot;</span>, <span class="built_in">type</span>(j))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Type of i is &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">Type of j is &lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>虽然元组是不可变类型，但在元组中的列表，是可以被修改的。</p>
<h3 id="3-字典"><a href="#3-字典" class="headerlink" title="(3) 字典"></a><strong>(3) 字典</strong></h3><p>Python中的字典是可变类型。要创建空字典，有两种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = &#123;&#125;</span><br><span class="line">j = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>

<p>Python中的字典也和其它语言的字典一样，有增删改查等操作。</p>
<div class="tabs" id="dictionarycrud"><ul class="nav-tabs"><li class="tab active"><a href="#dictionarycrud-1">新增/修改</a></li><li class="tab"><a href="#dictionarycrud-2">删除</a></li><li class="tab"><a href="#dictionarycrud-3">查找</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dictionarycrud-1"><p>与C++类似，只需要使用 <code>字典[键]=值</code> 这种方式就能新增或者修改。</p></div><div class="tab-pane" id="dictionarycrud-2"><p>要删除某一个键值对，可以使用 <code>del</code> 关键字。要想清空字典，可以使用 <code>clear()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Lacia = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">17</span>, <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;Type-005&quot;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> Lacia[<span class="string">&quot;Name&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Lacia =&quot;</span>, Lacia)</span><br><span class="line">Lacia.clear()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Lacia =&quot;</span>, Lacia)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Lacia = &#123;&#x27;Age&#x27;: 17, &#x27;Type&#x27;: &#x27;Type-005&#x27;&#125;</span><br><span class="line">Lacia = &#123;&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="dictionarycrud-3"><p>可以使用 <code>字典[键]</code> 来查找值。但当字典内不存在键值对的时候，将会直接引起程序异常。更安全的写法应该是使用 <code>get()</code> 函数。该函数有两个参数，第一个参数为键，第二个参数为默认返回值（可忽略，默认为None）。当不存在键值对时将返回第二个参数，如果存在则返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Lacia = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">17</span>, <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;Type-005&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(Lacia.get(<span class="string">&quot;Name&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(Lacia.get(<span class="number">114514</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Lacia</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<p>字典中的 <code>keys()</code> 函数，它的返回值是一个包含了字典内所有键的可迭代对象； <code>values()</code> 函数返回包含了字典内所有值的可迭代对象； <code>items()</code> 函数返回值是一个包含了所有键值对的可迭代对象。可以利用 <code>items</code> 来遍历字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Lacia = &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">17</span>, <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;Type-005&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> Lacia.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key =&quot;</span>, key, <span class="string">&quot;, value =&quot;</span>, value)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">key = Name , value = Lacia</span><br><span class="line">key = Age , value = 17</span><br><span class="line">key = Type , value = Type-005</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="4-集合"><a href="#4-集合" class="headerlink" title="(4) 集合"></a><strong>(4) 集合</strong></h3><p>集合是可变类型。与数学意义上的集合一样，Python中的集合不允许存在相同元素，相同的元素会被自动剔除。要创建空集合，只能使用 <code>set()</code> 函数，因为 <code>&#123;&#125;</code> 创建的是空字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="built_in">set</span>()   <span class="comment">#创建空集合</span></span><br><span class="line">j = &#123;<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>&#125;   <span class="comment">#初始化了的集合</span></span><br></pre></td></tr></table></figure>

<p>集合也封装了一些好用的内置函数。</p>
<div class="tabs" id="setfunction"><ul class="nav-tabs"><li class="tab active"><a href="#setfunction-1"><code>add()</code></a></li><li class="tab"><a href="#setfunction-2"><code>update()</code></a></li><li class="tab"><a href="#setfunction-3"><code>in</code></a></li><li class="tab"><a href="#setfunction-4"><code>remove()</code></a></li><li class="tab"><a href="#setfunction-5"><code>pop()</code></a></li><li class="tab"><a href="#setfunction-6"><code>discard()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="setfunction-1"><p><code>add()</code> 函数用于向集合中添加元素。如果集合中已经存在此元素了，则会忽略。该函数只能添加一个元素，不允许添加列表、字典等可变类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = &#123;<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>&#125;</span><br><span class="line">i.add(<span class="number">114514</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = &#123;514, 810, 114, 114514, 1919&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="setfunction-2"><p><code>update()</code> 函数用于向集合中添加元素。如果集合中已经存在相同元素了，则会忽略。与 <code>add()</code> 不同， <code>update()</code> 函数只接受可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = &#123;<span class="number">114</span>, <span class="number">514</span>&#125;</span><br><span class="line">j = &#123;<span class="number">114</span>, <span class="number">514</span>&#125;</span><br><span class="line">i.add((<span class="number">1919</span>, <span class="number">810</span>))</span><br><span class="line">j.update((<span class="number">1919</span>, <span class="number">810</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = &#123;114, 514, (1919, 810)&#125;</span><br><span class="line">j = &#123;114, 514, 810, 1919&#125;</span><br></pre></td></tr></table></figure>

<p><code>update()</code> 函数能接受列表，它会将列表中的每个元素依次加入集合，而 <code>add()</code> 函数则不接受列表。</p></div><div class="tab-pane" id="setfunction-3"><p><code>in</code> 关键字用于判断指定的元素是否位于集合内。是则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = &#123;<span class="number">114</span>, <span class="number">514</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;114 in i =&quot;</span>, <span class="number">114</span> <span class="keyword">in</span> i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;810 in i =&quot;</span>, <span class="number">810</span> <span class="keyword">in</span> i)</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">114 in i = True</span><br><span class="line">810 in i = False</span><br></pre></td></tr></table></figure>

<p>与 <code>in</code> 关键字功能相反的关键字是 <code>not in</code> 。</p></div><div class="tab-pane" id="setfunction-4"><p><code>remove()</code> 函数用于删除集合中的指定元素。如果不存在该元素将引起程序异常。</p></div><div class="tab-pane" id="setfunction-5"><p><code>pop()</code> 函数将会<span style="color:red;">随机</span>删除集合内的某一个元素，并返回。</p></div><div class="tab-pane" id="setfunction-6"><p><code>discard()</code> 函数用于删除集合中的指定元素。与 <code>remove()</code> 函数不同，当不存在指定的元素时， <code>discard()</code> 不会引发程序异常。</p></div></div></div>

<h3 id="5-公共操作"><a href="#5-公共操作" class="headerlink" title="(5) 公共操作"></a><strong>(5) 公共操作</strong></h3><p>有一些操作是复杂类型通用的操作，例如 <code>in</code> 关键字。</p>
<ul>
<li><code>+</code> 运算符。拼接可迭代对象。</li>
<li><code>*</code> 运算符。复制可迭代对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;1919&quot;</span></span><br><span class="line">j = i * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = 191919191919</span><br></pre></td></tr></table></figure>

<ul>
<li><code>max()</code> 函数。返回可迭代对象中元素的最大值。</li>
<li><code>min()</code> 函数。返回可迭代对象中元素的最小值。</li>
<li><code>range()</code>函数。它的返回值一个可迭代对象，它有三个只能为 <code>int</code> 类型的参数：<ol>
<li>起始值，可忽略，默认为0。</li>
<li>结束值</li>
<li>步长</li>
</ol>
</li>
<li><code>enumerate()</code>函数。它常用于 <code>for in</code> 循环：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [<span class="number">114</span>, <span class="number">514</span>, <span class="number">1919</span>, <span class="number">810</span>]</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(i, start=<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;index =&quot;</span>, index, <span class="string">&quot;, value =&quot;</span>, value)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">index = 1 , value = 114</span><br><span class="line">index = 2 , value = 514</span><br><span class="line">index = 3 , value = 1919</span><br><span class="line">index = 4 , value = 810</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tuple()</code> 函数。将可迭代对象转换为元组。</li>
<li><code>list()</code> 函数。将可迭代对象转换为列表。</li>
<li><code>set()</code> 函数，将可迭代对象转换为集合。</li>
</ul>
<h2 id="八、推导式"><a href="#八、推导式" class="headerlink" title="八、推导式"></a><strong>八、推导式</strong></h2><p>Python的推导式能够生成列表、字典与集合。这是Python的特色，不能不品尝。先直观地体验一下推导式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = [temp ** <span class="number">2</span> <span class="keyword">for</span> temp <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = [0, 1, 4, 9, 16]</span><br></pre></td></tr></table></figure>

<p>上述代码中，没有单独占据一行的 <code>for in</code> 循环即为推导式。该代码等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = []</span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    i.append(temp ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>推导式的基本语法就是将 <code>for in</code> 循环后的 <code>:</code> 删除，将 <code>append()</code> 函数或者与其有相似功能的函数中的表达式写在 <code>for in</code> 之前。推导式也支持 <code>if</code> 与多循环嵌套。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = [i + j <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;temp =&quot;</span>, temp)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">temp = [1, 2, 3, 3, 4, 5, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>

<h2 id="九、函数"><a href="#九、函数" class="headerlink" title="九、函数"></a><strong>九、函数</strong></h2><p>由于Python是解释型语言，解释器会逐行读取代码，因此函数必须在其使用前被定义。</p>
<h3 id="1-声明函数"><a href="#1-声明函数" class="headerlink" title="(1) 声明函数"></a><strong>(1) 声明函数</strong></h3><p>Python中定义函数需要在函数前使用 <code>def</code> 关键字；返回值类型可以忽略，但最好在 <code>-&gt;</code> 之后注明；Python允许有多个返回值，默认为元组类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Function</span>(<span class="params">x, y</span>) -&gt; <span class="built_in">int</span>:   <span class="comment">#一定要加冒号</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Function(<span class="number">114</span>, <span class="number">514</span>))</span><br></pre></td></tr></table></figure>

<p>标注的返回值类型 <code>int</code> 只是一个对开发人员的提示。当你传入 <code>str</code> 类型的变量时，该函数会做拼接处理，并且返回值也为 <code>str</code> 类型。</p>
<h3 id="2-“值传递”与“引用传递”"><a href="#2-“值传递”与“引用传递”" class="headerlink" title="(2) “值传递”与“引用传递”"></a><strong>(2) “值传递”与“引用传递”</strong></h3><p>Python中没有值传递和引用传递，只有可变类型和不可变类型。在使用时可以认为可变类型在传递时为引用传递，不可变类型在传递时为值传递。在底层实际上都是给地址，但不可变类型不允许修改地址中的值，修改值时会新分配一块内存空间，用于存放新的值，原值不变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;参数地址 = 0x%x&quot;</span> % <span class="built_in">id</span>(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">114514</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i的地址 = 0x%x&quot;</span> % <span class="built_in">id</span>(i))</span><br><span class="line">Function(i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i的地址 = 0x1ade24168f0</span><br><span class="line">参数地址 = 0x1ade24168f0</span><br></pre></td></tr></table></figure>

<p>可以看见Python中函数参数的传递实际上和 <code>=</code> 一样，是拷贝地址。</p>
<h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="(3) 全局变量"></a><strong>(3) 全局变量</strong></h3><p>Python的比较标准的、有点C&#x2F;C++风格的写法应该是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上述代码的 <code>main()</code> 函数与为C++中的 <code>main()</code> 函数作用相似。关于上述写法的细节<span style="color:red;">或许</span>会在下文提及，此处不用深入理解。直接写在Python脚本内、函数外的变量即为全局变量。但Python的全局变量与C&#x2F;C++的行为模式不太一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">114514</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)  <span class="comment"># 这一行将会引发报错</span></span><br><span class="line">    i = <span class="number">1919810</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>在注释掉报错的一行后，输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = 114514</span><br></pre></td></tr></table></figure>

<p>全局变量在函数中也不可用，并且也没有被更改。要使用或修改全局变量，必须使用关键字 <code>global</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">114514</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> i   <span class="comment">#声明有一个名称为i的全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line">    i = <span class="number">1919810</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i = 114514</span><br><span class="line">i = 1919810</span><br></pre></td></tr></table></figure>

<h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="(4) 可变参数"></a><strong>(4) 可变参数</strong></h3><p>Python中的函数也可以设置为可变个数的参数，需要使用符号 <code>*</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*para</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;para =&quot;</span>, para)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Type of para =&quot;</span>, <span class="built_in">type</span>(para))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">114</span>, <span class="number">514</span>, <span class="number">19.19</span>, <span class="string">&quot;810&quot;</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">para = (114, 514, 19.19, &#x27;810&#x27;, True)</span><br><span class="line">Type of para = &lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看见其实Python的解释器是把所有的可变参数转换成了一个元组进行传递。</p>
<p>可变参数也可以使用两个 <code>*</code> 符号，以将可变参数设置为可变关键字参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">**para</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;para =&quot;</span>, para)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Type of para =&quot;</span>, <span class="built_in">type</span>(para))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(First=<span class="number">114</span>, Second=<span class="number">514</span>, Third=<span class="number">19.19</span>, Forth=<span class="string">&quot;810&quot;</span>, Fifth=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">para = &#123;&#x27;First&#x27;: 114, &#x27;Second&#x27;: 514, &#x27;Third&#x27;: 19.19, &#x27;Forth&#x27;: &#x27;810&#x27;, &#x27;Fifth&#x27;: True&#125;</span><br><span class="line">Type of para = &lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>可以看出可变关键字参数其实是被转变成了字典进行传递。</p>
<h3 id="5-lambda表达式"><a href="#5-lambda表达式" class="headerlink" title="(5) lambda表达式"></a><strong>(5) lambda表达式</strong></h3><p>许多语言都有其独特的lambda表达式，Python也不例外。lambda表达式可以理解为函数的简写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="keyword">lambda</span> x, i: x ** i</span><br><span class="line"><span class="built_in">print</span>(i(<span class="number">5</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">625</span><br></pre></td></tr></table></figure>

<p>lambda表达式的基本语法结构就是 <code>lambda 参数列表:返回值语句</code> 。lambda表达式支持可变参数，也支持作为三目运算符的 <code>if</code> 关键字。</p>
<p>lambda表达式的重要性体现在函数作为参数的时候。</p>
<h3 id="6-内置高阶函数"><a href="#6-内置高阶函数" class="headerlink" title="(6) 内置高阶函数"></a><strong>(6) 内置高阶函数</strong></h3><p>Python中，函数可以作为参数传入另一个函数，这种函数称为高阶函数。</p>
<div class="tabs" id="lambdafunction"><ul class="nav-tabs"><li class="tab active"><a href="#lambdafunction-1"><code>map()</code></a></li><li class="tab"><a href="#lambdafunction-2"><code>filter()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="lambdafunction-1"><p><code>map()</code> 函数有两个参数：函数、可迭代对象。它的作用是将可迭代对象中的每个元素传入作为参数的函数，并返回一个可迭代对象，该对象保存了每一次调用参数函数的返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;13579&quot;</span></span><br><span class="line">j = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">int</span>(x) ** <span class="number">2</span>, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(j))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">[1, 9, 25, 49, 81]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="lambdafunction-2"><p><code>filter()</code> 函数用于过滤可迭代对象中的元素，参数类型与 <code>map()</code> 一致，返回值是一个可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="string">&quot;A1B3C5D7E9F&quot;</span></span><br><span class="line">j = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="number">48</span> &lt;= <span class="built_in">ord</span>(x) &lt;= <span class="number">57</span>, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(j))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">(&#x27;1&#x27;, &#x27;3&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;9&#x27;)</span><br></pre></td></tr></table></figure></div></div></div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础（三）</title>
    <url>/2022/02/21/PythonGrammar03/</url>
    <content><![CDATA[<img src="/2022/02/21/PythonGrammar03/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有学过一门其它编程语言的基础再看本文。</div>
</div>

<span id="more"></span>

<h2 id="十、文件流"><a href="#十、文件流" class="headerlink" title="十、文件流"></a><strong>十、文件流</strong></h2><p>Python的文件流很简单，类似于C和C++的混合体，但比C&#x2F;C++更简单。</p>
<h3 id="1-文件读写"><a href="#1-文件读写" class="headerlink" title="(1) 文件读写"></a><strong>(1) 文件读写</strong></h3><p>Python中常用的与文件读写相关的函数如下：</p>
<div class="tabs" id="filestream"><ul class="nav-tabs"><li class="tab active"><a href="#filestream-1">打开文件</a></li><li class="tab"><a href="#filestream-2">读取文件</a></li><li class="tab"><a href="#filestream-3">改变文件指针</a></li><li class="tab"><a href="#filestream-4">关闭文件</a></li></ul><div class="tab-content"><div class="tab-pane active" id="filestream-1"><p>Python中打开文件需要使用 <code>open()</code> 函数。该函数是内置函数，与C的 <code>open()</code> 类似，能返回文件描述符。它有两个参数：文件路径（绝对或者相对）、打开模式。</p>
<p>打开模式有如下几种：</p>
<ul>
<li><code>r</code> ，只读，文件不存在时报错，默认为这种模式。</li>
<li><code>r+</code> ，读写，文件指针将放在开头，写入时将逐渐替换原内容。</li>
<li><code>w</code> ，只写，文件不存在时则创建，存在则直接覆盖原文件。</li>
<li><code>w+</code> ，读写，在 <code>w</code> 的基础上追加读取功能。</li>
<li><code>a</code> ，追加，文件不存在时则创建，存在则在原文件后追加内容。</li>
<li><code>b</code> ，以二进制方式打开。<span style="color:red;">不能单独使用，需要配合其它打开模式。</span></li>
</ul></div><div class="tab-pane" id="filestream-2"><p>Python中有 <code>read()</code> 函数可以用于读取。该函数的参数为读取的字节数，可以忽略，忽略时默认为读取整个文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="built_in">open</span>(<span class="string">&quot;Text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">j = i.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = 1145141919810</span><br></pre></td></tr></table></figure>

<p><code>readlines()</code> 函数会以 <code>\n</code> （换行符）为分隔，将文件内容读取成列表。 <code>\n</code> 不会丢弃。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="built_in">open</span>(<span class="string">&quot;Text.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">j = i.readlines()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;j =&quot;</span>, j)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">j = [&#x27;114\n&#x27;, &#x27;514\n&#x27;, &#x27;1919\n&#x27;, &#x27;810&#x27;]</span><br></pre></td></tr></table></figure>

<p>与 <code>readlines()</code> 函数相似， <code>readline()</code> 函数也是按行读取，但一次只读取一行。</p></div><div class="tab-pane" id="filestream-3"><p><code>seek()</code> 函数可以改变文件指针的位置。该函数有两个参数：偏移量、“参考系”。</p>
<p>“参考系”指的是文件指针从哪里开始开始偏移。</p>
<ul>
<li>0，文件开始处</li>
<li>1，当前文件指针处</li>
<li>2，文件按结尾处</li>
</ul></div><div class="tab-pane" id="filestream-4"><p>关闭文件使用 <code>close()</code> 函数即可，它是文件对象的内置函数。</p></div></div></div>

<h3 id="2-os-库"><a href="#2-os-库" class="headerlink" title="(2) os 库"></a><strong>(2) <code>os</code> 库</strong></h3><p>Python的 <code>os</code> 库中含有许多操作文件与文件夹的函数。在使用这个库之前，应该先引用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<div class="tabs" id="osfunction"><ul class="nav-tabs"><li class="tab active"><a href="#osfunction-1"><code>rename()</code></a></li><li class="tab"><a href="#osfunction-2"><code>remove()</code></a></li><li class="tab"><a href="#osfunction-3"><code>mkdir()</code></a></li><li class="tab"><a href="#osfunction-4"><code>rmdir()</code></a></li><li class="tab"><a href="#osfunction-5"><code>getcwd()</code></a></li><li class="tab"><a href="#osfunction-6"><code>chdir()</code></a></li><li class="tab"><a href="#osfunction-7"><code>listdir()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="osfunction-1"><p><code>rename()</code> 函数用于修改文件或文件夹名。该函数有两个参数：目标文件或文件夹路径（相对或绝对）、新文件名。文件不存在时将会引发程序异常。</p></div><div class="tab-pane" id="osfunction-2"><p><code>remove()</code> 函数用于删除文件。只需要将待删除的文件路径（相对或绝对）传入函数即可。文件不存在时将会引发程序异常。</p></div><div class="tab-pane" id="osfunction-3"><p><code>mkdir()</code> 函数用于创建文件夹。参数为文件夹的名称，该名称可以带路径。</p></div><div class="tab-pane" id="osfunction-4"><p><code>rmdir()</code> 函数用于删除文件夹。参数为文件夹的名称，该名称可以带路径。</p></div><div class="tab-pane" id="osfunction-5"><p><code>getcwd()</code> 函数用于获取当前工作目录。</p></div><div class="tab-pane" id="osfunction-6"><p><code>chdir()</code> 函数用于切换当前工作目录。参数为目标工作目录路径。</p></div><div class="tab-pane" id="osfunction-7"><p><code>listdir()</code> 函数用于获取文件夹下所有文件的文件名。参数为目标目录路径，不写则默认为当前工作目录。</p></div></div></div>

<h2 id="十一、面向对象"><a href="#十一、面向对象" class="headerlink" title="十一、面向对象"></a><strong>十一、面向对象</strong></h2><p>Python创建类很简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    temp = <span class="string">&quot;Origin&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Say</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码创建类一个 <code>HIE</code> 类，类中有一个 <code>temp</code> 成员变量和 <code>Say()</code> 成员函数。以这种方式定义的成员变量和成员函数类似于C#的被 <code>static</code> 修饰的成员变量和方法，调用这种成员变量或成员函数只能使用形如 <code>类名.函数名()</code> 的方式调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HIE.Say()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;分隔&quot;</span>)</span><br><span class="line">i = HIE()   <span class="comment">#创建对象</span></span><br><span class="line">i.Say()   <span class="comment">#此处将会引发程序异常</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Hello, world!</span><br><span class="line">分隔</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\Files\Document\Visual Studio Code\Python\Hello.py&quot;, line 9, in &lt;module&gt;</span><br><span class="line">    i.Say()</span><br><span class="line">TypeError: Say() takes 0 positional arguments but 1 was given</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>类成员变量与对象成员变量</strong></div>

<div style="color:royalblue;">上述代码中的成员变量可以通过 <code>对象.成员变量</code> 的方式成功获取，但不能修改。</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EXP</span>:</span><br><span class="line">    temp = <span class="string">&quot;Origin&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Check</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;EXP.temp =&quot;</span>, EXP.temp)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;self.temp =&quot;</span>, self.temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = EXP()</span><br><span class="line">i.temp = <span class="string">&quot;114514&quot;</span></span><br><span class="line">i.Check()</span><br><span class="line">EXP.temp = <span class="string">&quot;1919810&quot;</span></span><br><span class="line">i.Check()</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">EXP.temp = Origin</span><br><span class="line">self.temp = 114514</span><br><span class="line">EXP.temp = 1919810</span><br><span class="line">self.temp = 114514</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">上述代码的异常行为其实只是因为 <code>i.temp = "114514"</code> 这行代码并不是修改变量值，而是<span style="color:red;">新建</span>成员变量。上述代码中，在类中定义的成员变量是类成员变量，而对象新增的成员变量则是对象成员变量。下文将会详述。</div>
</div>

<p>要想使用对象调用成员函数而不是用类名调用成员函数，必须了解什么是 <code>self</code> 。</p>
<h3 id="1-self"><a href="#1-self" class="headerlink" title="(1) self"></a><strong>(1) <code>self</code></strong></h3><p><code>self</code> 是 <code>__self__</code> 的简写。上文中的报错信息，如果过了CET4应该能轻松看懂：“Say()需要0个位置参数，但是给了1个”。Python中对象是作为参数传递给成员函数的，而指代对象本身的参数关键字即为 <code>self</code> 。在调用成员变量时不需要写 <code>self</code> 的参数，因为在使用 <code>.</code> 运算符调用成员函数时，对象就已经确定了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Say</span>(<span class="params">self, Name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, %s!&quot;</span> % Name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = HIE()</span><br><span class="line">i.Say(<span class="string">&quot;world&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<h3 id="2-成员变量"><a href="#2-成员变量" class="headerlink" title="(2) 成员变量"></a><strong>(2) 成员变量</strong></h3><p>成员变量也叫属性。<del>听着像JavaScript？</del>对象的属性可以在类的定义中定义，也可以在类外定义。<del>好家伙JavaScript就是你教坏的是吧？</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = HIE()</span><br><span class="line">i.test = <span class="number">114514</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i.test =&quot;</span>, i.test)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i.test = 114514</span><br></pre></td></tr></table></figure>

<p>在类中定义对象属性的方式与构造函数放在一起。</p>
<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="(3) 构造函数"></a><strong>(3) 构造函数</strong></h3><p><code>__init__()</code> 函数会在类创建对象时被调用，性质相当于构造函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        self.Name = Name</span><br><span class="line">        self.<span class="type">Type</span> = <span class="type">Type</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = HIE(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i.Name = %s, i.Type =%s&quot;</span> % (i.Name, i.<span class="type">Type</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i.Name = Lacia, i.Type =Type-005</span><br></pre></td></tr></table></figure>

<p>上述代码利用了在类外定义对象属性的方式，在类中用 <code>self</code> 定义了对象的属性。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>函数的重载</strong></div>

<div style="color:royalblue;">很不幸，Python并不支持函数的重载。但Python对可变参数的支持很强大。要想使用不同的构造函数，那就使用可变参数吧。</div>
</div>

<h3 id="4-str"><a href="#4-str" class="headerlink" title="(4) __str__()"></a><strong>(4) <code>__str__()</code></strong></h3><p><code>__str__()</code> 函数会在使用 <code>print()</code> 函数直接打印对象时被调用， <code>print()</code> 函数函数会输出 <code>__str__()</code> 函数的返回值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        self.Name = Name</span><br><span class="line">        self.<span class="type">Type</span> = <span class="type">Type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__str__ executed.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.Name&#125;</span> is <span class="subst">&#123;self.<span class="type">Type</span>&#125;</span> type.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = HIE(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">__str__ executed.</span><br><span class="line">Lacia is Type-005 type.</span><br></pre></td></tr></table></figure>

<h3 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="(5) 析构函数"></a><strong>(5) 析构函数</strong></h3><p><code>__del__()</code> 函数将会在使用 <code>del</code> 关键字删除对象时被调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        self.Name = Name</span><br><span class="line">        self.<span class="type">Type</span> = <span class="type">Type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">del</span> self.Name</span><br><span class="line">        <span class="keyword">del</span> self.<span class="type">Type</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Executed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = HIE(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> i</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Executed.</span><br></pre></td></tr></table></figure>

<h3 id="6-继承"><a href="#6-继承" class="headerlink" title="(6) 继承"></a><strong>(6) 继承</strong></h3><p>Python中所有类都继承自基类 <code>object</code> 。当类不写继承时，默认会继承 <code>object</code> 类。子类会有父类的所有成员函数和属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        self.Name = Name</span><br><span class="line">        self.<span class="type">Type</span> = <span class="type">Type</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span>(<span class="title class_ inherited__">HIE</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, world! from <span class="subst">&#123;self.Name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = Lacia(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>)</span><br><span class="line">i.Say()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Hello, world! Lacia</span><br></pre></td></tr></table></figure>

<p>当继承了多个父类时，若父类中有多个同名函数，则调用时会默认调用第一个继承的父类的函数。要查看某个类的继承关系，可以使用类属性 <code>__mro__</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(Lacia.__mro__)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">(&lt;class &#x27;__main__.Lacia&#x27;&gt;, &lt;class &#x27;__main__.HIE&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br></pre></td></tr></table></figure>

<h4 id="1-重写父类方法（多态）"><a href="#1-重写父类方法（多态）" class="headerlink" title="1. 重写父类方法（多态）"></a><strong>1. 重写父类方法（多态）</strong></h4><p>在Python中，子类的成员函数可以与父类的成员函数同名。在调用时，会默认调用子类的成员函数。父类函数在被重写后也能被调用。</p>
<p>上文已经提到了在Python中，成员函数在被调用时，对象也会作为参数进行传递。所以调用成员函数也可以用下述的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        self.Name = Name</span><br><span class="line">        self.<span class="type">Type</span> = <span class="type">Type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, world! from HIE&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span>(<span class="title class_ inherited__">HIE</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, world! from <span class="subst">&#123;self.Name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = Lacia(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>)</span><br><span class="line">Lacia.Say(i)   <span class="comment">#将对象作为参数传递</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Hello, world! from Lacia</span><br></pre></td></tr></table></figure>

<p>因此，想要调用被重写的父类成员函数，可以通过上述方式进行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HIE.Say(i)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Hello, world! from HIE</span><br></pre></td></tr></table></figure>

<h4 id="2-super-函数"><a href="#2-super-函数" class="headerlink" title="2. super() 函数"></a><strong>2. <code>super()</code> 函数</strong></h4><p><code>super()</code> 函数有两个参数：父类类名、 <code>self</code> 。参数可以省略。该函数的功能就是调用父类的成员函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        self.Name = Name</span><br><span class="line">        self.<span class="type">Type</span> = <span class="type">Type</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span>(<span class="title class_ inherited__">HIE</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Name, <span class="type">Type</span>)</span><br><span class="line">        self.Age = <span class="number">17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = Lacia(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Name = <span class="subst">&#123;i.Name&#125;</span>, Type = <span class="subst">&#123;i.<span class="type">Type</span>&#125;</span>, Age = <span class="subst">&#123;i.Age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Name = Lacia, Type = Type-005, Age = 17</span><br></pre></td></tr></table></figure>

<p>比起使用 <code>父类.成员函数(self)</code> 的方式， <code>super()</code> 函数显然方便快捷许多。</p>
<h3 id="7-私有成员"><a href="#7-私有成员" class="headerlink" title="(7) 私有成员"></a><strong>(7) 私有成员</strong></h3><p>Python中没有 <code>private</code> 关键字。在成员名前加上 <code>__</code> （双下划线）后，该成员即为私有。Python中私有的各种特性都与C&#x2F;C++类似：不可被类外函数调用、不可被子类函数调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        self.__Name = Name</span><br><span class="line">        self.__<span class="type">Type</span> = <span class="type">Type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">SI</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Name = <span class="subst">&#123;self.__Name&#125;</span>, Type = <span class="subst">&#123;self.__<span class="type">Type</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lacia</span>(<span class="title class_ inherited__">HIE</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, Name, <span class="type">Type</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Name, <span class="type">Type</span>)</span><br><span class="line">        self.Age = <span class="number">17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = Lacia(<span class="string">&quot;Lacia&quot;</span>, <span class="string">&quot;Type-005&quot;</span>)</span><br><span class="line">i.SI()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Name = Lacia, Type = Type-005</span><br></pre></td></tr></table></figure>

<p>可以看到父类 <code>HIE</code> 的私有属性 <code>__Name</code> 和 <code>__Type</code> 确实被子类继承了。</p>
<h3 id="8-类方法与静态方法"><a href="#8-类方法与静态方法" class="headerlink" title="(8) 类方法与静态方法"></a><strong>(8) 类方法与静态方法</strong></h3><p>Python中的类方法与静态方法都能被对象和类名调用。</p>
<p>上文已经说明了对象属性与类属性的差异。不能用对象去修改类属性，因为解释器将会把它解释为给对象新增一个属性。如果非要通过对象来修改属性，则可以使用类方法。声明类方法时，需要在该方法前面加上关键字 <code>@classmethod</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    Name = <span class="string">&quot;Lacia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod      </span><span class="comment"># 声明类方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Change</span>(<span class="params">self, Name</span>):</span><br><span class="line">        self.Name = Name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod      </span><span class="comment"># 声明类方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;HIE Name =&quot;</span>, self.Name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = HIE()</span><br><span class="line">i.Name = <span class="string">&quot;Method&quot;</span></span><br><span class="line">i.Change(<span class="string">&quot;Kouka&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i Name =&quot;</span>, i.Name)   <span class="comment"># 打印对象属性</span></span><br><span class="line">i.Output()                  <span class="comment"># 打印类属性</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">i Name = Method</span><br><span class="line">HIE Name = Kouka</span><br></pre></td></tr></table></figure>

<p>静态方法则与一般的函数没有差异，只是它必须通过类名或者对象来调用，并且拥有获取该类的私有成员的权限。声明静态方法时，需要在该方法前面加上关键字 <code>@staticmethod</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HIE</span>:</span><br><span class="line">    Name = <span class="string">&quot;Lacia&quot;</span></span><br><span class="line">    __<span class="type">Type</span> = <span class="string">&quot;Type-005&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod      </span><span class="comment"># 声明静态方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Name = <span class="subst">&#123;self.Name&#125;</span>, Type = <span class="subst">&#123;self.__<span class="type">Type</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = HIE()</span><br><span class="line">i.Output(i)     <span class="comment"># 必须传入参数i</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">python Hello.py</span></span><br><span class="line">Name = Lacia, Type = Type-005</span><br></pre></td></tr></table></figure>

<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">此处介绍的只有Python基本语法。当然，异常处理、包制作、网络爬虫等也是Python常用功能，但此处不做介绍。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基础</title>
    <url>/2022/03/01/SQLGrammar/</url>
    <content><![CDATA[<img src="/2022/03/01/SQLGrammar/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">本文采用MySQL作为数据库服务器。建议至少有一门编程语言的学习经验再阅读本文。</div>
</div>

<span id="more"></span>

<h2 id="一、SQL简介"><a href="#一、SQL简介" class="headerlink" title="一、SQL简介"></a><strong>一、SQL简介</strong></h2><p>SQL全称为结构化查询语言（<span style="color:red;">S</span>tructured <span style="color:red;">Q</span>uery <span style="color:red;">L</span>anguage）。它主要用于数据库的管理。SQL语法相对简单，并且数据库大多都对各种主要编程语言提供了接口以方便用字符串形式的SQL语言来管理数据库。</p>
<p>数据库的安装此处不做赘述。</p>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a><strong>二、基础语法</strong></h2><p>安装完MySQL后，需要开启SQL服务并登录到MySQL服务器。在安装时应该已经设置了root权限的密码，此处便可以直接使用root用户登录。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">net start SQL   &lt;===需要管理员权限</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">mysql -u root -p</span></span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>系统服务</strong></div>

<div style="color:royalblue;">在安装MySQL时，MySQL将会把数据库注册为Windows的系统服务，并设定为开机自启。<span style="color:red;">请注意，要手动开启系统服务，必须使用带有管理员权限的cmd或者PowerShell。</span>默认的服务名是 <code>mysql80</code> ，此处我将其设定为了 <code>SQL</code> 。如果你没有更改默认设置，那么启动MySQL系统服务的代码应该为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">net start mysql80</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">如果没有启动MySQL服务就进行登录，将会出现如下报错：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">mysql -u root -p</span></span><br><span class="line">Enter password: ************</span><br><span class="line">ERROR 2003 (HY000): Can&#x27;t connect to MySQL server on &#x27;localhost:3306&#x27; (10061)</span><br></pre></td></tr></table></figure>
</div>

<p>SQL语句不区分大小写，但为了区分数据与SQL的语句，建议SQL的语句全使用大写字母。SQL的每条语句都需要以分号结尾，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure>

<p>当然上述的语句小写也可以正常使用。上述语句将会打印所有的数据库名称：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW DATABASES;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="1-DDL"><a href="#1-DDL" class="headerlink" title="(1) DDL"></a><strong>(1) DDL</strong></h3><h4 id="1-基础语句"><a href="#1-基础语句" class="headerlink" title="1. 基础语句"></a><strong>1. 基础语句</strong></h4><p>DDL，全称为数据定义语言（<span style="color:red;">D</span>ata <span style="color:red;">D</span>efinition <span style="color:red;">L</span>anguage）。它是SQL的一种，用于管理库和表。</p>
<p>操作数据库有下述语句：</p>
<ul>
<li><code>SHOW DATABASES;</code> ，显示所有数据库</li>
<li><code>CREATE DATABASE 数据库名;</code> ，创建数据库</li>
<li><code>DROP DATABASE 数据库名;</code> ，删除数据库</li>
<li><code>USE 数据库名;</code> ，进入数据库</li>
<li><code>SELECT DATABASE();</code> ，查询当前的数据库</li>
</ul>
<p>表是数据库的精髓，不能不品尝。要执行对表的操作，必须进入特定的数据库。</p>
<ul>
<li><code>SHOW TABLES;</code> ，展示当前数据库的所有表</li>
<li><code>DESC 表名;</code> ，查询当前表的结构</li>
<li><code>SHOW CREATE TABLE 表名;</code> ，查询创建该表的语句</li>
<li><code>CREATE TABLE 表名(表结构);</code> ，创建表</li>
</ul>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>表结构</strong></div>

<div style="color:royalblue;">数据库中表的结构应该如下：</div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">属性名<span class="number">1</span> 属性<span class="number">1</span>类型 COMMENT <span class="string">&#x27;说明&#x27;</span>,</span><br><span class="line">属性名<span class="number">2</span> 属性<span class="number">2</span>类型 COMMENT <span class="string">&#x27;说明&#x27;</span>,</span><br><span class="line">······</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">其中，<code>COMMENT</code> 关键字及其后的说明可以省略。它相当于是注释。</div>
</div>

<h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a><strong>2. 数据类型</strong></h4><p>上文提到的属性类型，可以看成是其它编程语言中的变量类型。</p>
<div class="tabs" id="datatype"><ul class="nav-tabs"><li class="tab active"><a href="#datatype-1">整型</a></li><li class="tab"><a href="#datatype-2">浮点型</a></li><li class="tab"><a href="#datatype-3">字符型</a></li><li class="tab"><a href="#datatype-4">日期型</a></li></ul><div class="tab-content"><div class="tab-pane active" id="datatype-1"><p>SQL中的整型类型比较多，但很好记：</p>
<ul>
<li><code>TINYINT</code> ，占用1个字节</li>
<li><code>SMALLINT</code> ，占用2个字节</li>
<li><code>MEDIUMINT</code> ，占用3个字节</li>
<li><code>INT</code> ，占用4个字节</li>
<li><code>BIGINT</code> ，占用8个字节</li>
</ul>
<p>如果想使用无符号类型的整型，可以在类型后面追加 <code>UNSIGNED</code> 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> HIE(</span><br><span class="line">    Age TINYINT UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="datatype-2"><p>浮点型类型相对较少：</p>
<ul>
<li><code>FLOAT</code> ，占用4个字节</li>
<li><code>DOUBLE</code> ，占用8个字节</li>
<li><code>DECIMAL</code> ，占用大小根据精度改变</li>
</ul>
<p>SQL中的 <code>FLOAT</code> 和 <code>DOUBLE</code> 与其它多数语言一样，也存在精度缺陷。要想精确保存小数，应当使用 <code>DECIMAL</code> 。</p>
<p>浮点数也有符号，要想使用无符号浮点型，可以使用 <code>UNSIGNED</code> 关键字。</p>
<p>使用浮点类型时，应当指定它的长度和精度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> HIE(</span><br><span class="line">    Age TINYINT UNSIGNED,</span><br><span class="line">    Price <span class="keyword">DOUBLE</span>(<span class="number">9</span>,<span class="number">2</span>) UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述代码表示 <code>Price</code> 属性是无符号的 <code>DOUBLE</code> 类型，其10进制数字长度≤9，小数位数≤2。</p></div><div class="tab-pane" id="datatype-3"><p>SQL的字符型相对较多：</p>
<ul>
<li><code>CHAR</code> ，定长字符型</li>
<li><code>VARCHAR</code> ，变长字符型</li>
<li><code>BLOB</code> ，二进制</li>
<li><code>TEXT</code> ，文本</li>
</ul>
<p>使用字符类型时应指定其占用的字符数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> HIE(</span><br><span class="line">    Age TINYINT UNSIGNED,</span><br><span class="line">    Price <span class="keyword">DOUBLE</span>(<span class="number">9</span>,<span class="number">2</span>) UNSIGNED,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>CHAR</code> 与 <code>VARCHAR</code></strong></div>

<div style="color:royalblue;">不论是 <code>CHAR</code> 还是 <code>VARCHAR</code> ，其存储的字符长度均不能超过指定的长度。但它们实际占用的字节数不一样。不管存储的字符有多少， <code>CHAR</code> 始终会占用给定的字节数，而 <code>VARCHAR</code> 则会计算存储的字符数，并占用最小的空间。因此 <code>CHAR</code> 的时间性能更好而空间开销更大。</div>
</div></div><div class="tab-pane" id="datatype-4"><p>SQL中的日期型很多，这里就提及比较常用的几种：</p>
<ul>
<li><code>DATE</code> ，年月日</li>
<li><code>TIME</code> ，时分秒</li>
<li><code>TIMESTAMP</code> ，时间戳，年月日时分秒</li>
</ul></div></div></div>

<h4 id="3-属性操作"><a href="#3-属性操作" class="headerlink" title="3. 属性操作"></a><strong>3. 属性操作</strong></h4><p>数据库中表的结构并不是在定义后就不能修改。</p>
<p>要想修改属性，可以使用：</p>
<ul>
<li><code>ALTER TABLE 表名 ADD 属性名;</code> ，添加属性</li>
<li><code>ALTER TABLE 表名 MODIFY 属性名 新类型;</code> ，修改属性的类型</li>
<li><code>ALTER TABLE 表名 CHANGE 属性名 新属性名 新类型名;</code> ，修改属性名及类型</li>
<li><code>ALTER TABLE 表名 DROP 属性名;</code> ，删除属性</li>
</ul>
<p>要想修改表，可以使用：</p>
<ul>
<li><code>ALTER TABLE 表名 RENAME TO 新表名;</code> ，重命名表</li>
<li><code>DROP TABLE 表名;</code> ，删除表</li>
<li><code>TRUNCATE TABLE 表名;</code> ，删除表后再重建表（即清空表中数据）</li>
</ul>
<h3 id="2-DML"><a href="#2-DML" class="headerlink" title="(2) DML"></a><strong>(2) DML</strong></h3><p>DML，全称为数据操作语言（<span style="color:red;">D</span>ata <span style="color:red;">M</span>anipulation <span style="color:red;">L</span>anguage）。它是SQL的一种，用于操作表中的项。</p>
<p>下面的语句中， <code>[]</code> 中的语句代表该语句可省略。</p>
<ul>
<li><code>INSERT 表名 (属性名1, 属性名2, ···) VALUES (属性值1, 属性值2, ···);</code> ，向表中新增项</li>
<li><code>UPDATE 表名 SET 属性名1='属性值1', 属性名2='属性值2', ··· [WHERE 条件];</code> ，修改表中符合 <code>WHERE</code> 关键字后条件的项的属性值</li>
<li><code>DELETE FROM 表名 [WHERE 条件];</code> ，删除表中符合条件的所有项</li>
</ul>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>WHERE</code> 关键字的条件</strong></div>

<div style="color:royalblue;">类似于其它编程语言的控制流，SQL中也存在条件运算符。下面只列举与C++不同的条件运算符：

<ul>
<li><code>BETWEEN ··· AND ···</code> ，在某个范围之间</li>
<li><code>IN(···)</code> ，是括号内的值之一</li>
<li><code>LIKE</code> ，模糊匹配，<code>'_'</code>代表单个字符， <code>'%'</code> 代表任意个字符</li>
<li><code>IS NULL</code> ，是空值</li>
</ul>
</div>
</div>

<h3 id="3-DQL"><a href="#3-DQL" class="headerlink" title="(3) DQL"></a><strong>(3) DQL</strong></h3><p>DQL，全称为数据查询语言（<span style="color:red;">D</span>ata <span style="color:red;">Q</span>uery <span style="color:red;">L</span>anguage）。它是SQL的一种，用于查询数据库中的项。</p>
<h4 id="1-WHERE"><a href="#1-WHERE" class="headerlink" title="1. WHERE"></a><strong>1. <code>WHERE</code></strong></h4><ul>
<li><code>SELECT [DISTINCT] 属性名1 [AS '别名1'], 属性名2, ··· FROM 表名 [WHERE 条件];</code> 查询表中所有项对应的这些属性。<ul>
<li>如果有 <code>DISTINCT</code> 关键字，则不会显示重复结果；</li>
<li>如果有 <code>AS</code> 关键字，则会在显示结果时以别名代替；</li>
<li>如果有 <code>WHERE</code> 关键字，则只会显示符合条件的项。</li>
</ul>
</li>
</ul>
<p><code>AS</code> 关键字不仅可以用于设置属性别名，还能用于设置表的别名。</p>
<h4 id="2-聚合函数"><a href="#2-聚合函数" class="headerlink" title="2. 聚合函数"></a><strong>2. 聚合函数</strong></h4><p><code>SELECT</code> 关键字后也可以不加属性名而是使用函数。关于函数的细节之后再详述，这里只介绍一些能搭配 <code>SELECT</code> 使用的函数。这些函数被称作<span style="color:red;">聚合函数</span>。</p>
<ul>
<li><code>count(属性名)</code> ，返回该属性非空的项个数</li>
<li><code>max(属性名)</code> ，返回该属性的最大值</li>
<li><code>min(属性名)</code> ，返回该属性的最小值</li>
<li><code>avg(属性名)</code> ，返回该属性的平均值</li>
<li><code>sum(属性名)</code> ，返回该属性值的和</li>
</ul>
<h4 id="3-GROUP-BY-与-HAVING"><a href="#3-GROUP-BY-与-HAVING" class="headerlink" title="3. GROUP BY 与 HAVING"></a><strong>3. <code>GROUP BY</code> 与 <code>HAVING</code></strong></h4><p><code>GROUP BY</code> 关键字需要放在 <code>SELECT</code> 语句的最后。它的功能是按照某一属性对项进行分组，结果将会以组来显示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用ctos数据库</span><br><span class="line">USE ctos;</span><br><span class="line"></span><br><span class="line"># 传入一些数据</span><br><span class="line"><span class="keyword">INSERT</span> hie (Name, Type, Age)</span><br><span class="line"><span class="keyword">VALUES</span> (&quot;Lacia&quot;, &quot;Type-005&quot;, <span class="number">17</span>),</span><br><span class="line">    (&quot;Kouka&quot;, &quot;Type-001&quot;, <span class="number">20</span>),</span><br><span class="line">    (&quot;Method&quot;, &quot;Type-004&quot;, <span class="number">18</span>),</span><br><span class="line">    (&quot;Lacia-01&quot;, &quot;Type-005&quot;, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"># 查找数据</span><br><span class="line"><span class="keyword">SELECT</span> Type <span class="keyword">AS</span> <span class="string">&#x27;型号&#x27;</span>,</span><br><span class="line">    <span class="built_in">count</span>(Name) <span class="keyword">AS</span> <span class="string">&#x27;数量&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> hie</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Type;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p><img src="/2022/03/01/SQLGrammar/1.png" alt="1 1" title="1"></p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>图形化数据库</strong></div>

<div style="color:royalblue;">上图显然不是命令行的数据库。数据库也有图形化操作的软件，例如Navicat<del>一个屑中屑</del>与MySQL WorkBench等。但这里我用的是VS Code的插件——SQLTools。<del>为什么VS Code是神。</del></div>
</div>

<p>可以看见， <code>Type</code> 与 <code>count()</code> 均被替换为了别名，并且是以 <code>Type</code> 属性值相同的项为一组进行分组，再进行统计。如果有 <code>WHERE</code> 关键字，则不满足条件的项将不会被纳入统计。</p>
<p><code>HAVING</code> 关键字需要放在 <code>GROUP BY</code> 关键字之后。它与 <code>WHERE</code> 关键字相似，但它是对分组之后的项进行处理，并且 <code>HAVING</code> 可以使用聚合函数进行条件判断。</p>
<h4 id="4-ORDER-BY"><a href="#4-ORDER-BY" class="headerlink" title="4. ORDER BY"></a><strong>4. <code>ORDER BY</code></strong></h4><p>使用 <code>ORDER BY</code> 关键字可以按照某一属性的值对结果进行排序。可以在属性名后加上关键字以确定排序顺序：</p>
<ul>
<li><code>ASC</code> ，升序排序</li>
<li><code>DESC</code> ，降序排序</li>
<li>不加关键字，默认升序排序</li>
</ul>
<p><code>ORDER BY</code> 关键字后可以加多个属性。当前一个属性相同时，会按照后一个属性的排序方式进行排序。你可以为每一个属性设置排序方式。</p>
<h4 id="5-LIMIT"><a href="#5-LIMIT" class="headerlink" title="5. LIMIT"></a><strong>5. <code>LIMIT</code></strong></h4><p><code>LIMIT</code> 关键字用于规定一页展示多少条搜索结果。在不同的数据库系统中，分页功能有不同的关键字，在MySQL中这个关键字就是 <code>LIMIT</code> 。它的用法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT 页号, 每页条目数</span><br></pre></td></tr></table></figure>

<p>其中，页号是从0开始计数的。</p>
<h4 id="6-DQL的编写顺序与执行顺序"><a href="#6-DQL的编写顺序与执行顺序" class="headerlink" title="6. DQL的编写顺序与执行顺序"></a><strong>6. DQL的编写顺序与执行顺序</strong></h4><p>编写顺序：<br><code>SELECT</code>-&gt;<code>FROM</code>-&gt;<code>WHERE</code>-&gt;<code>GROUP BY</code>-&gt;<code>HAVING</code>-&gt;<code>ORDER BY</code>-&gt;<code>LIMIT</code> 。</p>
<p>执行顺序：<br><code>FROM</code>-&gt;<code>WHERE</code>-&gt;<code>GROUP BY</code>-&gt;<code>HAVING</code>-&gt;<code>SELECT</code>-&gt;<code>ORDER BY</code>-&gt;<code>LIMIT</code> 。</p>
<h3 id="4-DCL"><a href="#4-DCL" class="headerlink" title="(4) DCL"></a><strong>(4) DCL</strong></h3><p>DCL，全称为数据库控制语言（<span style="color:red;">D</span>ata <span style="color:red;">C</span>ontrol <span style="color:red;">L</span>anguage）。它用于控制数据的访问权限。</p>
<div class="tabs" id="usercontrol"><ul class="nav-tabs"><li class="tab active"><a href="#usercontrol-1">查看用户</a></li><li class="tab"><a href="#usercontrol-2">创建用户</a></li><li class="tab"><a href="#usercontrol-3">修改用户</a></li><li class="tab"><a href="#usercontrol-4">删除用户</a></li><li class="tab"><a href="#usercontrol-5">权限控制</a></li></ul><div class="tab-content"><div class="tab-pane active" id="usercontrol-1"><p>MySQL中的用户信息全都存放在一个名为 <code>mysql</code> 的数据库下的 <code>user</code> 表中。你可以运行下面的代码来查看有哪些用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>   # “<span class="operator">*</span>” 代表选择所有属性</span><br><span class="line"><span class="keyword">FROM</span> mysql.user;   #可以通过 库名.表名 来直接定位表</span><br></pre></td></tr></table></figure>

<p>由于该表中的属性过多，在命令行中显示极有可能格式紊乱，建议使用图形化的界面查看。</p>
<p><img src="/2022/03/01/SQLGrammar/2.png" alt="2 2" title="2"></p>
<p><code>Lacia</code> 用户是我在安装时添加的。如果你按照默认的方式安装了MySQL，那么将不会存在这个用户。</p></div><div class="tab-pane" id="usercontrol-2"><p>使用如下语句以创建用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>创建的用户只能从指定的地址登录。如果想设置为能从任意地址登录，可以把主机地址设置为 <code>'%'</code> （通配符）。</p></div><div class="tab-pane" id="usercontrol-3"><p>使用如下语句以修改用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> 加密方式 <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>其中，加密方式建议选择默认的 <code>mysql_native_password</code> 。</p></div><div class="tab-pane" id="usercontrol-4"><p>使用如下语句以删除用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="usercontrol-5"><p>SQL中的常用权限可以分为如下几种：</p>
<ul>
<li><code>ALL</code> ，所有特权</li>
<li><code>SELECT</code> ，查询项权限</li>
<li><code>INSERT</code> ，增加项权限</li>
<li><code>UPDATE</code> ，修改项权限</li>
<li><code>DELETE</code> ，删除项权限</li>
<li><code>ALTER</code> ，修改表权限</li>
<li><code>DROP</code> ，删除库&#x2F;表权限</li>
<li><code>CREATE</code> ，创建库&#x2F;表权限</li>
</ul>
<p>管理用户权限，可以使用下列语句：</p>
<ul>
<li><code>SHOW GRANTS FOR '用户名'@'主机地址';</code> ，查看指定用户的权限</li>
<li><code>GRANT 权限列表 ON 库名.表名 TO '用户名'@'主机地址';</code> ，赋予指定用户管理指定表的指定权限</li>
<li><code>REVOKE 权限列表 ON 库名.表名 FROM '用户名'@'主机地址';</code> 撤销指定用户对指定表的指定权限</li>
</ul>
<p>同样，建议使用图形化的数据库软件查看结果。</p></div></div></div>

<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a><strong>三、函数</strong></h2><p>SQL中内置了很多函数。</p>
<h3 id="1-字符串函数"><a href="#1-字符串函数" class="headerlink" title="(1) 字符串函数"></a><strong>(1) 字符串函数</strong></h3><ul>
<li><code>CONCAT(str1, ···)</code> ，将作为参数的所有字符串拼接后返回。</li>
<li><code>LOWER(str)</code> ，将 <code>str</code> 的所有字符转为小写后返回。</li>
<li><code>UPPER(str)</code> ，将 <code>str</code> 的所有字符转为大写后返回。</li>
<li><code>LPAD(str, n, pad)</code> ，用<code>pad</code> 填充 <code>str</code> 左侧，直到字符串长度达到 <code>n</code> ，并返回。</li>
<li><code>RPAD</code> ，同 <code>LPAD()</code> ，但是是填充右侧。</li>
<li><code>TRIM(str)</code> ，去除 <code>str</code> 头部和尾部的空格。</li>
<li><code>SUBSTRING(str, start, len)</code> ,截取 <code>str</code> ，从第 <code>start</code> 个字符开始截取（包含），直到子串长度达到 <code>len</code> 或达到字符串末尾。</li>
</ul>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>显示函数结果</strong></div>

<div style="color:royalblue;">可以直接使用 <code>SELECT</code> 关键字来打印函数的执行结果。</div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;1145141919810&#x27;</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT SUBSTRING(<span class="string">&#x27;1145141919810&#x27;</span>, 3, 7);</span></span><br><span class="line">+----------------------------------+</span><br><span class="line">| SUBSTRING(&#x27;1145141919810&#x27;, 3, 7) |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| 4514191                          |</span><br><span class="line">+----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">另外，请注意，<code>SUBSTRING()</code> 函数的起始位置是从1开始计数的。</div>
</div>

<h3 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="(2) 数值函数"></a><strong>(2) 数值函数</strong></h3><ul>
<li><code>CEIL(a)</code> ， <code>a</code> 向上取整后返回</li>
<li><code>FLOOR(a)</code> ，<code>a</code> 向下取整后返回</li>
<li><code>MOD(a, b)</code> ，返回 <code>a</code> mod <code>b</code></li>
<li><code>RAND()</code> ，返回1个在0~1之间的随机数。</li>
<li><code>ROUND(x, i)</code> ，将 <code>x</code> 四舍五入取整，保留 <code>i</code> 位小数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEIL</span>(<span class="number">114.514</span>),</span><br><span class="line">    <span class="built_in">FLOOR</span>(<span class="number">114.514</span>),</span><br><span class="line">    <span class="built_in">MOD</span>(<span class="number">1919</span>, <span class="number">810</span>),</span><br><span class="line">    RAND() <span class="operator">*</span> <span class="number">100</span>,</span><br><span class="line">    ROUND(<span class="number">114.5145</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/03/01/SQLGrammar/3.png" alt="3 3" title="3"></p>
<h3 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="(3) 日期函数"></a><strong>(3) 日期函数</strong></h3><ul>
<li><code>CURDATE()</code> ，返回当前日期</li>
<li><code>CURTIME()</code> ，返回当前时间</li>
<li><code>NOW()</code> ，返回当前的日期+时间</li>
<li><code>YEAR(date)</code> ，返回日期中的年份</li>
<li><code>MONTH(date)</code> ，返回日期中的月份</li>
<li><code>DAY(date)</code> ，返回日期中的天</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CURDATE(),</span><br><span class="line">    CURTIME(),</span><br><span class="line">    NOW(),</span><br><span class="line">    <span class="keyword">YEAR</span>(CURDATE()),</span><br><span class="line">    <span class="keyword">MONTH</span>(<span class="string">&#x27;1919-08-10&#x27;</span>),</span><br><span class="line">    <span class="keyword">DAY</span>(CURDATE());</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/03/01/SQLGrammar/4.png" alt="4 4" title="4"></p>
<p>SQL能够非常便捷地进行日期运算，只需要使用 <code>DATE_ADD()</code> 函数与 <code>INTERVAL</code> 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_ADD(</span><br><span class="line">        <span class="string">&#x27;1919-08-10&#x27;</span>,</span><br><span class="line">        <span class="type">INTERVAL</span> <span class="number">114514</span> <span class="keyword">DAY</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/03/01/SQLGrammar/5.png" alt="5 5" title="5"></p>
<p>计算两个日期相隔多少天，可以使用 <code>DATEDIFF()</code> 函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATEDIFF(CURDATE(), <span class="string">&#x27;1919-08-10&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意是前者减去后者。如果把较早的日期放在前面，将会返回负数。输出结果为：</p>
<p><img src="/2022/03/01/SQLGrammar/6.png" alt="6 6" title="6"></p>
<h2 id="四、控制流"><a href="#四、控制流" class="headerlink" title="四、控制流"></a><strong>四、控制流</strong></h2><p>SQL的常用控制流函数有以下两个：</p>
<ul>
<li><code>IF(bool, a, b)</code> ，如果 <code>bool</code> 为 <code>true</code> ，则返回 <code>a</code> ，否则返回 <code>b</code> 。</li>
<li><code>IFNULL(a, b)</code> ，如果 <code>a</code> 不为 <code>NULL</code> ，则返回 <code>a</code> ，否则返回 <code>b</code> 。</li>
</ul>
<p>SQL中还可以使用 <code>CASE</code> 关键字来建立控制流：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 第一种</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> bool1 <span class="keyword">THEN</span> value1</span><br><span class="line">    <span class="keyword">WHEN</span> bool2 <span class="keyword">THEN</span> value2</span><br><span class="line">    ······</span><br><span class="line">    <span class="keyword">ELSE</span> DefaultValue</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二种</span><br><span class="line"><span class="keyword">CASE</span> a</span><br><span class="line">    <span class="keyword">WHEN</span> a1 <span class="keyword">THEN</span> value1</span><br><span class="line">    <span class="keyword">WHEN</span> a2 <span class="keyword">THEN</span> value2</span><br><span class="line">    ······</span><br><span class="line">    <span class="keyword">ELSE</span> DefaultValue</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的第一种，是当 <code>WHEN</code> 关键字后的逻辑表达式为真时，返回其后的 <code>THEN</code> 关键字后的值。<br>第二种则是当 <code>WHEN</code> 关键字后的值等于 <code>a</code> 时，返回其后的 <code>THEN</code> 关键字后的值。</p>
<p>由 <code>CASE</code> 关键字定义的控制流，与Go语言的 <code>switch</code> 语句相似，它只会返回第一个符合条件的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> <span class="literal">true</span> <span class="keyword">THEN</span> &quot;1&quot;</span><br><span class="line">    <span class="keyword">WHEN</span> <span class="literal">true</span> <span class="keyword">THEN</span> &quot;2&quot;</span><br><span class="line">    <span class="keyword">ELSE</span> &quot;3&quot;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> &quot;测试&quot;;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/03/01/SQLGrammar/7.png" alt="7 7" title="7"></p>
<h2 id="五、约束"><a href="#五、约束" class="headerlink" title="五、约束"></a><strong>五、约束</strong></h2><p>约束用于限制数据库中存储的某一个属性的值应该处于什么范围内。与约束有关的关键字如下：</p>
<ul>
<li><code>NOT NULL</code> ，非空</li>
<li><code>UNIQUE</code> ，唯一</li>
<li><code>PRIMARY KEY</code> ，主键约束，非空且唯一</li>
<li><code>DEFAULT</code> ，未指定属性值时，采用其后的默认值</li>
<li><code>FOREIGN KEY</code> ，外键约束，链接两张表的某一属性</li>
<li><code>CHECK</code> ，值必须满足某一条件</li>
</ul>
<p>约束又分为表级约束与列级约束。表级约束将对整张表的符合条件的属性起约束作用，而列级约束只对某一个属性起约束作用。由于约束的删除与添加各不相同<del>设计这部分代码的人真的是人间之屑</del>，此处只涉及对外键约束的操作，因为它最常被添加或修改。</p>
<p>一般外键约束都是在表建立以后再进行链接，因此有必要掌握创建与删除外键约束的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建外键约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 自定义约束名 <span class="keyword">FOREIGN</span> KEY (属性名) REFERENCE 表名(属性名);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除外键约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 自定义约束名;</span><br></pre></td></tr></table></figure>

<p>要链接两个表的某一属性，前提是这两张表的对应属性必须属于一种类型。在设置外键约束以后，还可以设置更新&#x2F;删除项时的行为：</p>
<ul>
<li><code>RESTRICT</code> ，若有对应外键则不允许修改</li>
<li><code>CASCADE</code> ，连对应外键一起修改</li>
<li><code>SET NULL</code> ，将外键的值设置为 <code>NULL</code> 。</li>
</ul>
<p>默认行为是 <code>RESTRICT</code> ，要修改行为可以使用 <code>ON UPDATE</code> 和 <code>ON DELETE</code> 关键字，它们需要接在 <code>REFERENCE</code> 关键字之后。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 自定义约束名 <span class="keyword">FOREIGN</span> KEY (属性名) REFERENCE 表名(属性名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> 行为<span class="number">1</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> 行为<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">SQL还有多表查询，事务等。这些也属于基础知识，但本文不再涉及。更深层次的知识则有数据库引擎、存储方式等偏向底层的知识，这些应该在打好基础之后再深入了解。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>数据库</category>
        <category>SQL语法</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow 2.7.0 部分API</title>
    <url>/2022/01/18/TensorflowAPI/</url>
    <content><![CDATA[<img src="/2022/01/18/TensorflowAPI/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要理解机器学习原理以及Python基础。</div>
</div>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>请确认版本</strong></div>

<div style="color:goldenrod;">此笔记适用于Tensorflow 2.7.0版本。</div>
</div>

<span id="more"></span>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>特殊标志</strong></div>

<div style="color:goldenrod;">除非以<span style="color:blue;">蓝色</span>特殊标识，否则均为加上"tensorflow."即可引用的函数。</div>
</div>

<h2 id="Const-value-dtype-x3D-shape-x3D-name-x3D-”Const”"><a href="#Const-value-dtype-x3D-shape-x3D-name-x3D-”Const”" class="headerlink" title="Const(value, dtype&#x3D;, shape&#x3D;, name&#x3D;”Const”)"></a><strong>Const(value, dtype&#x3D;, shape&#x3D;, name&#x3D;”Const”)</strong></h2><p>功能：创建一个tf.Tensor型的变量。</p>
<p>value：value：设定变量值。<br>可以为数字、字符串、列表、元组。</p>
<p>dtype&#x3D;：设定变量类型。<br>默认数字为int32或float32，字符串为string。可忽略。</p>
<p>shape&#x3D;：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。可忽略。</p>
<p>name&#x3D;：设定变量内置名称。<br>仅支持字符串。可忽略。</p>
<h2 id="Variable-value-name-x3D-dtype-x3D-shape-x3D-trainable-x3D"><a href="#Variable-value-name-x3D-dtype-x3D-shape-x3D-trainable-x3D" class="headerlink" title="Variable(value, name&#x3D;, dtype&#x3D;, shape&#x3D;, trainable&#x3D;)"></a><strong>Variable(value, name&#x3D;, dtype&#x3D;, shape&#x3D;, trainable&#x3D;)</strong></h2><p>功能：创建一个tf.Variable型的变量。</p>
<p>value：设定变量值。<br>可以为数字、字符串、列表、元组。</p>
<p>name&#x3D;：设定变量内置名称。<br>仅支持字符串。可忽略。</p>
<p>dtype&#x3D;：设定变量类型。<br>默认数字为int32或float32，字符串为string。可忽略。</p>
<p>shape&#x3D;：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。可忽略。</p>
<p>trainable&#x3D;：设定变量可否训练。<br>仅支持True、False和None。可忽略。</p>
<p>返回值：一个tf.Variable型的变量。</p>
<h2 id="GradientTape-persistent-x3D-False-watch-accessed-variables-x3D-True"><a href="#GradientTape-persistent-x3D-False-watch-accessed-variables-x3D-True" class="headerlink" title="GradientTape(persistent&#x3D;False, watch_accessed_variables&#x3D;True)"></a><strong>GradientTape(persistent&#x3D;False, watch_accessed_variables&#x3D;True)</strong></h2><p>功能：创建一个梯度带类型的变量。</p>
<p>persistent&#x3D;：设定是否要持续求导。<br>False则调用gradient()后释放，即不可第二次调用gradient()。</p>
<p>watch_accessed_variables&#x3D;：是否自动追踪可训练变量。<br>False则需手动指定变量。</p>
<p>返回值：一个梯度带类型的变量。</p>
<h2 id="GradientTape-gradient-target-sources"><a href="#GradientTape-gradient-target-sources" class="headerlink" title="GradientTape.gradient(target, sources)"></a><strong><span style="color:blue;">GradientTape</span>.gradient(target, sources)</strong></h2><p>功能：求指定函数对指定变量的偏导数。</p>
<p>target：要求偏导数的函数。</p>
<p>sources：要求偏导数的变量。<br>对单个变量求偏导数时直接写变量名，对多个倒数求偏导数时写列表。</p>
<p>返回值：若sources为变量则返回一个tf.Tensor型变量，若sources为列表则返回一个由tf.Tensor型变量组成的列表。</p>
<h2 id="GradientTape-watch-tensor"><a href="#GradientTape-watch-tensor" class="headerlink" title="GradientTape.watch(tensor)"></a><strong><span style="color:blue;">GradientTape</span>.watch(tensor)</strong></h2><p>功能：设定要追踪的变量。</p>
<p>tensor：要追踪的变量。<br>只追踪一个变量时直接写变量名，追踪多个变量时需以列表形式填入。</p>
<p>无返回值。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>使用样例</strong></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=tensorflow.Variable(<span class="number">5</span>, dtype=tensorflow.float32, trainable=<span class="literal">True</span>)</span><br><span class="line">y=tensorflow.Variable(<span class="number">7</span>, dtype=tensorflow.float32, trainable=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> tensorflow.GradientTape() <span class="keyword">as</span> temp:</span><br><span class="line"><span class="comment">#这里使用默认的设置</span></span><br><span class="line">    temp.watch([x, y])</span><br><span class="line">    <span class="comment">#指定要关注x与y</span></span><br><span class="line">    z=x*x*x*y*y+x*x*y+x+<span class="number">1</span></span><br><span class="line">    <span class="comment">#z=x³y²+x²y+x+1，相当于z=f(x,y)，z即为需要求导的函数</span></span><br><span class="line">result=temp.gradient(z, [x, y])   <span class="comment">#求导</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">其结果应该为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">[&lt;tf.Tensor: shape=(), dtype=float32, numpy=3746.0&gt;, &lt;tf.Tensor: shape=(), dtype=float32, numpy=1775.0&gt;]</span><br></pre></td></tr></table></figure>
</div>

<h2 id="convert-to-tensor-value-dtype-x3D-name-x3D"><a href="#convert-to-tensor-value-dtype-x3D-name-x3D" class="headerlink" title="convert_to_tensor(value, dtype&#x3D;, name&#x3D;)"></a><strong>convert_to_tensor(value, dtype&#x3D;, name&#x3D;)</strong></h2><p>功能：将变量转换为tf.Tensor型变量。</p>
<p>value：设置需要转变的变量。<br>可以是值、列表或者元组。</p>
<p>dtype&#x3D;：设置变量的值的格式。<br>常用float32。<em>（因为要求导数，对小数运算有需求）</em> 可忽略。</p>
<p>name&#x3D;：设置变量的内置名称。<br>可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="zeros-shape-dtype-x3D-name-x3D"><a href="#zeros-shape-dtype-x3D-name-x3D" class="headerlink" title="zeros(shape, dtype&#x3D;, name&#x3D;)"></a><strong>zeros(shape, dtype&#x3D;, name&#x3D;)</strong></h2><p>功能：产生全0的tf.Tensor型的变量。</p>
<p>shape：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。</p>
<p>dtype&#x3D;：设置值的类型。<br>默认为float32。可忽略。</p>
<p>name&#x3D;：设置内置名称。<br>仅支持字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="ones-shape-dtype-x3D-name-x3D"><a href="#ones-shape-dtype-x3D-name-x3D" class="headerlink" title="ones(shape, dtype&#x3D;, name&#x3D;)"></a><strong>ones(shape, dtype&#x3D;, name&#x3D;)</strong></h2><p>功能：产生全1的tf.Tensor型的变量。</p>
<p>shape：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。</p>
<p>dtype&#x3D;：设置值的类型。<br>默认为float32。可忽略。</p>
<p>name&#x3D;：设置内置名称。<br>仅支持字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="fill-dims-value-name-x3D"><a href="#fill-dims-value-name-x3D" class="headerlink" title="fill(dims, value, name&#x3D;)"></a><strong>fill(dims, value, name&#x3D;)</strong></h2><p>功能：产生值均为某一指定值的tf.Tensor型的变量。</p>
<p>dims：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。</p>
<p>value：指定填充变量所有维度的值。</p>
<p>name&#x3D;：设置内置名称。<br>仅支持字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="random-normal-shape-mean-x3D-0-stddev-x3D-1-dtype-x3D-seed-x3D-name-x3D"><a href="#random-normal-shape-mean-x3D-0-stddev-x3D-1-dtype-x3D-seed-x3D-name-x3D" class="headerlink" title="random.normal(shape, mean&#x3D;0, stddev&#x3D;1, dtype&#x3D;, seed&#x3D;, name&#x3D;)"></a><strong>random.normal(shape, mean&#x3D;0, stddev&#x3D;1, dtype&#x3D;, seed&#x3D;, name&#x3D;)</strong></h2><p>功能：产生指定维度数的正态分布的随机的tf.Tensor型的变量</p>
<p>shape：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。</p>
<p>mean&#x3D;：指定产生的随机数的平均值。<br>默认为0。可忽略。</p>
<p>stddev&#x3D;：指定产生的随机数的标准差。<br>默认为1。可忽略。</p>
<p>dtype&#x3D;：指定产生的随机数的类型。<br>默认为float32。可忽略。</p>
<p>seed&#x3D;：指定产生随机数的种子。<br>可忽略。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="random-truncated-normal-shape-mean-x3D-0-stddev-x3D-1-dtype-x3D-seed-x3D-name-x3D"><a href="#random-truncated-normal-shape-mean-x3D-0-stddev-x3D-1-dtype-x3D-seed-x3D-name-x3D" class="headerlink" title="random.truncated_normal(shape, mean&#x3D;0, stddev&#x3D;1, dtype&#x3D;, seed&#x3D;, name&#x3D;)"></a><strong>random.truncated_normal(shape, mean&#x3D;0, stddev&#x3D;1, dtype&#x3D;, seed&#x3D;, name&#x3D;)</strong></h2><p>功能：产生指定维度数的正态分布的随机的tf.Tensor型的变量，其值的分布范围限定在$(μ-2σ，μ+2σ)$</p>
<p>shape：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。</p>
<p>mean&#x3D;：指定产生的随机数的平均值。<br>默认为0。可忽略。</p>
<p>stddev&#x3D;：指定产生的随机数的标准差。<br>默认为1。可忽略。</p>
<p>dtype&#x3D;：指定产生的随机数的类型。<br>默认为float32。可忽略。</p>
<p>seed&#x3D;：指定产生随机数的种子。<br>可忽略。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="random-uniform-shape-minval-x3D-0-maxval-x3D-None-dtype-x3D-seed-x3D-name-x3D"><a href="#random-uniform-shape-minval-x3D-0-maxval-x3D-None-dtype-x3D-seed-x3D-name-x3D" class="headerlink" title="random.uniform(shape, minval&#x3D;0, maxval&#x3D;None, dtype&#x3D;, seed&#x3D;, name&#x3D;)"></a><strong>random.uniform(shape, minval&#x3D;0, maxval&#x3D;None, dtype&#x3D;, seed&#x3D;, name&#x3D;)</strong></h2><p>功能：产生指定维度数的均匀分布的随机的tf.Tensor型的变量。</p>
<p>shape：指定每个维度变量个数。<br>仅支持列表。格式为[第一维度，第二维度，第三维度，······]。</p>
<p>minval&#x3D;：指定产生的随机数的最小值。<br>默认为0。可忽略。</p>
<p>maxval&#x3D;：指定产生的随机数的最大值。<br>默认为1。可忽略。</p>
<p>dtype&#x3D;：指定产生的随机数的类型。<br>默认为float32。可忽略。</p>
<p>seed&#x3D;：指定产生随机数的种子。<br>可忽略。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="cast-x-dtype-name-x3D-None"><a href="#cast-x-dtype-name-x3D-None" class="headerlink" title="cast(x, dtype, name&#x3D;None)"></a><strong>cast(x, dtype, name&#x3D;None)</strong></h2><p>功能：将tf.Tensor型的变量x内的值强制转换为指定类型。</p>
<p>x：需要转换的tf.Tensor型的变量。</p>
<p>dtype：转换后的值的类型。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="reduce-min-input-tensor-axis-x3D-None-keepdims-x3D-False-name-x3D"><a href="#reduce-min-input-tensor-axis-x3D-None-keepdims-x3D-False-name-x3D" class="headerlink" title="reduce_min(input_tensor, axis&#x3D;None, keepdims&#x3D;False, name&#x3D;)"></a><strong>reduce_min(input_tensor, axis&#x3D;None, keepdims&#x3D;False, name&#x3D;)</strong></h2><p>功能：返回tf.Tensor型的变量input_tensor的指定维度中的最小值。</p>
<p>input_tensor：指定tf.Tensor型的变量。<br>可以由列表、元组隐式转换得到。</p>
<p>axis&#x3D;：指定是第几个维度。<br>可以不指定，不指定则全维度参与。默认为None，即不指定。</p>
<p>keepdims&#x3D;：指定是否保留维度信息。<br>默认不保留。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="reduce-max-input-tensor-axis-x3D-None-keepdims-x3D-False-name-x3D"><a href="#reduce-max-input-tensor-axis-x3D-None-keepdims-x3D-False-name-x3D" class="headerlink" title="reduce_max(input_tensor, axis&#x3D;None, keepdims&#x3D;False, name&#x3D;)"></a><strong>reduce_max(input_tensor, axis&#x3D;None, keepdims&#x3D;False, name&#x3D;)</strong></h2><p>功能：返回tf.Tensor型的变量input_tensor的指定维度中的最大值。</p>
<p>input_tensor：指定tf.Tensor型的变量。<br>可以由列表、元组隐式转换得到。</p>
<p>axis&#x3D;：指定是第几个维度。<br>可以不指定，不指定则全维度参与。默认为None，即不指定。</p>
<p>keepdims&#x3D;：指定是否保留维度信息。<br>默认不保留。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="reduce-sum-input-tensor-axis-x3D-None-keepdims-x3D-False-name-x3D"><a href="#reduce-sum-input-tensor-axis-x3D-None-keepdims-x3D-False-name-x3D" class="headerlink" title="reduce_sum(input_tensor, axis&#x3D;None, keepdims&#x3D;False, name&#x3D;)"></a><strong>reduce_sum(input_tensor, axis&#x3D;None, keepdims&#x3D;False, name&#x3D;)</strong></h2><p>功能：返回tf.Tensor型的变量input_tensor的指定维度中的和。</p>
<p>input_tensor：指定tf.Tensor型的变量。<br>可以由列表、元组隐式转换得到。</p>
<p>axis&#x3D;：指定是第几个维度。<br>可以不指定，不指定则全维度参与。默认为None，即不指定。</p>
<p>keepdims&#x3D;：指定是否保留维度信息。<br>默认不保留。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="add-x-y-name-x3D-None"><a href="#add-x-y-name-x3D-None" class="headerlink" title="add(x, y, name&#x3D;None)"></a><strong>add(x, y, name&#x3D;None)</strong></h2><p>功能：tf.Tensor型变量的加法。两个变量的维度需一致，对应位置的元素做运算。</p>
<p>x：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>y：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="subtract-x-y-name-x3D-None"><a href="#subtract-x-y-name-x3D-None" class="headerlink" title="subtract(x, y, name&#x3D;None)"></a><strong>subtract(x, y, name&#x3D;None)</strong></h2><p>功能：tf.Tensor型变量的减法。两个变量的维度需一致，对应位置的元素做运算。</p>
<p>x：指定的tf.Tensor型变量，被减数。<br>可以由列表、元组隐式转换得到。</p>
<p>y：指定的tf.Tensor型变量，减数。<br>可以由列表、元组隐式转换得到。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="multiply-x-y-name-x3D-None"><a href="#multiply-x-y-name-x3D-None" class="headerlink" title="multiply(x, y, name&#x3D;None)"></a><strong>multiply(x, y, name&#x3D;None)</strong></h2><p>功能：tf.Tensor型变量的乘法。两个变量的维度需一致，对应位置的元素做运算。</p>
<p>x：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>y：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="divide-x-y-name-x3D-None"><a href="#divide-x-y-name-x3D-None" class="headerlink" title="divide(x, y, name&#x3D;None)"></a><strong>divide(x, y, name&#x3D;None)</strong></h2><p>功能：tf.Tensor型变量的乘法。两个变量的维度需一致，对应位置的元素做运算。</p>
<p>x：指定的tf.Tensor型变量，被除数。<br>可以由列表、元组隐式转换得到。</p>
<p>y：指定的tf.Tensor型变量，除数。<br>可以由列表、元组隐式转换得到。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="square-x-name-x3D-None"><a href="#square-x-name-x3D-None" class="headerlink" title="square(x, name&#x3D;None)"></a><strong>square(x, name&#x3D;None)</strong></h2><p>功能：tf.Tensor型变量的平方运算。每个元素单独运算。</p>
<p>x：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="pow-x-y-name-x3D-None"><a href="#pow-x-y-name-x3D-None" class="headerlink" title="pow(x, y, name&#x3D;None)"></a><strong>pow(x, y, name&#x3D;None)</strong></h2><p>功能：tf.Tensor型变量的次方运算。两个变量的维度需一致，对应位置的元素做运算。</p>
<p>x：指定的tf.Tensor型变量，底数。<br>可以由列表、元组隐式转换得到。</p>
<p>y：指定的tf.Tensor型变量，指数。<br>可以由列表、元组隐式转换得到。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="sqrt-x-name-x3D-None"><a href="#sqrt-x-name-x3D-None" class="headerlink" title="sqrt(x, name&#x3D;None)"></a><strong>sqrt(x, name&#x3D;None)</strong></h2><p>功能：tf.Tensor型变量的算数平方根运算。每个元素单独运算。</p>
<p>x：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="matmul-a-b-transpose-a-x3D-False-transpose-b-x3D-False-adjoint-a-x3D-False-adjoint-b-x3D-False-a-is-sparse-x3D-False-b-is-sparse-x3D-False-output-type-x3D-name-x3D"><a href="#matmul-a-b-transpose-a-x3D-False-transpose-b-x3D-False-adjoint-a-x3D-False-adjoint-b-x3D-False-a-is-sparse-x3D-False-b-is-sparse-x3D-False-output-type-x3D-name-x3D" class="headerlink" title="matmul(a, b, transpose_a&#x3D;False, transpose_b&#x3D;False, adjoint_a&#x3D;False, adjoint_b&#x3D;False, a_is_sparse&#x3D;False, b_is_sparse&#x3D;False, output_type&#x3D;, name&#x3D;)"></a><strong>matmul(a, b, transpose_a&#x3D;False, transpose_b&#x3D;False, adjoint_a&#x3D;False, adjoint_b&#x3D;False, a_is_sparse&#x3D;False, b_is_sparse&#x3D;False, output_type&#x3D;, name&#x3D;)</strong></h2><p>功能：tf.Tensor型的变量进行矩阵乘法。输入的变量维度需符合矩阵乘法要求。</p>
<p>a：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>b：指定的tf.Tensor型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>transpose_a&#x3D;：指定a需不需要先转置。</p>
<p>transpose_a&#x3D;：指定b需不需要先转置。</p>
<p>adjoint_a&#x3D;：指定a需不需要先共轭和转置。</p>
<p>adjoint_b&#x3D;：指定b需不需要先共轭和转置。</p>
<p>a_is_sparse&#x3D;：指定a是否为稀疏矩阵。</p>
<p>b_is_sparse&#x3D;：指定b是否为稀疏矩阵。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="data-Dataset-from-tensor-slices-tensors-name-x3D-None"><a href="#data-Dataset-from-tensor-slices-tensors-name-x3D-None" class="headerlink" title="data.Dataset.from_tensor_slices(tensors, name&#x3D;None)"></a><strong>data.Dataset.from_tensor_slices(tensors, name&#x3D;None)</strong></h2><p>功能：将数据集中的输入与标签一一配对后并返回。</p>
<p>tensors：指定输入与标签。<br>可以用[输入，标签]或者(输入,标签)的形式给定。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个TensorSliceDataset型变量。</p>
<h2 id="enumerate-list"><a href="#enumerate-list" class="headerlink" title="enumerate(list)"></a><strong><span style="color:blue;">enumerate(list)</span></strong></h2><p>功能：返回列表list中的序号和元素，常用于for in循环。</p>
<p>list：给定的列表。</p>
<p>返回值：一个[(序号0，元素0)，······(序号n，元素n)]形式的列表（或元组）。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>使用样例</strong></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]):</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">返回值应该为</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">(0, 4)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br></pre></td></tr></table></figure>
</div>

<h2 id="one-hot-indices-depth-on-value-x3D-off-value-x3D-axis-x3D-None-dtype-x3D-name-x3D"><a href="#one-hot-indices-depth-on-value-x3D-off-value-x3D-axis-x3D-None-dtype-x3D-name-x3D" class="headerlink" title="one_hot(indices, depth, on_value&#x3D;, off_value&#x3D;, axis&#x3D;None, dtype&#x3D;, name&#x3D;)"></a><strong>one_hot(indices, depth, on_value&#x3D;, off_value&#x3D;, axis&#x3D;None, dtype&#x3D;, name&#x3D;)</strong></h2><p>功能：执行分类。tf.Tensor型变量按每个维度中的第$i$个元素元素值为$x_i$，然后将返回列表第$i$行的第$x_i$个元素置1，其余全置0。</p>
<p>indices：指定的tf.Tensor类型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>depth：指定分类的个数。<br>即返回的列表中的每个列表的长度。</p>
<p>on_value：指定命中值。<br>默认为1。可忽略。</p>
<p>off_value：指定未命中值。<br>默认为0。可忽略。</p>
<p>axis&#x3D;：指定分类后对齐的轴。<br>具体结果不好描述建议动手试验，查看输出的shape。</p>
<p>dtype&#x3D;：指定输出变量的类型。<br>默认为float32。可忽略。</p>
<p>name&#x3D;：指定变量的内置名称。<br>仅接受字符串。可忽略。</p>
<p>返回值：一个tf.Tensor型变量。</p>
<h2 id="nn-softmax-logits-axis-x3D-None-name-x3D-None"><a href="#nn-softmax-logits-axis-x3D-None-name-x3D-None" class="headerlink" title="nn.softmax(logits, axis&#x3D;None, name&#x3D;None)"></a><strong>nn.softmax(logits, axis&#x3D;None, name&#x3D;None)</strong></h2><p>功能：将传入的tf.Tensor型变量（一维）中的值做处理使得其占比不变而和永远为1。即算出概率。</p>
<p>logits：指定的tf.Tensor类型变量。<br>可以由列表、元组隐式转换得到。</p>
<p>axis&#x3D;：好像没啥作用。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="tf-Tensor-assign-sub-value"><a href="#tf-Tensor-assign-sub-value" class="headerlink" title="tf.Tensor.assign_sub(value)"></a><strong><span style="color:blue;">tf.Tensor</span>.assign_sub(value)</strong></h2><p>功能：对应元素自减。<br>调用函数的tf.Tensor型的变量需为可训练的，输入的值为自减的值，类似于subtract()函数。</p>
<p>value：指定的tf.Tensor类型变量。<br>可以由列表、元组或者值隐式转换得到。其形状应和调用函数的tf.Tensor型的变量一致。</p>
<h2 id="argmax-input-axis-x3D-output-type-x3D"><a href="#argmax-input-axis-x3D-output-type-x3D" class="headerlink" title="argmax(input, axis&#x3D;, output_type&#x3D;)"></a><strong>argmax(input, axis&#x3D;, output_type&#x3D;)</strong></h2><p>功能：返回tf.Tensor型的变量沿指定维度最大值的序号。</p>
<p>input：指定的tf.Tensor型的变量。<br>可以由列表、元组隐式转换得到。</p>
<p>axis&#x3D;：指定的维度。<br>若不指定则默认为0。</p>
<p>output_type&#x3D;：指定输出的值的类型。<br>默认为int64。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="TensorSliceDataset-batch-value"><a href="#TensorSliceDataset-batch-value" class="headerlink" title="TensorSliceDataset.batch(value)"></a><strong><span style="color:blue;">TensorSliceDataset</span>.batch(value)</strong></h2><p>功能：将数据集每value组打包为一个数据包。<br>常接在Dataset.from_tensor_slices()后。</p>
<p>value：指定多少组打包为一个数据包。</p>
<p>返回值：一个TensorSliceDataset型变量。</p>
<h2 id="where-condition-x-x3D-y-x3D"><a href="#where-condition-x-x3D-y-x3D" class="headerlink" title="where(condition, x&#x3D;, y&#x3D;)"></a><strong>where(condition, x&#x3D;, y&#x3D;)</strong></h2><p>功能：条件的为真返回x，条件为假返回y。<br>若为张量则按元素比较，condition[i]为真返回x[i]，condition[i]为假返回y[i]。</p>
<p>x&#x3D;：指定变量。</p>
<p>y&#x3D;：指定变量。</p>
<p>返回值：一个tf.Tensor型的变量。</p>
<h2 id="keras-models-Sequential-Network"><a href="#keras-models-Sequential-Network" class="headerlink" title="keras.models.Sequential([Network])"></a><strong>keras.models.Sequential([Network])</strong></h2><p>功能：生成网络的结构。</p>
<p>Network：指定网络结构。<br>一个结构包含了很多层。<br>请注意这个结构必须放在列表中，再传入函数。</p>
<p>返回值：一个容器。</p>
<h2 id="keras-layers-Dense-units-activation-x3D-kernel-regularizer-x3D"><a href="#keras-layers-Dense-units-activation-x3D-kernel-regularizer-x3D" class="headerlink" title="keras.layers.Dense(units, activation&#x3D;, kernel_regularizer&#x3D;)"></a><strong>keras.layers.Dense(units, activation&#x3D;, kernel_regularizer&#x3D;)</strong></h2><p>功能：生成全连接层。</p>
<p>units：指定该层的结点数。</p>
<p>activation&#x3D;：指定该层的激活函数。<br>值需为字符串。通常有’relu’，’sigmoid’和’tanh’。</p>
<p>kernel_regularizer&#x3D;：指定正则化方式。<br>一般会指定为keras.regularizer.l1()或keras.regularizer.l2()。</p>
<p>返回值：一个神经网络层。</p>
<h2 id="keras-layers-Conv2D-filters-x3D-，kernel-size-x3D-，strides-x3D-，padding-x3D-activation-x3D"><a href="#keras-layers-Conv2D-filters-x3D-，kernel-size-x3D-，strides-x3D-，padding-x3D-activation-x3D" class="headerlink" title="keras.layers.Conv2D(filters&#x3D;，kernel_size&#x3D;，strides&#x3D;，padding&#x3D;, activation&#x3D;)"></a><strong>keras.layers.Conv2D(filters&#x3D;，kernel_size&#x3D;，strides&#x3D;，padding&#x3D;, activation&#x3D;)</strong></h2><p>功能：生成卷积层。</p>
<p>filters&#x3D;：指定卷积核个数。</p>
<p>kernel_size&#x3D;：指定卷积核大小。<br>正方形卷积核直接输入数字，其它则以(长,宽)的模式输入。<br>不推荐长方形卷积核。</p>
<p>strides&#x3D;：指定步长。</p>
<p>padding&#x3D;：指定填充方式。<br>值需为字符串。通常有’valid’（不填充）和’same’（全0填充）。</p>
<p>activation&#x3D;：指定该层的激活函数。<br>值需为字符串。通常有’relu’，’sigmoid’和’tanh’。</p>
<p>返回值：一个神经网络层。</p>
<h2 id="keras-layers-LSTM-units-input-shape-x3D-activation-x3D"><a href="#keras-layers-LSTM-units-input-shape-x3D-activation-x3D" class="headerlink" title="keras.layers.LSTM(units, input_shape&#x3D;, activation&#x3D;)"></a><strong>keras.layers.LSTM(units, input_shape&#x3D;, activation&#x3D;)</strong></h2><p>功能：生成LSTM（循环）层。</p>
<p>units：指定循环核个数。</p>
<p>input_shape&#x3D;：指定输入形状。</p>
<p>activation&#x3D;：指定该层的激活函数。<br>值需为字符串。通常有’relu’，’sigmoid’和’tanh’。</p>
<p>返回值：一个神经网络层。</p>
<h2 id="keras-optimizers-SGD-lr-x3D-momentum-x3D"><a href="#keras-optimizers-SGD-lr-x3D-momentum-x3D" class="headerlink" title="keras.optimizers.SGD(lr&#x3D;, momentum&#x3D;)"></a><strong>keras.optimizers.SGD(lr&#x3D;, momentum&#x3D;)</strong></h2><p>功能：生成一个优化器（optimizer）。</p>
<p>lr&#x3D;：设置学习率。<br>学习率在0~1之间，建议使用默认值。</p>
<p>momentum&#x3D;：设置动量。<br>工作原理为逐渐减小学习率以更准确符合模型。其值需&gt;0。建议使用默认值。</p>
<p>返回值：一个优化器（optimizer）。</p>
<h2 id="keras-optimizers-Adagrad-lr-x3D"><a href="#keras-optimizers-Adagrad-lr-x3D" class="headerlink" title="keras.optimizers.Adagrad(lr&#x3D;)"></a><strong>keras.optimizers.Adagrad(lr&#x3D;)</strong></h2><p>功能：生成一个优化器（optimizer）。</p>
<p>lr&#x3D;：设置学习率。<br>学习率在0~1之间，建议使用默认值。</p>
<p>返回值：一个优化器（optimizer）。</p>
<h2 id="keras-optimizers-Adadelta-lr-x3D"><a href="#keras-optimizers-Adadelta-lr-x3D" class="headerlink" title="keras.optimizers.Adadelta(lr&#x3D;)"></a><strong>keras.optimizers.Adadelta(lr&#x3D;)</strong></h2><p>功能：生成一个优化器（optimizer）。</p>
<p>lr&#x3D;：设置学习率。<br>学习率在0~1之间，建议使用默认值。</p>
<p>返回值：一个优化器（optimizer）。</p>
<h2 id="keras-optimizers-Adam-lr-x3D-beta-1-x3D-0-9-beta-2-x3D-0-999"><a href="#keras-optimizers-Adam-lr-x3D-beta-1-x3D-0-9-beta-2-x3D-0-999" class="headerlink" title="keras.optimizers.Adam(lr&#x3D;, beta_1&#x3D;0.9, beta_2&#x3D;0.999)"></a><strong>keras.optimizers.Adam(lr&#x3D;, beta_1&#x3D;0.9, beta_2&#x3D;0.999)</strong></h2><p>功能：生成一个优化器（optimizer）。</p>
<p>lr&#x3D;：设置学习率。<br>学习率在0~1之间，建议使用默认值。</p>
<p>beta_1&#x3D;：不明参数。<br>其值应接近于1但小于1。</p>
<p>beta_2&#x3D;：不明参数。<br>其值应接近于1但小于1。</p>
<p>返回值：一个优化器（optimizer）。</p>
<h2 id="keras-losses-MeanSquaredError"><a href="#keras-losses-MeanSquaredError" class="headerlink" title="keras.losses.MeanSquaredError()"></a><strong>keras.losses.MeanSquaredError()</strong></h2><p>功能：生成一个采用均方差的loss函数。</p>
<p>返回值：采用均方差的loss函数。</p>
<h2 id="keras-losses-SparseCategoricalCrossentropy-from-logits-x3D-False"><a href="#keras-losses-SparseCategoricalCrossentropy-from-logits-x3D-False" class="headerlink" title="keras.losses.SparseCategoricalCrossentropy(from_logits&#x3D;False)"></a><strong>keras.losses.SparseCategoricalCrossentropy(from_logits&#x3D;False)</strong></h2><p>功能：生成一个采用SparseCategoricalCrossentropy的loss函数。</p>
<p>from_logits&#x3D;：设置是否为原始输出。<br>即：最后一层没有使用sigmoid作为激活函数，得到的输出就是原始输出，填True；否则应填False。</p>
<p>返回值：采用均方差的loss函数。</p>
<h2 id="model-compile-optimizer-x3D-，loss-x3D-，metrics-x3D"><a href="#model-compile-optimizer-x3D-，loss-x3D-，metrics-x3D" class="headerlink" title="model.compile(optimizer&#x3D;，loss&#x3D;，metrics&#x3D;)"></a><strong><span style="color:blue;">model</span>.compile(optimizer&#x3D;，loss&#x3D;，metrics&#x3D;)</strong></h2><p>功能：定义网络的各种参数。</p>
<p>optimizer&#x3D;：指定优化器<br>可以使用默认的’sgd’，’adagrad’，’adadelta’和’adam’。也可以通过调用上述优化器函数来自定义这些优化器。</p>
<p>loss&#x3D;：设置loss函数。<br>可以使用默认的’mse’和’sparse_categorical_crossentropy’等。也可以选择自定义。</p>
<p>metrics&#x3D;：设置评测指标。<br>请根据选择的loss函数选择合适的评测指标。评测指标为列表，列表内为字符串。候选项有<br>[‘accuracy’]，[‘categorical_accuracy’]和[‘sparse_categorical_accuracy’]等。</p>
<p>无返回值。</p>
<h2 id="model-fit-x-y-batch-size-x3D-epochs-x3D-verbose-x3D-callbacks-x3D-validation-split-x3D-validation-data-x3D"><a href="#model-fit-x-y-batch-size-x3D-epochs-x3D-verbose-x3D-callbacks-x3D-validation-split-x3D-validation-data-x3D" class="headerlink" title="model.fit(x, y, batch_size&#x3D;, epochs&#x3D;, verbose&#x3D;, callbacks&#x3D;, validation_split&#x3D;, validation_data&#x3D;)"></a><strong><span style="color:blue;">model</span>.fit(x, y, batch_size&#x3D;, epochs&#x3D;, verbose&#x3D;, callbacks&#x3D;, validation_split&#x3D;, validation_data&#x3D;)</strong></h2><p>功能：训练模型。</p>
<p>x：训练用的数据。<br>应该与y的形状一致。</p>
<p>y：训练用的标签。<br>应该与x的形状一致。</p>
<p>batch_size&#x3D;：将数据集多少组打一包进行训练。</p>
<p>epochs&#x3D;：设置数据集训练多少次。</p>
<p>verbose&#x3D;：指定是否显示日志。<br>0：不显示日志<br>1：输出进度条<br>2：每个epoch结束后给出信息。</p>
<p>callback&#x3D;：指定回调函数用于保存模型。<br>该参数由tensorflow.keras.callbacks.ModelCheckpoint()函数返回。</p>
<p>validation_split&#x3D;：指定从训练集中划分多少作为测试集。<br>值应该在0~1之间。与validation_data参数冲突。</p>
<p>validation_data&#x3D;：指定测试集。<br>传入格式应该为(测试数据,测试标签)。</p>
<p>返回值：模型训练结束后的格式。</p>
<h2 id="model-summary"><a href="#model-summary" class="headerlink" title="model.summary()"></a><strong>model.summary()</strong></h2><p>功能：打印模型的网络结构。</p>
<p>无返回值。</p>
<h2 id="keras-layers-BatchNormalization"><a href="#keras-layers-BatchNormalization" class="headerlink" title="keras.layers.BatchNormalization()"></a><strong>keras.layers.BatchNormalization()</strong></h2><p>功能：生成一个批标准化层。</p>
<p>返回值：一个神经网络层。</p>
<h2 id="keras-layers-MaxPool2D-pool-size-x3D-strides-x3D-padding-x3D"><a href="#keras-layers-MaxPool2D-pool-size-x3D-strides-x3D-padding-x3D" class="headerlink" title="keras.layers.MaxPool2D(pool_size&#x3D;, strides&#x3D;, padding&#x3D;)"></a><strong>keras.layers.MaxPool2D(pool_size&#x3D;, strides&#x3D;, padding&#x3D;)</strong></h2><p>功能：生成一个最大池化层。</p>
<p>pool_size&#x3D;：指定池化核大小。</p>
<p>strides&#x3D;：指定步长。</p>
<p>padding&#x3D;：指定填充方式。<br>值需为字符串。通常有’valid’（不填充）和’same’（全0填充）。</p>
<p>返回值：一个神经网络层。</p>
<h2 id="keras-layers-AveragePooling2D-pool-size-x3D-strides-x3D-padding-x3D"><a href="#keras-layers-AveragePooling2D-pool-size-x3D-strides-x3D-padding-x3D" class="headerlink" title="keras.layers.AveragePooling2D(pool_size&#x3D;, strides&#x3D;, padding&#x3D;)"></a><strong>keras.layers.AveragePooling2D(pool_size&#x3D;, strides&#x3D;, padding&#x3D;)</strong></h2><p>功能：生成一个平均池化层。</p>
<p>pool_size&#x3D;：指定池化核大小。</p>
<p>strides&#x3D;：指定步长。</p>
<p>padding&#x3D;：指定填充方式。<br>值需为字符串。通常有’valid’（不填充）和’same’（全0填充）。</p>
<p>返回值：一个神经网络层。</p>
<h2 id="keras-layers-Dropout-rate-x3D"><a href="#keras-layers-Dropout-rate-x3D" class="headerlink" title="keras.layers.Dropout(rate&#x3D;)"></a><strong>keras.layers.Dropout(rate&#x3D;)</strong></h2><p>功能：按照给定的概率临时舍弃部分神经元。</p>
<p>rate&#x3D;：指定舍弃的概率。<br>其值应在0~1之间。建议为0.2。</p>
<p>无返回值。</p>
<h2 id="model-load-weights-path"><a href="#model-load-weights-path" class="headerlink" title="model.load_weights(path)"></a><strong>model.load_weights(path)</strong></h2><p>功能：读取模型</p>
<p>path：指定模型所在的路径。</p>
<p>无返回值。</p>
<h2 id="keras-callbacks-ModelCheckpoint-filepath-x3D-monitor-x3D-mode-x3D-save-freq-x3D-save-weights-only-x3D-save-best-only-x3D"><a href="#keras-callbacks-ModelCheckpoint-filepath-x3D-monitor-x3D-mode-x3D-save-freq-x3D-save-weights-only-x3D-save-best-only-x3D" class="headerlink" title="keras.callbacks.ModelCheckpoint(filepath&#x3D;, monitor&#x3D;, mode&#x3D;, save_freq&#x3D;,save_weights_only&#x3D;,save_best_only&#x3D;)"></a><strong>keras.callbacks.ModelCheckpoint(filepath&#x3D;, monitor&#x3D;, mode&#x3D;, save_freq&#x3D;,save_weights_only&#x3D;,save_best_only&#x3D;)</strong></h2><p>功能：生成回调函数以保存模型训练后的参数。</p>
<p>filepath&#x3D;：指定模型保存路径。</p>
<p>monitor&#x3D;：指定需要监视的值。<br>一般指定’val_loss’，即测试集的loss。</p>
<p>mode&#x3D;：指定什么情况下保存模型。<br>指定是变大保存还是变小保存。<br>函数会根据monitor的值自动指定，可忽略此选项。</p>
<p>save_freq&#x3D;：指定保存频率。<br>这个频率是step的频率，要想每个epoch保存一次，请填写’epoch’。</p>
<p>save_weights_only&#x3D;：指定是否只保存参数。<br>若为False，则会将神经网络的结构一并保存。若为True则只保存参数。</p>
<p>save_best_only&#x3D;：指定是否指保存最佳结果。</p>
<h2 id="keras-layers-Activation-name-x3D"><a href="#keras-layers-Activation-name-x3D" class="headerlink" title="keras.layers.Activation(name&#x3D;)"></a><strong>keras.layers.Activation(name&#x3D;)</strong></h2><p>功能：生成激活函数。</p>
<p>name&#x3D;：指定激活函数的名称。</p>
<p>返回值：一个激活函数。</p>
<h2 id="keras-layers-SimpleRNN-units-activation-x3D-return-sequences-x3D"><a href="#keras-layers-SimpleRNN-units-activation-x3D-return-sequences-x3D" class="headerlink" title="keras.layers.SimpleRNN(units, activation&#x3D;, return_sequences&#x3D;)"></a><strong>keras.layers.SimpleRNN(units, activation&#x3D;, return_sequences&#x3D;)</strong></h2><p>功能：生成一个循环计算层。</p>
<p>units：指定记忆体数量。</p>
<p>activation&#x3D;：指定该层的激活函数。<br>值需为字符串。通常有’relu’，’sigmoid’和’tanh’。</p>
<p>return_sequences&#x3D;：指定是否每个时刻都输出结果。</p>
<p>返回值：一个神经网络层。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>Python API</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础（一）</title>
    <url>/2022/03/12/VueGrammar01/</url>
    <content><![CDATA[<img src="/2022/03/12/VueGrammar01/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有HTML和JavaScript基础，并且最好学过CSS。</div>
</div>

<span id="more"></span>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>Vue是一个开源的JavaScript库。它的目标是更好地开发网页。jQuery能更快地找到网页中的元素对象、更方便地设置事件、样式与动画等。而Vue，则实现了模块化。</p>
<p>关于Vue库与开发者插件的下载请自行百度，此处不做赘述。在使用Vue库之前，应当先在HTML文件中引入Vue库：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a><strong>二、入门</strong></h2><h3 id="1-模板语法"><a href="#1-模板语法" class="headerlink" title="(1) 模板语法"></a><strong>(1) 模板语法</strong></h3><p>在Vue中，被Vue截关的HTML元素中的“异常”语法被称为模板语法。模板语法分为两种，插值语法和指令语法。</p>
<h4 id="1-插值语法"><a href="#1-插值语法" class="headerlink" title="1. 插值语法"></a><strong>1. 插值语法</strong></h4><p>在Vue的库中有一个名为 <code>Vue</code> 的构造函数。该构造函数必须使用 <code>new</code> 关键字创建实例对象后才能使用。该实例会“接管”HTML中的<span style="color:red;">一个</span>元素。</p>
<p>本文的代码样例将只写出 <code>&lt;body&gt;</code> 元素内的代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建Vue匿名实例，传入的参数是一个匿名对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 匿名对象有一个el属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 它是element的缩写，代表HTML元素</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 其值应符合CSS选择器的语法</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 存储要替换的数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">text</span>: <span class="string">&quot;Hello, world!&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>网页的表现为：</p>
<p><img src="/2022/03/12/VueGrammar01/1.jpg" alt="1 1" title="1"></p>
<p>网页并没有显示 <code>&#123;&#123;text&#125;&#125;</code> ，而是显示了 <code>Hello, world!</code> 。这是因为Vue实例接管了id为 <code>test</code> 的元素。</p>
<p>Vue和PHP略有相似之处。Vue中的标记语法是 <code>&#123;&#123;&#125;&#125;</code> ，在两个大括号内的字符将被认为是“变量”，它会被替换掉。Vue会在传入构造函数的对象中寻找 <code>data</code> 对象中的属性，若有与“变量”相符的属性名，则将 <code>&#123;&#123;&#125;&#125;</code> 连同其中的“变量”替换为属性值。若没有，则会删除之。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>Vue实例与HTML元素</strong></div>

<div style="color:goldenrod;">一个Vue实例只能接管一个HTML元素；一个HTML元素只能被一个Vue实例接管。即Vue实例与HTML元素是一一对应关系。这就是为什么Vue非常适合模块化开发。</div>
</div>

<p>此外，在 <code>&#123;&#123;&#125;&#125;</code> 中也能写JavaScript中会产生值的函数或表达式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;text.toUpperCase()&#125;&#125;, &#123;&#123;Date.now()&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">text</span>: <span class="string">&quot;Hello, world!&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述的代码将会把 <code>Hello,world!</code> 转换为全大写输出，并打印 <code>Date.now()</code> 的值。</p>
<h4 id="2-指令语法"><a href="#2-指令语法" class="headerlink" title="2. 指令语法"></a><strong>2. 指令语法</strong></h4><p>插值语法是用于替换HTML的文本内容的，而指令语法则用于替换HTML的元素的属性。在HTML元素的属性之前加上 <code>v-bind:</code> 关键字即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引号内不需要使用&#123;&#123;&#125;&#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;Type&quot;</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Type</span>: <span class="string">&quot;color:red;&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码将会把 <code>Hello, world!</code> 文本以红色字体显示。 <code>v-bind:</code> 关键字指示其后的第一个属性的值，是指令语法，它应当被替换。目前版本的Vue已经支持将 <code>v-bind:</code> 简写为 <code>:</code> 。</p>
<p>Vue中还有除了 <code>v-bind</code> 外其他的指令语法，这里先只介绍一种： <code>v-model</code> ，其余的下文会慢慢叙述。它的所绑定的属性值是双向影响的。如果该值在网页中因“外力”而改变，那么绑定在其上的对应的变量也会改变。但它有它的局限性， <code>v-bind</code> 可以用于任意的HTML元素，而 <code>v-model</code> 只能用于表单类元素的 <code>value</code> 等属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用v-model绑定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model:value</span>=<span class="string">&quot;Value&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Value</span>: <span class="string">&quot;请给定输入&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当改变输入框中的内容以后，<code>Value</code> 的值也会跟着改变。</p>
<p><img src="/2022/03/12/VueGrammar01/2.png" alt="1 1"></p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>Vue开发者插件</strong></div>

<div style="color:royalblue;">Vue有适用于Chrome内核的浏览器的插件，该插件能够查看Vue中实例的详细信息。上图就展示了Vue实例中 <code>data</code> 对象的属性。可以看到该属性是随着输入框的内容变化而变化的。</div>
</div>

<p>此外， <code>v-model:value</code> 可以简写为 <code>v-model</code> 。</p>
<h3 id="2-el-与-data"><a href="#2-el-与-data" class="headerlink" title="(2) el 与 data"></a><strong>(2) <code>el</code> 与 <code>data</code></strong></h3><p>Vue允许初始化时空置 <code>el</code> 属性，可以之后再追加该属性。追加该属性需要用到 <code>$mount()</code> 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="title class_">Value</span>: <span class="string">&quot;请给定输入&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样是使用CSS语法</span></span><br><span class="line"><span class="title class_">Item</span>.$mount(<span class="string">&quot;#test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>data</code> 属性可以直接设置为对象，也可以设置为一个返回对象的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="title class_">Value</span>: <span class="string">&quot;来点输入&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 也可以简写为：</span></span><br><span class="line"><span class="comment">    data()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return &#123;</span></span><br><span class="line"><span class="comment">            Value: &quot;来点输入&quot;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Item</span>.$mount(<span class="string">&quot;#test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码同样能正常生效，但不允许使用lambda表达式的函数。</p>
<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>lambda表达式的局限性</strong></div>

<div style="color:darkred;">lambda表达式所创建的函数，其 <code>this</code> 指针是“异常”的。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda表达式定义的方法</span></span><br><span class="line">    <span class="attr">fun1</span>: <span class="function">() =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;From fun1() :&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印this指针</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数定义的方法</span></span><br><span class="line">    <span class="attr">fun2</span>: <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;From fun2() :&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印this指针</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">temp.<span class="title function_">fun1</span>();</span><br><span class="line">temp.<span class="title function_">fun2</span>();</span><br></pre></td></tr></table></figure>

<div style="color:darkred;">使用 <code>node</code> 运行上述JavaScript代码，其输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">From fun1() :</span><br><span class="line">&#123;&#125;</span><br><span class="line">From fun2() :</span><br><span class="line">&#123; fun1: [Function: fun1], fun2: [Function: fun2] &#125;</span><br></pre></td></tr></table></figure>

<div style="color:darkred;">可以看到，使用lambda表达式的 <code>this</code> 指针并没有指向调用它的对象，而是指向了 <code>temp</code> 对象所处的环境，即上下文对象。这是非常危险的。</div>
</div>

<h3 id="3-数据代理"><a href="#3-数据代理" class="headerlink" title="(3) 数据代理"></a><strong>(3) 数据代理</strong></h3><p>首先需要介绍 <code>defineProperty()</code> 方法。该方法定义在 <code>Object</code> 对象下，是JavaScript内置的对象。Vue底层很多原理都应用到了这个方法。该方法会为指定的对象添加属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建HIE对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">HIE</span> = &#123;</span><br><span class="line">    <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为HIE添加Type属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable constant_">HIE</span>, <span class="string">&quot;Type&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Type-005&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看HIE的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">HIE</span>);</span><br><span class="line"><span class="comment">// 查看HIE的Type属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">HIE</span>.<span class="property">Type</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">&#123; Name: &#x27;Lacia&#x27; &#125;</span><br><span class="line">Type-005</span><br></pre></td></tr></table></figure>

<p>可以看见，输出的 <code>HIE</code> 对象中并不包含 <code>Type</code> 属性，但是输出 <code>Type</code> 属性却是正常的。这是因为，由 <code>defineProperty()</code> 方法添加的属性是不可遍历的。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>属性的属性</strong></div>

<div style="color:royalblue;">虽然很绕，但是对象的属性也有属性。这些属性可以通过 <code>getOwnPropertyDescriptor()</code> 方法查看，该方法定义在 <code>Object</code> 对象下。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Name property : &quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable constant_">HIE</span>, <span class="string">&quot;Name&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Type property : &quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable constant_">HIE</span>, <span class="string">&quot;Type&quot;</span>));</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">&#123; Name: &#x27;Lacia&#x27; &#125;</span><br><span class="line">Type-005</span><br><span class="line"></span><br><span class="line">Name property :</span><br><span class="line">&#123;</span><br><span class="line">  value: &#x27;Lacia&#x27;,</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Type property :</span><br><span class="line">&#123;</span><br><span class="line">  value: &#x27;Type-005&#x27;,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: false,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">上述输出结果展示了属性的属性。<code>value</code> 属性代表它的值， <code>writable</code> 属性代表它可不可以被修改， <code>enumerable</code> 属性代表它可不可以被枚举， <code>configurable</code> 属性代表它可不可以被删除。这些属性的属性都可以通过 <code>defineProperty()</code> 来设置。</div>
</div>

<p>除了上述列举的四种属性，对象的属性还有两个方法： <code>get()</code> 和 <code>set()</code> 。使用这两个方法可以将该属性的属性值与某个外部变量关联起来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Communism</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个外部变量</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Now</span> = <span class="number">2022</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Communism</span>, <span class="string">&quot;Experienced&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 当设置get与set方法时</span></span><br><span class="line">    <span class="comment">// 不允许设置其它四个属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法的返回值会作为属性值</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="title class_">Now</span> - <span class="number">1848</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法会改变外部变量，从而影响get方法</span></span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">Value</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Now</span> = <span class="title class_">Value</span> + <span class="number">1848</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Communism.Experienced : &quot;</span> + <span class="title class_">Communism</span>.<span class="property">Experienced</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变外部变量后检查属性值</span></span><br><span class="line"><span class="title class_">Now</span> = <span class="number">1917</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Communism.Experienced : &quot;</span> + <span class="title class_">Communism</span>.<span class="property">Experienced</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变属性值后检查外部变量</span></span><br><span class="line"><span class="title class_">Communism</span>.<span class="property">Experienced</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Now = &quot;</span> + <span class="title class_">Now</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">Communism.Experienced : 174</span><br><span class="line">Communism.Experienced : 69</span><br><span class="line">Now = 1848</span><br></pre></td></tr></table></figure>

<p>可以看见，上述代码中， <code>Communism</code> 对象的 <code>Experienced</code> 属性与外部变量 <code>Now</code> 关联起来了。Vue将HTML中的“变量”与Vue实例中的属性关联起来的底层原理就是上述代码的原理。这就是数据代理。</p>
<p>通过Vue的构造函数来创建的Vue对象，含有作为参数的对象的 <code>data</code> 属性的属性。这些属性是一一对应且互相绑定的，其实现原理是上述的数据代理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;Value&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 不使用匿名对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">Config</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Value</span>: <span class="number">114514</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建Vue实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(<span class="title class_">Config</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码的效果为：</p>
<p><img src="/2022/03/12/VueGrammar01/3.png" alt="3 3" title="3"></p>
<p>当在控制台中修改 <code>Config.data.Value</code> 的值时，网页中的内容也随之变化：</p>
<p><img src="/2022/03/12/VueGrammar01/4.png" alt="4 4" title="4"></p>
<p>当在控制台中输入 <code>Item</code> ，查看Vue实例的属性时，可以看到它有一个名为 <code>Value</code> 的属性，并且拥有 <code>get</code> 与 <code>set</code> 方法。</p>
<p><img src="/2022/03/12/VueGrammar01/5.png" alt="5 5" title="5"></p>
<p><code>get</code> 与 <code>set</code> 方法由于滚动条限制没有截取到。<del>就这么大点的图压缩了都有30KB，要老命了，这个博客网页加载慢80%是图片大小的原因，15%是CDN的原因，5%是托管平台的原因。</del>上述的过程也说明了插值语法的“变量”是在Vue实例的属性中查找的。</p>
<p>此外，Vue实例中的 <code>_data</code> 属性与作为参数传入的对象的 <code>data</code> 属性指向同一个堆地址，即它们是同一个对象，使用 <code>===</code> 判断是否相等将返回 <code>true</code> 。因此传入Vue实例的对象不一定非要“有名字”，作为匿名对象传入后，其 <code>data</code> 属性依然能够通过Vue实例的 <code>_data</code> 属性修改。</p>
<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>修改 <code>data</code> 属性下的数组</strong></div>

<div style="color:darkred;">切记不要用索引来修改Vue中的数组！否则将发生不幸的事故。</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;HIE[0]&#125;&#125;, &#123;&#123;HIE[1]&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">HIE</span>: [<span class="string">&quot;Kouka&quot;</span>, <span class="string">&quot;Lacia&quot;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:darkred;">上述代码的效果如下：</div>

<p><img src="/2022/03/12/VueGrammar01/16.png" alt="16 16" title="16"></p>
<div style="color:darkred;">在控制台中尝试使用索引修改 <code>HIE</code> 的第一个元素：</div>

<p><img src="/2022/03/12/VueGrammar01/17.png" alt="17 17" title="17"></p>
<div style="color:darkred;">不幸的事故发生了，元素修改成功了，但没能引发Vue更新HTML，网页上的显示结果没有改变。这是因为Vue并没有监测使用索引引修改数组的行为。能被监测到的修改数组的行为，只有如下方法：

<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>unshift()</code></li>
<li><code>shift()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
<li><code>splice()</code></li>
</ul>
<p>上述方法虽然是常见的数组对象的方法，功能也一致，但是在Vue实例中，它们是Vue“重写”的方法。其中，能够修改数组元素的是 <code>splice()</code> 方法。因此正确的修改行为应该是：</p>
</div>

<p><img src="/2022/03/12/VueGrammar01/18.png" alt="18 18" title="18"></p>
</div>

<h3 id="4-事件"><a href="#4-事件" class="headerlink" title="(4) 事件"></a><strong>(4) 事件</strong></h3><p>在Vue中使用的事件名，不需要写 <code>on</code> 。例如当按键被按下时想触发事件，应在HTML元素中添加 <code>onkeydown</code> 属性；而在Vue中，使用 <code>keydown</code> 即可。</p>
<h4 id="1-绑定事件"><a href="#1-绑定事件" class="headerlink" title="1. 绑定事件"></a><strong>1. 绑定事件</strong></h4><p>使用 <code>v-on:</code> 关键字修饰HTML元素的属性，可以将其值设置为一个函数名。这个函数需要定义在Vue构造函数的参数对象的 <code>methods</code> 属性下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;ButtonClicked&quot;</span>&gt;</span>&#123;&#123;Value&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Value</span>: <span class="number">114514</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// v-on绑定的事件将会在该属性内寻找回调函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">ButtonClicked</span>(event)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">Value</span> = <span class="number">1919810</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>事件对象</strong></div>

<div style="color:royalblue;">网页事件触发时将会调用JavaScript的回调函数，并且会传入一个参数，该参数即为事件对象。事件对象有很多方便的属性，例如是哪个HTML元素触发了这个事件，触发事件时鼠标的位置等，此处不做赘述，详情请参见 <a class="btn" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event ">MDN Web 文档</a> 。</div>
</div>

<p>上述的代码在浏览器中会生成一个按钮，其上的文本为“114514”，单击按钮以后其上的文本变成“1919810”。</p>
<p>在Vue构造函数的参数对象中， <code>methods</code> 属性下的属性不会做数据代理。因此建议将回调函数写在该属性下（因为它们不会被修改0）。另外，上述方式设置的事件也能设置要传递的参数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- $event是一个特殊的符号，Vue会将其解析为事件对象 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当省略()时，将默认传递且传递事件对象参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;ButtonClicked($event,Date.now(),$event.target)&quot;</span>&gt;</span>&#123;&#123;Value&#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Value</span>: <span class="number">114514</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">ButtonClicked</span>(a, b, c)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述的代码在点击按钮后将会在控制台中打印：</p>
<p><img src="/2022/03/12/VueGrammar01/6.png" alt="6 6" title="6"></p>
<p>此外， <code>v-on:</code> 关键字可以简写为 <code>@</code> 符号，它们在Vue解析时是等价的。</p>
<h4 id="2-事件修饰符"><a href="#2-事件修饰符" class="headerlink" title="2. 事件修饰符"></a><strong>2. 事件修饰符</strong></h4><p>Vue中存在事件修饰符，它可以修改事件的一些行为。事件修饰符的用法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;ButtonClicked&quot;</span>&gt;</span>&#123;&#123;Value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>.prevent</code> 即为事件修饰符。Vue中的常见的事件修饰符如下：</p>
<table>
<thead>
<tr>
<th align="center">事件修饰符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.prevent</code></td>
<td align="center">阻止默认事件</td>
</tr>
<tr>
<td align="center"><code>.stop</code></td>
<td align="center">阻止事件冒泡</td>
</tr>
<tr>
<td align="center"><code>.once</code></td>
<td align="center">事件只被触发一次</td>
</tr>
<tr>
<td align="center"><code>.capture</code></td>
<td align="center">使用事件的捕获模式</td>
</tr>
<tr>
<td align="center"><code>.self</code></td>
<td align="center">仅当 <code>event.target</code> 是本元素时才触发事件</td>
</tr>
<tr>
<td align="center"><code>.passive</code></td>
<td align="center">触发事件时立即执行默认行为</td>
</tr>
</tbody></table>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>捕获与冒泡</strong></div>

<div style="color:royalblue;">在嵌套结构的HTML元素中，如果同时触发了内外的事件（例如内层 <code>&lt;div&gt;</code> 和外层 <code>&lt;div&gt;</code> 都定义了鼠标单击事件），那么就存在事件处理的先后顺序。从外层元素的事件开始处理，是事件的捕获模式；从内层元素的事件开始处理，则是事件的冒泡模式。默认的事件处理行为是冒泡模式。</div>
</div>

<p>所有的修饰符都是允许叠加、允许混搭的，包括下述的修饰符。</p>
<h4 id="3-按键修饰符"><a href="#3-按键修饰符" class="headerlink" title="3. 按键修饰符"></a><strong>3. 按键修饰符</strong></h4><p>Vue中还存在按键修饰符，即指定当何种按键被按下时才会触发事件。这些修饰符一般用于 <code>keydown</code> 和 <code>keyup</code> 事件。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>keydown</code> 与 <code>keyup</code></strong></div>

<div style="color:royalblue;"><code>keydown</code> 事件是在按键按下时立即触发，而 <code>keyup</code> 则是松开按键时才会触发。这两个事件的特性造成了它们之间的差异：前者可以捕获Windows键、Tab键、Shift键、Alt键和Ctrl键，而后者在某些浏览器上不行，这取决于浏览器的处理顺序。</div>
</div>

<p>这些修饰符虽然数量庞大，但有规律可循：键盘上的按键有两种唯一区分的标记，一个是按键名，另一个是按键码。 <code>.按键名</code> 或者 <code>.按键码</code> 即为按键修饰符。<span style="color:red;">推荐使用按键名，因为似乎按键码已经开始逐渐不被支持了</span>。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>按键名的规则与按键修饰符的局限性</strong></div>

<div style="color:goldenrod;">JavaScript标记的按键名是驼峰规则书写的，例如 <code>CapsLock</code> ，而Vue则要求你将其转换为全小写的“烤串”规则，即以 <code>caps-lock</code> 作为对应的按键修饰符。<br>
另外，并不是所有的按键都可以被JavaScript捕获。但常用的按键都可以被捕获，所以放心大胆地用就完事辣！</div>
</div>

<p>你可以百度搜索“键码”以查找按键码，也可以通过下面的输入框来测试你键盘上各个按键的按键名与按键码。</p>
<div style="text-align:center;">
    <input id="KeyboardChecker" type="text" placeholder="点我以进行测试" onkeyup="this.value='按键名：'+event.key+'    按键码：'+event.keyCode;" readonly style="width:80%;height:100%;text-align:center;">
</div>

<p>上述的输入框不会接受用户输入，可以放心折腾。请先点击上面的输入框，再按键盘即可获取按键名与按键码。上述功能的JavaScript实现很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="string">&#x27;按键名：&#x27;</span> + event.<span class="property">key</span> + <span class="string">&#x27;    按键码：&#x27;</span> + event.<span class="property">keyCode</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>this</code> 代表触发该事件的HTML元素，即输入框，它的 <code>value</code> 属性就是其中的显示文本。 <code>event</code> 是事件对象，该对象的 <code>key</code> 属性是触发该事件的按键名， <code>keyCode</code> 属性则是该按键的按键码。</p>
<p>另外， <code>.exact</code> 关键字将会让事件在<span style="color:red;">按下且仅按下指定的按键</span>时才触发。</p>
<h3 id="5-计算属性"><a href="#5-计算属性" class="headerlink" title="(5) 计算属性"></a><strong>(5) 计算属性</strong></h3><p>当Vue的插值语法中的“变量”值，是需要根据其它的“变量”而得出时，就需要使用计算属性。在Vue构造函数的参数对象中的 <code>computed</code> 属性即为计算属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 插值语法，Base与Index都是data属性的属性 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 要求输入为数字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;Base&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;Index&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Result为计算属性，根据Base与Index得到 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Index</span>: <span class="string">&quot;1&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Base</span>: <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 定义计算属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 计算属性本身是一个对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 它必须要有get方法，可以没有set方法（如果是只读的话）</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Result</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">                &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 简单的指数运算，但要先类型转换</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// Vue会将函数的调用者设置为Vue实例</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 即：在Vue实例中的方法中，this指针将永远指向Vue实例</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">Base</span>), <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">Index</span>));</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码是一个简单的指数运算代码，并且没有做输入检查（即指数与底数不允许同时为0，不允许输入为空）。其效果如下：</p>
<p><img src="/2022/03/12/VueGrammar01/7.png" alt="7 7" title="7"></p>
<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>不要使用方法或插值语法！</strong></div>

<div style="color:darkred;">上述的效果当然也可以使用插值语法搭配 <code>methods</code> 属性实现，或只使用插值语法也行。但这存在一个严重的问题：计算出的值无法复用。上述两种替代方案不论哪种，每当需要值时，都会再计算一次。</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;Base&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;Index&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 多写一点，看看调用的次数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result0()&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result0()&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result0()&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;Result0()&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Index</span>: <span class="string">&quot;1&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Base</span>: <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Result0</span>()</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 看使用methods时会被调用多少次</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数被调用&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">Base</span>), <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">Index</span>));</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Result</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">                &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 看看计算属性的调用次数</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;重新计算值&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">Base</span>), <span class="built_in">parseInt</span>(<span class="variable language_">this</span>.<span class="property">Index</span>));</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:darkred;">控制台输出结果为：</div>

<p><img src="/2022/03/12/VueGrammar01/8.png" alt="8 8" title="8"></p>
<div style="color:darkred;">使用 <code>methods</code> 属性 + 插值语法的方式，每遇到一次就计算一次。当调用次数很庞大时，网页性能将大幅下降。而计算属性则只会计算一次，显然计算属性优势明显。</div>
</div>

<p>上面的例子说明，Vue为计算属性维护了一个“缓存”，每次都从“缓存”中读取数据。刷新“缓存”，执行计算的时机有二：</p>
<ol>
<li>首次加载时</li>
<li>依赖的值改变时</li>
</ol>
<p>当只计算属性是只读时，可以直接把计算属性简写为函数而不是一个有 <code>get</code> 方法的对象。</p>
<h3 id="6-侦听属性"><a href="#6-侦听属性" class="headerlink" title="(6) 侦听属性"></a><strong>(6) 侦听属性</strong></h3><p>Vue允许侦听Vue实例的 <code>data</code> 的属性的值的变化<span style="color:red;">与计算属性</span>的值的变化，并在变化时执行指定的方法。实现侦听功能需要在Vue的构造函数的参数对象中添加 <code>watch</code> 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;Input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Input</span>: <span class="string">&quot;114514&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 设置侦听属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 要侦听data中的Input属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Input</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 是否要在加载HTML时就执行</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">immediate</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// Input值变化时会执行handler方法</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">handler</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">                &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value changing detected.&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码的效果如下：</p>
<p><img src="/2022/03/12/VueGrammar01/9.png" alt="9 9" title="9"></p>
<p>可以看见控制台在加载HTML时输出了一次 <code>Value changing detected.</code> ，并在改变文本框内容时再次输出。夹在这两次输出中间的输出，是Vue.js的开发者版本发出的信息，指示这是开发者版本，请只在开发模式下使用它，而不要在生产中使用。</p>
<p>侦听属性也可以在已经创建完Vue对象后在添加，只需要使用Vue对象的 <code>$watch()</code> 方法即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="comment">// ··········</span></span><br><span class="line">    <span class="comment">// 此处省略代码</span></span><br><span class="line">    <span class="comment">// ··········</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义data属性</span></span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="title class_">Input</span>: <span class="string">&quot;114514&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加侦听属性</span></span><br><span class="line"><span class="comment">// 属性名一定要传字符串</span></span><br><span class="line"><span class="title class_">Item</span>.$watch(<span class="string">&quot;Input&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">handler</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value changing detected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述两种方式是等价的，选择哪一种都行。下面详述 <code>handler</code> 方法。该方法是Vue设置的、在值更改时会自动调用的方法，它有两个参数：新值、旧值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;Input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Input</span>: <span class="string">&quot;114514&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Input</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">immediate</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">handler</span>(<span class="params">NewValue, OldValue, test</span>)</span></span><br><span class="line"><span class="language-javascript">                &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新值：&quot;</span> + <span class="title class_">NewValue</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;旧值：&quot;</span> + <span class="title class_">OldValue</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;测试有无值：&quot;</span> + test);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改变输入框中的值，控制台中会打印：</p>
<p><img src="/2022/03/12/VueGrammar01/10.png" alt="10 10" title="10"></p>
<p>另外，在 <code>watch</code> 属性中，还可以有一个属性： <code>deep</code> 。当它为 <code>true</code> 时，将会检测 <code>data</code> 内的属性内的属性的值是否改变。它默认是 <code>false</code> 。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;Layer.Trash.Input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Layer</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Trash</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title class_">Input</span>: <span class="string">&quot;114514&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Layer</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 启用深度监测</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 当它为false时，控制台将不会有任何输出</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">deep</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">handler</span>(<span class="params">NewValue</span>)</span></span><br><span class="line"><span class="language-javascript">                &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NewValue</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改变输入框中的值，控制台将会打印：</p>
<p><img src="/2022/03/12/VueGrammar01/11.png" alt="11 11" title="11"></p>
<p>可以看见成功监测到了 <code>Input</code> 值的改变，并且打印出的对象确实是 <code>Layer</code> 。</p>
<p>当侦听属性不需要设置额外的参数，只需要设置 <code>handler</code> 方法时，可以直接将其简写为方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 省略部分代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title class_">Input</span>(<span class="title class_">NewValue</span>, <span class="title class_">OldValue</span>) &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="comment">// 你的代码</span></span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="title class_">Item</span>.$watch(<span class="string">&quot;Input&quot;</span>, <span class="keyword">function</span> (<span class="params">NewValue, OldValue</span>) &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="comment">// 你的代码</span></span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>计算属性和侦听属性的区别在于，后者能完成的前者都能做，反之则不成立，但在二者都能实现的功能中，后者往往比前者更简洁。侦听属性可以利用 <code>setTimeout()</code> 函数实现延时更新，但计算属性不行。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>watch</code> 的一个专有功能</strong></div>

<div style="color:royalblue;">使用 <code>watch</code> 可以实现延迟更新，但 <code>computed</code> 不行。回调函数应当使用lambda表达式，因为lambda表达式的 <code>this</code> 指针指向调用该函数的对象所处的环境，在 <code>setTimeout()</code> 函数中，lambda表达式被  <code>setTimeout()</code> 函数调用，而该函数所处的环境是设置的侦听属性，是由Vue管理的，因此 <code>this</code> 最终会指向Vue实例。</div>
</div>

<h3 id="7-set"><a href="#7-set" class="headerlink" title="(7) set()"></a><strong>(7) <code>set()</code></strong></h3><p>此处的 <code>set()</code> 不是上文所述的对象的 <code>set()</code> 方法，而是Vue的 <code>set()</code> 方法。在已经实例化Vue对象后，若还想向该对象中添加数据，就必须使用Vue提供的 <code>set()</code> 方法，否则添加的属性不会有数据代理也不会有相应的HTML实时更新。</p>
<p>该方法接受三个参数，分别是要添加数据的对象、要添加的属性名、要添加属性的初始值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 无序列表，下文将会向其中添加元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(Element,Index) in List&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;Element.Name&#125;&#125;，&#123;&#123;Element.Type&#125;&#125;，&#123;&#123;Index&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">List</span>: [</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-005&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Kouka&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-001&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Method&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-004&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Vue的set()方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">set</span>(<span class="title class_">Item</span>.<span class="property">List</span>, <span class="number">3</span>, &#123; <span class="title class_">Name</span>: <span class="string">&quot;Undefined&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Unknown&quot;</span> &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>网页效果为：</p>
<p><img src="/2022/03/12/VueGrammar01/15.png" alt="15 15" title="15"></p>
<p>Vue对象还有 <code>$set()</code> 方法，它和 <code>set()</code> 方法是等价的。此处就不做演示。 <code>set()</code> 方法存在局限性，即它只能给 <code>data</code> 属性内的对象添加数据，而不能给Vue实例、 <code>data</code> 添加数据。</p>
<h2 id="三、指令语法"><a href="#三、指令语法" class="headerlink" title="三、指令语法"></a><strong>三、指令语法</strong></h2><h3 id="1-再探-v-bind"><a href="#1-再探-v-bind" class="headerlink" title="(1) 再探 v-bind"></a><strong>(1) 再探 <code>v-bind</code></strong></h3><h4 id="1-绑定-class"><a href="#1-绑定-class" class="headerlink" title="1. 绑定 class"></a><strong>1. 绑定 <code>class</code></strong></h4><p>当 <code>:</code> 绑定 <code>class</code> 属性时，原生的 <code>class</code> 会和 <code>:class</code> 一起生效。 <code>:class</code> 可以接受数组与对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        <span class="title class_">Value0</span>: [<span class="string">&#x27;class0&#x27;</span>, <span class="string">&#x27;class1&#x27;</span>, <span class="string">&#x27;class3&#x27;</span>],</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        <span class="comment">// true表示启用该类名，false表示禁用</span></span><br><span class="line">        <span class="title class_">Value1</span>: &#123;</span><br><span class="line">            <span class="attr">class0</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">class1</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">class2</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">class3</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述两种写法等价。数组写法常用于类名个数不确定或类名不确定的情况；对象写法常用于类名确定，但不确定要不要启用的情况。</p>
<h4 id="2-绑定-style"><a href="#2-绑定-style" class="headerlink" title="2. 绑定 style"></a><strong>2. 绑定 <code>style</code></strong></h4><p>当 <code>:</code> 绑定 <code>style</code> 属性时，其绑定值应当是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于原属性含有“-”，因此需要使用引号</span></span><br><span class="line">            <span class="string">&quot;background-color&quot;</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>:style</code> 也能接受对象数组，所有该数组内的对象所表示的样式会叠加生效。</p>
<h3 id="2-一些常见的其它指令语法"><a href="#2-一些常见的其它指令语法" class="headerlink" title="(2) 一些常见的其它指令语法"></a><strong>(2) 一些常见的其它指令语法</strong></h3><div class="tabs" id="commandgrammar"><ul class="nav-tabs"><li class="tab active"><a href="#commandgrammar-1"><code>v-if</code> 与 <code>v-show</code></a></li><li class="tab"><a href="#commandgrammar-2"><code>v-for</code></a></li><li class="tab"><a href="#commandgrammar-3"><code>v-text</code></a></li><li class="tab"><a href="#commandgrammar-4"><code>v-html</code></a></li><li class="tab"><a href="#commandgrammar-5"><code>v-cloak</code></a></li><li class="tab"><a href="#commandgrammar-6"><code>v-once</code></a></li><li class="tab"><a href="#commandgrammar-7"><code>v-pre</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="commandgrammar-1"><p>下述的关键字可以直接当作属性使用，不需要去绑定HTML原生的属性。</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">效果</th>
<th align="center">参数类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>v-show</code></td>
<td align="center">控制该元素是否显示</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>v-if</code></td>
<td align="center">控制元素是否出现在HTML中</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>v-else-if</code></td>
<td align="center">当上一个<code>v-if</code> 不成立时，控制当前元素是否出现在HTML中</td>
<td align="center"><code>boolean</code></td>
</tr>
<tr>
<td align="center"><code>v-else</code></td>
<td align="center">当它之前的 <code>v-if</code> 和 <code>v-else-if</code> 都不成立时，当前元素将出现在HTML中</td>
<td align="center">无</td>
</tr>
</tbody></table>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong><code>v-if</code> 的限制与 <code>v-show</code> 的限制</strong></div>

<div style="color:goldenrod;"><code>v-if</code> 、 <code>v-else-if</code> 和 <code>v-else</code> 这三者的使用方法与JavaScript的控制流很相似，它们所控制的元素必须是相邻的兄弟元素，中间不允许插入其他元素，否则控制语句将不会生效。并且它们是直接控制元素是否出现在HTML中，频繁地切换可能导致卡顿。<br>
而 <code>v-show</code> 不能作为 <code>&lt;template&gt;</code> 标签的属性，只有 <code>v-if</code> 可以。 <code>&lt;template&gt;</code> 标签在渲染时会被移除，不会影响HTML的展示结构。
</div>
</div></div><div class="tab-pane" id="commandgrammar-2"><p><code>v-for</code> 属性常用于 <code>&lt;li&gt;</code> 标签。它可以生成列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 无序列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用v-for来生成列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(Element,Index) in List&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;Element.Name&#125;&#125;，&#123;&#123;Element.Type&#125;&#125;，&#123;&#123;Index&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 需要被遍历的数组</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">List</span>: [</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-005&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Kouka&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-001&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Method&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-004&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码的效果如下：</p>
<p><img src="/2022/03/12/VueGrammar01/12.png" alt="12 12" title="12"></p>
<p><code>v-for</code> 与JavaScript的 <code>for</code> 有些许差异（或许有点像数组的 <code>forEach()</code> 方法）。<code>v-for</code> 接受两个迭代变量。</p>
<ul>
<li>当被遍历的变量是数组时，前者是该元素的值，后者是该元素的索引。</li>
<li>当被遍历的变量是对象时，前者是属性值，后者是属性名。</li>
<li>当被遍历的变量是字符串时，前者是字符，后者是该字符的索引。</li>
<li>当被遍历的变量是数字时，前者是从1开始的递增序列，后者是从0开始的递增序列。</li>
</ul>
<p>在使用 <code>v-for</code> 属性时，强烈建议搭配上 <code>:key</code> 属性一起使用。从名字上来看， <code>key</code> 只是个普通属性，只是使用了 <code>v-bind</code> 绑定了而已。事实上，该属性不会出现在HTML文件中，但它依然重要。</p>
<p>在上文的计算属性一节曾经提到了Vue中存在“缓存”。事实上，在HTML最终渲染完成前，Vue会先处理一次HTML中被接管的元素，然后再用处理后的元素替换HTML中的元素。为了减少处理次数，Vue维护了一个“缓存”。当更新网页中被接管的元素时，Vue会倾向于优先使用“缓存”。而这就是 <code>:key</code> 属性的重要之处。</p>
<p>先来看看不加 <code>:key</code> 属性会有什么下场：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(Element,Index) in List&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;Element.Name&#125;&#125;，&#123;&#123;Element.Type&#125;&#125;，&#123;&#123;Index&#125;&#125;</span><br><span class="line">            <span class="comment">&lt;!-- 每一行后添加一个输入框 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按钮，其功能是向数组的首部添加元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;Add&quot;</span>&gt;</span>列表增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">List</span>: [</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-005&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Kouka&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-001&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">                &#123; <span class="title class_">Name</span>: <span class="string">&quot;Method&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Type-004&quot;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">Add</span>()</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">List</span>.<span class="title function_">unshift</span>(&#123; <span class="title class_">Name</span>: <span class="string">&quot;Undefined&quot;</span>, <span class="title class_">Type</span>: <span class="string">&quot;Unknown&quot;</span> &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打开网页，先不点按钮，在点按钮之前先向输入框中输入一些数据：</p>
<p><img src="/2022/03/12/VueGrammar01/13.png" alt="13 13" title="13"></p>
<p>然后再点击“列表增加按钮”：</p>
<p><img src="/2022/03/12/VueGrammar01/14.png" alt="14 14" title="14"></p>
<p>不幸的事情发生了。可以看到输入框中的数据并没有因为插入了新的行而向下移动。Vue在执行修改时，会倾向于优先使用“缓存”，也就是倾向于做最小改动。当不写 <code>:key</code> 时，Vue会默认帮你维护一个 <code>:key</code> ，它的值等于索引。Vue在执行修改时，会比对两个 <code>&lt;li&gt;</code> 元素的 <code>:key</code> 属性。如果一致，则认为这两个元素是对应的，若文本结点不一致，则会在原有的文本节点上进行修改。因此，第一行开头的文本原本是 <code>Lacia</code> ，Vue不是在它之前插入一行，而是将其中的文本进行了修改。</p>
<p>当对比到 <code>&lt;li&gt;</code> 元素内部的 <code>&lt;input&gt;</code> 元素时，由于输入框中的信息是之后用户添加的，并不会影响到Vue的缓存，因此比对时Vue会认为前后的  <code>&lt;input&gt;</code> 元素是一致的，不会做任何修改。这就产生了相当严重的问题。</p>
<p>因此， <code>:key</code> 属性的值应当能够唯一标识数组（或对象等）内的、当前正在显示的元素，否则就会因Vue的“缓存”机制而发生不幸的事故。上述代码中，由于是在数组的头部添加元素，使数组的顺序发生了改变，索引所标识的对象也就发生了改变，最终导致上述的异常状况。</p></div><div class="tab-pane" id="commandgrammar-3"><p>它的作用与插值语法一致，但它是通过作为HTML元素的属性生效的，并且它会完全覆盖元素内的文本。</p>
<p>由于过于简单，此处不做过多赘述。</p></div><div class="tab-pane" id="commandgrammar-4"><p>它的作用与 <code>v-text</code> 差不多，但 <code>v-html</code> 会将其中的HTML语言变成真实的HTML元素。</p></div><div class="tab-pane" id="commandgrammar-5"><p>该属性不需要值，也没有什么实际作用，Vue在接管HTML元素后会删除该属性。它常与CSS搭配，用于网页加载时间较长时，隐藏未被Vue处理的原HTML内容。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 属性选择器 */</span></span><br><span class="line"><span class="comment">/* 选中所有含有v-cloak属性的元素 */</span></span><br><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Vue介入之前，所有含有 <code>v-cloak</code> 属性的元素都不会被显示；而当Vue接管HTML元素以后， <code>v-cloak</code> 属性会被删除，Vue接管后的元素将被显示在网页中。</p></div><div class="tab-pane" id="commandgrammar-6"><p><code>v-once</code> 属性不需要值，含有此属性的HTML元素只会在Vue接管它时初始化一次，之后其中的插值语法、 <code>v-text</code> 等值不会被更改。</p></div><div class="tab-pane" id="commandgrammar-7"><p><code>v-pre</code> 属性不需要值，它会跳过Vue对HTML元素的解析，即：即便该元素含有插值语法或指令语法，Vue也会忽略。可以使用该属性加快不含Vue语法的元素的解析。</p></div></div></div>

<h3 id="3-自定义指令"><a href="#3-自定义指令" class="headerlink" title="(3) 自定义指令"></a><strong>(3) 自定义指令</strong></h3><p>Vue构造函数的参数对象可以设置 <code>directives</code> 属性。该属性就是控制自定义指令的属性。该属性下的属性有两种设置方法：对象式与函数式。</p>
<h4 id="1-函数式"><a href="#1-函数式" class="headerlink" title="1. 函数式"></a><strong>1. 函数式</strong></h4><p>首先来看一段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意该div元素有id属性，它被唯一标识了 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Vue中并没有v-custom指令，它是自定义指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;#target&quot;</span> <span class="attr">v-custom</span>=<span class="string">&quot;HIE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#test&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">HIE</span>: <span class="string">&quot;Lacia&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 与自定义指令相关的属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">directives</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 定义v-custom属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">custom</span>(<span class="params">element, binding</span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 查看参数是什么</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(element);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(binding);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器的控制台将输出：</p>
<p><img src="/2022/03/12/VueGrammar01/19.png" alt="19 19" title="19"></p>
<p>可以看到，使用自定义指令时不需要加上前缀的 <code>v-</code> 。并且，函数式的自定义指令可以接受两个参数，前者是一个HTML元素对象，指向使用了该指令的HTML元素；后者是一个对象，它包含了该指令的名称（ <code>name</code> 属性）、原名称（ <code>rawName</code> 属性）、它的值（ <code>expression</code> 属性）、它的值在 <code>data</code> 属性中的值（ <code>value</code> 属性）。在拿到相应的HTML元素和自定义指令的值以后，使用者就可以“为所欲为”了。JavaScript DOM中已经详述过了，此处不做赘述。</p>
<p>函数式的自定义指令，在它所在的Vue接管的HTML元素需要解析或重新解析（也就是加载或更新页面数据）时会被调用，不论是否改变了该自定义指令所用到的值。</p>
<h4 id="2-对象式"><a href="#2-对象式" class="headerlink" title="2. 对象式"></a><strong>2. 对象式</strong></h4><p>相比函数式自定义指令，对象式自定义指令相对繁琐，但它能更精确地控制HTML元素的行为。</p>
<p>对象式自定义指令内应当有三个函数： <code>bind()</code>、<code>inserted()</code>、<code>update()</code> ，它们将分别在绑定HTML元素时、处理后的HTML元素被插入页面时、更新HTML元素时被执行。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">被调用时间</th>
<th align="center">建议写在其中的功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>bind()</code></td>
<td align="center">HTML元素、对象</td>
<td align="center">Vue接管HTML元素之后，HTML元素被插入网页之前</td>
<td align="center">初始化时需要执行的功能，例如值初始化。</td>
</tr>
<tr>
<td align="center"><code>inserted()</code></td>
<td align="center">HTML元素、对象</td>
<td align="center">HTML元素被插入网页之后，网页加载完毕之前</td>
<td align="center">需要初始化时被执行，但又必须等到HTML元素被插入网页后的功能。例如自动获取焦点。</td>
</tr>
<tr>
<td align="center"><code>update()</code></td>
<td align="center">HTML元素、对象</td>
<td align="center">更新HTML元素时</td>
<td align="center">HTML元素的更新行为。</td>
</tr>
</tbody></table>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>自定义指令的 <code>this</code></strong></div>

<div style="color:goldenrod;">不论是在函数式自定义指令中，还是在对象式自定义指令的方法中， <code>this</code> 都是指向 <code>window</code> 对象而非Vue实例的。</div>
</div>

<h4 id="3-全局自定义指令"><a href="#3-全局自定义指令" class="headerlink" title="3. 全局自定义指令"></a><strong>3. 全局自定义指令</strong></h4><p>上述两种方法定义的自定义指令，只能在它所在的Vue实例中使用。要想设置全局可用的自定义指令，可以直接使用Vue对象下的 <code>directive()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式：函数式自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;Lacia&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ·······</span></span><br><span class="line">    <span class="comment">// 你的代码</span></span><br><span class="line">    <span class="comment">// ·······</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式：对象式自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;Kouka&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">bind</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ·······</span></span><br><span class="line">        <span class="comment">// 你的代码</span></span><br><span class="line">        <span class="comment">// ·······</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">inserted</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ·······</span></span><br><span class="line">        <span class="comment">// 你的代码</span></span><br><span class="line">        <span class="comment">// ·······</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ·······</span></span><br><span class="line">        <span class="comment">// 你的代码</span></span><br><span class="line">        <span class="comment">// ·······</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>JavaScript库</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础（二）</title>
    <url>/2022/04/18/VueGrammar02/</url>
    <content><![CDATA[<img src="/2022/04/18/VueGrammar02/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有HTML和JavaScript基础，并且最好学过CSS。</div>
</div>

<span id="more"></span>

<h2 id="四、生命周期"><a href="#四、生命周期" class="headerlink" title="四、生命周期"></a><strong>四、生命周期</strong></h2><p>Vue实例对象的生命周期，即Vue实例被创建（挂载流程）、Vue更新模板（更新流程）、回收Vue实例（销毁流程）三个阶段。这三个阶段又可进一步细分，其中每一个小环节分别有各自的回调函数，即可以让Vue在这写小环节开始时 &#x2F; 完成时执行用户自定义的语句。</p>
<h3 id="1-挂载流程"><a href="#1-挂载流程" class="headerlink" title="(1) 挂载流程"></a><strong>(1) 挂载流程</strong></h3><p>挂载阶段的流程图如下：</p>
<pre class="mermaid">
graph TD

A[开始] --&gt; B(创建实例)
B --&gt;|调用 &lt;code&gt;beforeCreate&lt;&#x2F;code&gt; 方法| C(数据代理)
C --&gt;|调用 &lt;code&gt;created&lt;&#x2F;code&gt; 方法| D(解析模板开始)
D(解析模板开始) --&gt; E{存在 &lt;code&gt;el&lt;&#x2F;code&gt; 属性}
E --&gt;|是| F{存在 &lt;code&gt;template&lt;&#x2F;code&gt; 属性}
E --&gt;|否| G(阻塞等待 &lt;code&gt;.$mount&lt;&#x2F;code&gt; 方法被调用)
G --&gt; F
F --&gt;|是| H(将 &lt;code&gt;template&lt;&#x2F;code&gt; 属性中的HTML语句作为模板解析)
F --&gt;|否| I(将 &lt;code&gt;el&lt;&#x2F;code&gt; 属性接管的HTML元素作为模板解析)
H --&gt; J(开始挂载)
I --&gt; J
J --&gt;|调用 &lt;code&gt;beforeMount&lt;&#x2F;code&gt; 方法| k(挂载完成)
k --&gt;|调用 &lt;code&gt;mounted&lt;&#x2F;code&gt; 方法| L[更新流程]

</pre>

<table>
<thead>
<tr>
<th align="center">回调函数名</th>
<th align="center">调用时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>beforeCreate()</code></td>
<td align="center">Vue实例创建完成后，数据代理开始前</td>
</tr>
<tr>
<td align="center"><code>created()</code></td>
<td align="center">Vue实例数据代理、数据监测完成后，开始解析模板前</td>
</tr>
<tr>
<td align="center"><code>beforeMount()</code></td>
<td align="center">Vue实例模板解析完成后，挂载（接管HTML）开始前</td>
</tr>
<tr>
<td align="center"><code>mounted()</code></td>
<td align="center">Vue挂载完成后，更新流程开始前</td>
</tr>
</tbody></table>
<p>执行如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 接管 id=&quot;root&quot; 的元素</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&quot;#root&quot;</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 设置一些数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">data</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">test</span>: <span class="string">&quot;114514&quot;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 在数据代理开始前查看 this.test 的值</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">beforeCreate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeCreate(): this.test =&quot;</span>, <span class="variable language_">this</span>.<span class="property">test</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 在数据代理完成后查看 this.test 的值</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">created</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;created(): this.test =&quot;</span>, <span class="variable language_">this</span>.<span class="property">test</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 在挂载前修改接管元素的 innerHTML</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">beforeMount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>).<span class="property">innerHTML</span> += <span class="string">&quot;挂载前&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>));</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 在挂载后查看 beforeMount() 方法的修改结果，并再次修改 innerHTML</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">mounted</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>).<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#root&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;挂载后&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p><img src="/2022/04/18/VueGrammar02/1.png" alt="1" title="1"></p>
<p>其中第一行输出是Vue的debug信息。第二行输出则表明了在数据代理完成前，通过 <code>Vue实例.成员</code> 的方式无法访问<code>data</code>属性中的数据。而数据代理完成后则可以访问。</p>
<p>第四行输出表明，在挂载开始前对Vue接管的元素内的改动都不会生效。因为在挂载开始前，Vue实例已经完成了对HTML的解析，并将它“缓存”了起来。挂载时，Vue将重构“缓存”的HTML，并在重构完成后替换原有的HTML。</p>
<p>一般在<code>mounted()</code>回调函数内定义计时器。</p>
<h3 id="2-更新流程"><a href="#2-更新流程" class="headerlink" title="(2) 更新流程"></a><strong>(2) 更新流程</strong></h3><p>更新阶段的流程图如下：</p>
<pre class="mermaid">
graph TD

A[挂载流程] --&gt;|当数据改变时| B(开始更新)
B --&gt;|调用 &lt;code&gt;beforeUpdate&lt;&#x2F;code&gt; 方法| C(更新中)
C --&gt;|调用 &lt;code&gt;updated&lt;&#x2F;code&gt; 方法| A
A --&gt;|当 &lt;code&gt;.$destroy&lt;&#x2F;code&gt; 方法被调用时| D[销毁流程]

</pre>

<table>
<thead>
<tr>
<th align="center">回调函数名</th>
<th align="center">调用时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>beforeUpdate()</code></td>
<td align="center">Vue监测到数据变化后，开始更新HTML之前</td>
</tr>
<tr>
<td align="center"><code>Updated()</code></td>
<td align="center">Vue更新HTML完成后</td>
</tr>
</tbody></table>
<h3 id="2-销毁流程"><a href="#2-销毁流程" class="headerlink" title="(2) 销毁流程"></a><strong>(2) 销毁流程</strong></h3><p>销毁阶段的流程图如下：</p>
<pre class="mermaid">
graph TD

A[更新流程] --&gt;|当 &lt;code&gt;.$destroy&lt;&#x2F;code&gt; 方法被调用时| B(开始销毁)
B --&gt;|调用 &lt;code&gt;beforeDestroy&lt;&#x2F;code&gt; 方法| C(销毁中)
C --&gt;|调用 &lt;code&gt;destroyed&lt;&#x2F;code&gt; 方法| D(完全销毁)

</pre>

<table>
<thead>
<tr>
<th align="center">回调函数名</th>
<th align="center">调用时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>beforeDestroy()</code></td>
<td align="center">Vue监测到数据变化后，开始更新HTML之前</td>
</tr>
<tr>
<td align="center"><code>destroyed()</code></td>
<td align="center">Vue更新HTML完成后</td>
</tr>
</tbody></table>
<p>当Vue实例调用<code>$destroy()</code>方法后，虽然实例不再接管HTML，但对HTML的修改会被保存。一旦调用<code>$destroy()</code>方法，开始销毁流程后，Vue将不再更新HTML。此外，用户应当在<code>beforeDestroy()</code>回调函数中销毁自定义的定时器等。</p>
<h2 id="五、组件化"><a href="#五、组件化" class="headerlink" title="五、组件化"></a><strong>五、组件化</strong></h2><p>组件化是Vue的特色，不能不品尝。组件化，即将网页分割为多个小块（例如页眉，页尾，侧边栏和主要内容等），然后分别对每一块进行涉及，最终将所有的组件拼接成一个网页。所有的这些组件都可以进行复用而无需复制粘贴代码。此外，每一个组件还能再次细分为更小的组件，每一个单独的组件含有自身特有的CSS、HTML和JavaScript。</p>
<h3 id="1-非单文件组件"><a href="#1-非单文件组件" class="headerlink" title="(1) 非单文件组件"></a><strong>(1) 非单文件组件</strong></h3><p>实际上就是嵌在HTML或者写在JavaScript文件内的Vue组件。这种组件不依赖Vue脚手架（或者叫Vue命令行）。上文讲解生命周期时已经提到了Vue实例对象中可以含有<code>template</code>属性，该属性即为模板，需要向其中写入Vue需要接管的元素内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- HTML 里没有 “item” 这个标签 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 它是用于指示Vue实例的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title class_">Config</span> = &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 指定 Vue 组件的模板</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 注意此处使用的是&quot;`&quot;，而不是单引号</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;div&gt;&lt;button&gt;&#123;&#123;test&#125;&#125;&lt;/button&gt;&lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">        `</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 组件形式的 Vue 必须使用函数式的 data</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">test</span>: <span class="string">&quot;114514&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建 Vue 组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 组件不能直接用，需要全局注册或者注册在 Vue 实例内</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title class_">Item</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">Config</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#root&quot;</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用 components 属性注册组件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 格式: &quot;名称:组件对象&quot;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 然后在 HTML 文件中以标签形式使用名称</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如 &lt;item&gt;&lt;/item&gt;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">item</span>: <span class="title class_">Item</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>为什么必须使用函数式的<code>data</code></strong></div>

<div style="color:goldenrod;">当在Vue组件中使用对象式的<code>data</code>时，Vue组件将直接报错。因为Vue组件可以接管多个HTML元素，但每一个被接管的HTML的数据应当是互不影响的（要想关联数据应当使用<code>methods</code>或者<code>computed</code>）。因此<code>data</code>应当被写成函数式，每当Vue组件接管一个新的HTML元素时，它会返回一个新的对象，使每个HTML元素的数据互不干扰。</div>
</div>

<p>执行效果如下：</p>
<p><img src="/2022/04/18/VueGrammar02/2.png" alt="2" title="2"></p>
<p>可以看到Vue实例将 <code>&lt;item&gt;&lt;/item&gt;</code> 标签替换为了组件中的模板。上述代码的注册方式使得组件只能在接管了 id&#x3D;”root” 的Vue实例中生效。如果要想全局注册Vue，即所有Vue实例均可使用该组件，应当使用 <code>Vue.component()</code> 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;item&quot;</span>, <span class="title class_">Item</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-组件的嵌套"><a href="#2-组件的嵌套" class="headerlink" title="(2) 组件的嵌套"></a><strong>(2) 组件的嵌套</strong></h3><p>Vue组件允许套娃。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 空的 div 标签，Vue 实例将会接管它 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Vue 组件的配置对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title class_">Inner</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;button&gt;&#123;&#123;test&#125;&#125;&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">        `</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">test</span>: <span class="string">&quot;114514&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在上方组件的外面再套一层组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title class_">Item</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;inner&gt;&lt;/inner&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;h1&gt;测试&lt;/h1&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">        `</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 注册组件时可以直接写该组件的配置对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// Vue 会自动调用 Vue.extend() 函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">inner</span>: <span class="title class_">Inner</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 新建 Vue 实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#root&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;item&gt;&lt;/item&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">        `</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">item</span>: <span class="title class_">Item</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<p><img src="/2022/04/18/VueGrammar02/3.png" alt="3" title="3"></p>
<p>当Vue实例有<code>template</code>属性时，将会用该属性内的HTML模板替换接管元素内的HTML。</p>
<h3 id="3-组件的本质"><a href="#3-组件的本质" class="headerlink" title="(3) 组件的本质"></a><strong>(3) 组件的本质</strong></h3><p><del>组件的本质是组件的本质。</del>组件的本质是构造函数。这一点可以很轻松地通过控制台来验证：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title class_">Item</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">`&lt;div&gt;&lt;/div&gt;`</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在控制台中尝试查看 <code>Item</code> ，将会看到如下输出：</p>
<p><img src="/2022/04/18/VueGrammar02/4.png" alt="4" title="4"></p>
<p>可以很明显地看到它是一个函数。每当该组件接管HTML时都会调用一次该构造函数，返回一个全新的Vue组件对象。 不同的组件虽然都是一个名为 <code>VueComponent()</code> 的构造函数，但它们之间是不一样的。其中的具体原理涉及到JavaScript的闭包，此处不做赘述。</p>
<p>此外， <code>VueComponent()</code> 函数的原型对象的原型对象是Vue构造函数的原型对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 随便创建一个 Vue 组件，但一定要注册并且使用它</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 否则 Vue 将不会创建它的实例对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> a = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">                &lt;button @click=&quot;test&quot;&gt;点击&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">            &lt;/div&gt;</span></span></span><br><span class="line"><span class="string"><span class="language-javascript">        `</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// Vue 组件的实例对象不好获取</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 但是可以通过按钮触发事件来打印 this 指针</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 从而获取 Vue 组件的实例对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建 Vue 实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#root&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">template</span>: <span class="string">`&lt;test&gt;&lt;/test&gt;`</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">test</span>: a</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击页面按钮后，控制台将会打印：</p>
<p><img src="/2022/04/18/VueGrammar02/5.png" alt="5"></p>
<h3 id="4-单文件组件"><a href="#4-单文件组件" class="headerlink" title="(4) 单文件组件"></a><strong>(4) 单文件组件</strong></h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a><strong>1. 初始化</strong></h4><p>从这一步开始就要踏上Vue CLI的不归路了。首先需要安装Vue CLI，即Vue命令行，也叫Vue脚手架。关于它的安装与创建工程此处不做赘述，详情请参考 <a class="btn" href="https://cli.vuejs.org/zh/guide/installation.html ">Vue CLI 官方文档</a> 。</p>
<p>运行如下命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">vue create hello</span></span><br></pre></td></tr></table></figure>

<p>该命令会在当前文件夹下创建一个名为 “hello” 的文件夹，并在其中部署好Vue工程。用户只需要切换到该文件夹下，执行如下命令：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm run serve</span></span><br></pre></td></tr></table></figure>

<p>即可预览工程编译后的状态。工程文件的目录结构应该是如下的状态：</p>
<p><img src="/2022/04/18/VueGrammar02/6.png" alt="6" title="6"></p>
<p>其中， <code>node_modules</code> 目录下存放Node.js的模组， <code>public</code> 目录下存放公共资源（通常是HTML文件）， <code>src</code> 目录下存放素材、 <code>.vue</code> 源代码文件和一个 <code>main.js</code> 文件。其余的文件都是配置信息文件。Vue脚手架甚至会贴心地帮你初始化好git。</p>
<p>因此目录结构应该如下：</p>
<pre class="mermaid">
graph LR

A[hello]&#x3D;&#x3D;&gt;B[node_modules]
B--&gt;F((Node.js 模组))
A&#x3D;&#x3D;&gt;C[public]
C--&gt;G((HTML 文件))
A&#x3D;&#x3D;&gt;D[src]
D&#x3D;&#x3D;&gt;H[assets]
H--&gt;I((网页素材))
D&#x3D;&#x3D;&gt;J[components]
J--&gt;K((Vue 组件))
D--&gt;L((&lt;code&gt;App.vue&lt;&#x2F;code&gt;))
D--&gt;M((&lt;code&gt;main.js&lt;&#x2F;code&gt;))
A--&gt;E((配置文件))

</pre>

<p>其中， <code>.vue</code> 文件的结构应该如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- template 标签内的内容会自动变为 Vue 对象的 template 属性值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 编写自定义的 HTML --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="comment">/* 组件名 */</span> <span class="keyword">from</span> <span class="comment">/* .vue文件的相对路径 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;该组件的组件名&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">/* 要注册的组件 */</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// ······</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// Vue 组件/实例 的剩余配置</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 不需要写入 template 属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// ······</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 用户自定义的样式 */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>main.js</code> 内，会有如下的初始代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>不需要对其做任何修改。用户只需要在 HTML 文件中确保 <code>&lt;body&gt;</code> 标签中存在如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即可。Vue脚手架会自动接管该元素。而 <code>App.vue</code> 文件则是囊括所有Vue组件的组件，只需要分别编写好各个组件并最终让 <code>App.vue</code> 引用即可。</p>
<h4 id="2-ref"><a href="#2-ref" class="headerlink" title="2. ref"></a><strong>2. <code>ref</code></strong></h4><p><code>ref</code> 属性是Vue脚手架里特有的属性。在编译完后该属性将不会出现在HTML中。它的使用方法与性质与HTML元素的<code>id</code>很像：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当Vue解析到<code>ref</code>属性时，Vue会自动解析它所在的元素，并将该元素绑定到Vue实例对象的 <code>$refs.test</code> 属性上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;click&quot;</span>&gt;</span>自定义的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">click</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 尝试打印它</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">button</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>npm run serve</code> 命令，点击网页上的按钮，会看到如下输出：</p>
<p><img src="/2022/04/18/VueGrammar02/7.png" alt="7" title="7"></p>
<p>可以看见确确实实地获得了 <code>&lt;button&gt;</code> 元素。这很大程度上意味着，使用Vue脚手架后可以不再需要jQuery。</p>
<div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>请不要使用 <code>id</code> 来查找子组件！</strong></div>

<div style="color:darkred;">在Vue组件中，子组件能够以标签的形式插入 <code>&lt;template&gt;</code> 标签中并生效。如果为子组件的标签设置了<code>id</code>属性，那么该属性则会被转移到子组件的包裹元素上。如果使用<code>ref</code>属性，则会将子组件绑定到 <code>$refs</code> 属性下。</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;click()&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="title class_">MainStruct</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Main.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title class_">MainStruct</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">click</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">            &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 查看通过 id 查找到的对象</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;id:&quot;</span>,<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#test&quot;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 查看通过 $refs 查找到的对象</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">test</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">variable0</span>:<span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">variable1</span>:<span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;测试&quot;</span>:<span class="number">3</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:darkred;">控制台将会输出：</div>

<p><img src="/2022/04/18/VueGrammar02/8.png" alt="8" title="8"></p>
<div style="color:darkred;">确切地说，绑定在 <code>$refs</code> 属性下的对象是Vue组件的实例对象。</div>
</div>

<h4 id="3-props"><a href="#3-props" class="headerlink" title="3. props"></a><strong>3. <code>props</code></strong></h4><p>组件化的优势在于复用，而复用一般是布局样式、交互行为复用，较少有连数据也一起复用的。而直接将数据初始化在子组件的 <code>data</code> 方法内，则不便修改。因此，Vue组件的配置对象允许一个名为 <code>props</code> 的属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>型号：&#123;&#123;Type&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>名称：&#123;&#123;Name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">props</span>:[<span class="string">&#x27;Type&#x27;</span>,<span class="string">&#x27;Name&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码表明，在以标签形式使用该组件时，需要以元素属性的形式为其表明 <code>Type</code> 与 <code>Name</code> 的值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HIE<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 以元素属性的形式传入参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">Name</span>=<span class="string">&quot;Kouka&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;Type-001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">Name</span>=<span class="string">&quot;Method&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;Type-004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">Name</span>=<span class="string">&quot;Lacia&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;Type-005&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并且这些自定义的 “元素属性” 可以被Vue的指令语法绑定，即使用 <code>v-bind</code> 或者<code>v-model</code>来绑定，从而达到随时修改其值的效果。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>利用<code>v-bind</code>传入 <code>Number</code>型变量</strong></div>

<div style="color:royalblue;">有时用户不需要动态修改数据，但又想传入一个固定的数值，却发现通过 “元素属性” 的形式传入的参数都会被解析为 <code>String</code> 类型。此处可以借助 <code>v-bind</code> 指令来传入。</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">Name</span>=<span class="string">&quot;Kouka&quot;</span> <span class="attr">:Type</span>=<span class="string">&quot;17&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;"><code>v-bind</code> 指令会先计算其内的表达式的值，将计算结果作为值。而纯数字的结果就是 <code>Number</code> 型变量。</div>
</div>

<p>若要想指定传入的变量的类型，就不应当使用数组类型的 <code>props</code> 属性，而应当以对象的形式定义它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;MainStruct&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定类型的方式</span></span><br><span class="line">        <span class="comment">// 变量名 : 类型</span></span><br><span class="line">        <span class="title class_">Type</span>:<span class="title class_">Number</span>,</span><br><span class="line">        <span class="title class_">Name</span>:<span class="title class_">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议使用对象形式的<code>props</code>属性。对象形式的<code>props</code>属性还能定义得更详细：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;MainStruct&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定名为 Type 的变量</span></span><br><span class="line">        <span class="title class_">Type</span>:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定类型为 Number</span></span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 默认值为1</span></span><br><span class="line">            <span class="comment">// 设置这个选项意味着可以不传入这个参数</span></span><br><span class="line">            <span class="attr">default</span>:<span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title class_">Name</span>:&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定类型为 String</span></span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">String</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置这个选项意味着必须传入该变量</span></span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般推荐至少要限制传入变量的类型，因为JavaScript默认的隐式类型转换会造成令人困惑的错误，尤其是当你的代码多到自己看着都头晕的时候。</p>
<h4 id="4-lt-style-gt"><a href="#4-lt-style-gt" class="headerlink" title="4. &lt;style&gt;"></a><strong>4. <code>&lt;style&gt;</code></strong></h4><p>Vue内 <code>&lt;style&gt;</code> 标签允许接受一个 <code>lang</code> 属性。可以通过它来标记你所使用的样式语言（不写则默认为CSS），例如SCSS、LESS等，但需要安装插件，此处不做详述。</p>
<p>另外， <code>&lt;style&gt;</code> 标签还可以接受一个没有值的属性—— <code>scoped</code> 属性。添加了这个属性以后，该样式就只会应用于该 <code>.vue</code> 文件中的HTML元素，不加则会全局生效。<span style="color:red;">请注意， <code>.vue</code> 文件中允许存在多个 <code>&lt;style&gt;</code> 标签，并且它们将同时生效。</span></p>
<h3 id="5-自定义事件"><a href="#5-自定义事件" class="headerlink" title="(5) 自定义事件"></a><strong>(5) 自定义事件</strong></h3><p>Vue组件允许自定义事件。自定义的事件不能应用于HTML，只能用于Vue组件的实例对象。</p>
<h4 id="1-v-on式"><a href="#1-v-on式" class="headerlink" title="1. v-on式"></a><strong>1. <code>v-on</code>式</strong></h4><p>使用<code>v-on</code>式的自定义事件，与使用一般的事件没有什么太大区别：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 给子组件的实例对象绑定 receive 事件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 并且指定该事件触发时调用 Receiver 函数 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">MainStruct</span> @<span class="attr">receive</span>=<span class="string">&quot;Receiver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码为<code>MainStruct</code>组件的实例对象绑定了一个名为<code>receive</code>的事件。要触发该事件，需要在<code>MainStruct</code>组件中添加如下语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;MainStruct&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">test</span>(<span class="params"></span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 触发名为 &quot;receive&quot; 的事件，并传参</span></span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&quot;receive&quot;</span>,&#123;<span class="string">&quot;1&quot;</span>:<span class="number">114514</span>,<span class="string">&quot;8&quot;</span>:<span class="number">1919810</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$emit()</code> 方法是定义在Vue组件实例下的方法，该方法类似于jQuery的<code>trigger()</code>方法，会触发与指定事件名一致的事件。区别在于前者用于触发绑定在子组件上的自定义事件，后者是触发JavaScript内置的事件。</p>
<h4 id="2-on"><a href="#2-on" class="headerlink" title="2. $on"></a><strong>2. <code>$on</code></strong></h4><div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>已过时！</strong></div>

<div style="color:darkred;">Vue 3.0版本移除了<code>$on</code>方法，它不再适用。替代方案网络上已经不胜枚举，此处不做赘述。</div>
</div>

<p>首先需要获取到子组件的实例对象：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">ref</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在父组件中定义挂载完成时的回调函数，即 <code>mounted()</code> 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">main</span>.$on(<span class="string">&quot;receive&quot;</span>, <span class="variable language_">this</span>.<span class="property">Receiver</span>);</span><br></pre></td></tr></table></figure>

<p>该方法就将名为 “receive” 的事件绑定到了指定的组件上。触发事件的方式与 <code>v-on</code> 式自定义事件一样。</p>
<h3 id="6-全局事件总线"><a href="#6-全局事件总线" class="headerlink" title="(6) 全局事件总线"></a><strong>(6) 全局事件总线</strong></h3><div class="note danger"><div style="color:darkred;font-size:1.5em;"><strong>已过时！</strong></div>

<div style="color:darkred;">由于Vue 3.0版本移除了<code>$on</code>方法，使得全局事件总线已经难以实现。如果一定要实现全局事件总线，请使用第三方库。</div>
</div>

<p>Vue本身并不提供任意组件实例间通信的功能，但可以利用自定义事件来做到类似的功能。自定义事件可以把某个组件实例内定义的函数交给另一个组件实例，并通过 <code>$emit()</code> 方法触发该组件实例的事件，从而达到通过传入事件参数的方法实现组件间通信。</p>
<p>上述方法要想实现任意的组件实例都能实现通信，需要一个全局的公开的 “工具人” 组件实例。需要接收数据的组件实例将事件交给 “工具人” ，需要发送数据的组件实例通过 <code>$emit()</code> 方法触发 “工具人” 的事件来发送数据。上文已经阐述了，Vue组件实例的原型对象的原型对象是Vue构造函数的原型对象，因此这个工具人需要定义在 <code>Vue.prototype</code> 下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为什么是 beforeCreate() ？</span></span><br><span class="line">    <span class="comment">// 因为这个时候还没开始解析HTML，也没开始读取配置对象，此时绑定不会引发报错</span></span><br><span class="line">    <span class="title function_">beforeCreate</span>(<span class="params"></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将当前Vue实例对象绑定到Vue构造函数的原型上</span></span><br><span class="line">        <span class="comment">// 之后使用 $on 方法绑定事件时，全都绑定到 this.DataCenter 上</span></span><br><span class="line">        <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">DataCenter</span> = <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当绑定了事件之后，一定要记得在绑定事件的组件里写上它销毁前要解绑所用到的事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ······</span></span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="comment">// ······</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">DataCenter</span>.$off([ <span class="comment">/* 绑定的所有事件名称 */</span> ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ······</span></span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="comment">// ······</span></span><br></pre></td></tr></table></figure>

<h3 id="7-消息订阅与发布"><a href="#7-消息订阅与发布" class="headerlink" title="(7) 消息订阅与发布"></a><strong>(7) 消息订阅与发布</strong></h3><p>Vue并没有自带的消息订阅与发布的功能。一般是使用第三方库来实现这个功能。消息订阅功能大致是：任意组件实例都可以订阅多份消息；不同的组件实例可以订阅同一份消息，且都可以执行接受到消息后的函数；任意组件实例都可以发布消息。</p>
<p>我自己写了一个简陋的消息订阅与发布模块，以实现全局任意组件实例间通讯：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于存储消息订阅数据的对象</span></span><br><span class="line"><span class="comment">// 不会对外暴露</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Database</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露的对象，它负责处理订阅与发布</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">HQ</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        该方法用于订阅消息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            MessageName：要订阅的消息名称， String 类型。</span></span><br><span class="line"><span class="comment">            CallBack： 接收到新消息后要执行的回调函数， function 类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            唯一确定此订阅消息数据的ID。</span></span><br><span class="line"><span class="comment">            取消订阅时会用到。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title class_">Follow</span>(<span class="title class_">MessageName</span>, <span class="title class_">CallBack</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Register</span> = &#123;</span><br><span class="line">            <span class="attr">ID</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">            <span class="title class_">Executer</span>: <span class="title class_">CallBack</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">MessageName</span> <span class="keyword">in</span> <span class="title class_">Database</span>)</span><br><span class="line">            <span class="title class_">Database</span>[<span class="title class_">MessageName</span>].<span class="title function_">push</span>(<span class="title class_">Register</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="title class_">Database</span>[<span class="title class_">MessageName</span>] = [<span class="title class_">Register</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Register</span>.<span class="property">ID</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        该方法用于取消订阅消息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            MessageName：要取消订阅的消息名称， String 类型。</span></span><br><span class="line"><span class="comment">            ID：要取消订阅消息的ID。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title class_">Unfollow</span>(<span class="title class_">MessageName</span>, <span class="variable constant_">ID</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">MessageName</span> <span class="keyword">in</span> <span class="title class_">Database</span>)</span><br><span class="line">            <span class="title class_">Database</span>[<span class="title class_">MessageName</span>] = <span class="title class_">Database</span>[<span class="title class_">MessageName</span>].<span class="title function_">filter</span>(<span class="function">(<span class="params">Element</span>) =&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Element</span>[<span class="string">&quot;ID&quot;</span>] === <span class="variable constant_">ID</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        该方法用于发布消息。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            MessageName：要发布的消息名称， String 类型。</span></span><br><span class="line"><span class="comment">            Message：要发布的消息。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title class_">Post</span>(<span class="title class_">MessageName</span>, <span class="title class_">Message</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">MessageName</span> <span class="keyword">in</span> <span class="title class_">Database</span>)</span><br><span class="line">            <span class="title class_">Database</span>[<span class="title class_">MessageName</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">Element</span>) =&gt;</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title class_">Element</span>.<span class="title class_">Executer</span>(<span class="title class_">Message</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="variable constant_">HQ</span>;</span><br></pre></td></tr></table></figure>

<p>毕竟是自己写的东西，方方面面都不如更加专业的开发者们编写的模块。常用的模块是 <code>pubsub.js</code> 模块。</p>
<h3 id="8-动画与过渡"><a href="#8-动画与过渡" class="headerlink" title="(8) 动画与过渡"></a><strong>(8) 动画与过渡</strong></h3><p>使用Vue框架搭配CSS动画时，可以把某一个动画效果绑定到一个类名上，然后通过Vue的<code>v-bind</code>来控制HTML元素的类名，从而达到动画的播放与切换效果。但Vue为用户提供了更加方便的途径—— <code>&lt;transition&gt;</code>标签。</p>
<p>位于<code>&lt;transition&gt;</code>标签内的元素，在其<code>v-show</code>属性值为<code>false</code>时，Vue会自动为其切换<code>v-leave-active</code>类名；而为<code>true</code>时，则会切换为<code>v-enter-active</code>类名（其他类名不受影响）。但采用这种方式意味着必须在CSS中为Vue规定的类名编写动画样式。</p>
<p>与其他的HTML自带的标签类似，Vue特有的<code>&lt;transition&gt;</code>标签也存在属性：</p>
<ul>
<li>当设置了<code>name</code>属性时，需要在CSS中将<code>v-leave-active</code>等类名替换为<code>name属性值-leave-active</code> 。</li>
<li>当存在<code>appear</code>属性时（不需要属性值），该标签内的元素将在HTML首次加载完成时执行进入动画。</li>
</ul>
<p>Vue的这种设计使得其本身并不与CSS动画直接交互，因此Vue对于第三方动画库的支持效果很不错。推荐使用<code>Animate.css</code>第三方CSS动画库。</p>
<p><code>&lt;transition&gt;</code>标签还会自动为其内的元素附加<code>v-enter</code> 、 <code>v-enter-to</code> 和 <code>v-leave</code> 、 <code>v-leave-to</code> 标签。这些标签表明了元素的起始位置与结束位置，配合元素其自身CSS的<code>transition</code>属性，以达到过渡的效果。</p>
<p>如果要想自定义动画样式的类名，请在<code>&lt;transition&gt;</code>标签中添加<code>enter-active-class</code>属性和<code>leave-active-class</code>属性。这个属性使得使用第三方CSS动画库变得非常容易。</p>
<p><span style="color:red;">请注意， <code>&lt;transition&gt;</code>标签内只能有一个元素。若要插入多个元素，请使用<code>&lt;transition-group&gt;</code>标签，并且其中每一个元素都必须拥有一个唯一的<code>key</code>属性值。</span></p>
<h2 id="六、杂项"><a href="#六、杂项" class="headerlink" title="六、杂项"></a><strong>六、杂项</strong></h2><p>这一节是讲述一些Vue Web开发中常用的知识。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>什么是异步交互</strong></div>

<div style="color:royalblue;">此博客使用Next主题提供的pjax第三方插件来实现异步，首先在此感谢Next主题与pjax的开发者。不知读者有没有注意到，当你点击此博客的任意一篇文章时，左侧的音乐播放器不会中断或重新开始播放，并且更新的内容只有主体部分，侧边栏没有重新加载。这就是异步交互，即不重新加载页面，而是只更新页面中需要被更新的部分。</div>
</div>

<h3 id="1-本地存储"><a href="#1-本地存储" class="headerlink" title="(1) 本地存储"></a><strong>(1) 本地存储</strong></h3><p>此博客会记录读者的阅读记录，即关闭浏览器后，再次用同样的浏览器打开这个网页，点击同一篇文章，会直接跳转到上一次阅读的位置。不要担心，此网站并没有任何收集用户数据的行为。<del>托管在Github &#x2F; Gitee上的静态网页怎么收集数据啊（绝望）</del>实现这个功能其实非常简单——读者的阅读记录全都存在了读者自己的浏览器上。这就是本地存储。</p>
<p><img src="/2022/04/18/VueGrammar02/9.png" alt="9" title="9"></p>
<p>打开控制台，切换到 “应用程序” 一栏，可以看到一个名为 “本地存储” 的选项。此处的网址是 <code>localhost:8080</code> ，是因为该网站是我在撰写本文时开设的用于即时查看网页效果的本地服务器。右侧可以看到记录了键值对（原文应该是<code>key</code>和<code>value</code> ，被微软机翻成了 “密钥” 和 “值” ）。键就是相对地址，值就是滚动条的进度，此博客就是通过读取存储于本地的这些数据来实现书签功能。这是Next主题实现的功能，感谢Next主题的开发者。</p>
<p>那么怎么使用这个本地存储呢？使用<code>window</code>对象下的<code>localStorage</code>对象即可。</p>
<p><code>localStorage</code>对象中定义了如下方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">参数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>setItem()</code></td>
<td align="center"><code>String</code> ， <code>String</code></td>
<td align="center">添加键值对，第一个字符串是键，第二个字符串是值</td>
</tr>
<tr>
<td align="center"><code>getItem()</code></td>
<td align="center"><code>String</code></td>
<td align="center">根据传入的键返回值，没有此键则返回 <code>null</code></td>
</tr>
<tr>
<td align="center"><code>removeItem()</code></td>
<td align="center"><code>String</code></td>
<td align="center">根据传入的键，删除键值对</td>
</tr>
<tr>
<td align="center"><code>clear()</code></td>
<td align="center">无</td>
<td align="center">清空本地存储</td>
</tr>
</tbody></table>
<p>请注意，本地存储只能存储 <code>String</code> 类型的数据，此外的数据不能存储。要想存储对象？请使用 <code>JSON.stringify()</code> 方法，读取时使用 <code>JSON.parse()</code> 方法。前者会将对象转换为字符串，后者则是将字符串分割成为对象。</p>
<h3 id="2-会话存储"><a href="#2-会话存储" class="headerlink" title="(2) 会话存储"></a><strong>(2) 会话存储</strong></h3><p>会话存储与本地存储基本类似，只不过会话存储会在关闭网页时被清空，而本地存储会被保留。要想使用会话存储，使用<code>window</code>对象下的<code>sessionStorage</code>对象即可。该对象下的方法与<code>localStorage</code>对象一致，此处不做赘述。</p>
<h3 id="3-nextTick"><a href="#3-nextTick" class="headerlink" title="(3) $nextTick()"></a><strong>(3) <code>$nextTick()</code></strong></h3><p><code>$nextTick()</code> 方法是Vue定义在Vue组件实例下的方法。它接受一个回调函数作为参数。当 <code>this.$nextTick()</code> 语句所在的函数被执行时，作为参数的回调函数将在该函数执行完、Vue重新渲染模板完成后再被调用。即：该方法是同步的。</p>
<p>该函数常常用于实现Vue重新渲染完模板以后自动获取焦点等功能。Vue重新渲染模板一般是等到事件触发结束以后再一次性重新渲染，因此在事件回调函数内编写自动获取焦点的代码有可能不会生效，此时就需要同步等待Vue渲染模板结束。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>JavaScript库</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础（三）</title>
    <url>/2022/04/23/VueGrammar03/</url>
    <content><![CDATA[<img src="/2022/04/23/VueGrammar03/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有HTML和JavaScript基础，并且最好学过CSS。</div>
</div>

<span id="more"></span>

<h2 id="七、插槽"><a href="#七、插槽" class="headerlink" title="七、插槽"></a><strong>七、插槽</strong></h2><p>Vue 中组件的标签有两种写法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MainStruct</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二种 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MainStruct</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一种是自结束标签，第二种就是一般的标签。Vue 专门保留了两种写法，说明这两种写法都有其自己的作用。前者就是一般的组件标签，而后者有额外的功能——插槽。</p>
<p>Vue 的插槽功能允许向组件标签的内部再追加内容，并且浏览网页时能在子组件中显示。插槽一般用于有多个同类的子组件实例，但每个实例中的显示内容又不一致的情况。</p>
<h3 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="(1) 默认插槽"></a><strong>(1) 默认插槽</strong></h3><p>使用默认插槽很简单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用组件，并向其中添加 HTML 元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;slot&gt; 标签标记了被插入的信息应当存在的位置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 即定义了一个插槽 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>网页展示效果应该如下：</p>
<p><img src="/2022/04/23/VueGrammar03/1.png" alt="1" title="1"></p>
<p>在<code>&lt;slot&gt;</code>标签中允许存在 HTML 结构（即纯文本和标签都可以），但这些 HTML 结构只有插槽没有被使用的时候才会展示。</p>
<h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="(2) 具名插槽"></a><strong>(2) 具名插槽</strong></h3><p>Vue 允许存在多个<code>&lt;slot&gt;</code>标签，即允许使用多个插槽。但当不加任何修饰时，每一个插槽都会显示父组件传递的 HTML 结构。因此需要对插槽进行一些 “修饰” 。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;template&gt; 标签允许套娃，且 v-slot 属性只能应用在 &lt;template&gt; 标签上 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 将会装入名为 Lacia 的插槽中 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:Lacia</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Type-005<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 会装入与上方的 &lt;template&gt; 标签不同的插槽 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 将会装入名为 Kouka 的插槽中 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:Kouka</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Type-001<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置两个带 name 属性的插槽 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;Lacia&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;Kouka&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在网页中的展示结果为：</p>
<p><img src="/2022/04/23/VueGrammar03/2.png" alt="2" title="2"></p>
<h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="(3) 作用域插槽"></a><strong>(3) 作用域插槽</strong></h3><p>使用插槽时，可以把子组件的数据传递给父组件中的插槽。在子组件中，为<code>&lt;slot&gt;</code>标签绑定属性即可在父组件中接收到该属性值。这需要用到<code>v-slot</code>属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 标注该 &lt;template&gt; 标签应当插入名为 Lacia 的插槽中 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 并且接受从该插槽来的所有数据，将其命名为 Data --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:Lacia</span>=<span class="string">&quot;Data&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 尝试展示接收到的数据 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; Data &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Type-005<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:Kouka</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Type-001<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 向使用该插槽的组件传入参数 a 和 b --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:a</span>=<span class="string">&quot;a&quot;</span> <span class="attr">:b</span>=<span class="string">&quot;b&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Lacia&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;Kouka&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 定义数据 a 和 b</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">a</span>: <span class="number">114514</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">b</span>: <span class="number">1919810</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码在网页中的效果为：</p>
<p><img src="/2022/04/23/VueGrammar03/3.png" alt="3" title="3"></p>
<p>即：要想使用来自子组件的数据，使用<code>Data.a</code>即可。</p>
<h2 id="八、组合式-API"><a href="#八、组合式-API" class="headerlink" title="八、组合式 API"></a><strong>八、组合式 API</strong></h2><p>组合式 API 是 Vue 3.0 新提出来的东西，因此 Vue 2.0 是不适用的。</p>
<h3 id="1-emits"><a href="#1-emits" class="headerlink" title="(1) emits"></a><strong>(1) <code>emits</code></strong></h3><p><code>emits</code>是 Vue 3.0 新追加的一个应当被定义在 Vue 组件的配置对象中的属性。该属性用于接收来自父组件传递给子组件的自定义事件。如果没有使用<code>emits</code>属性 “注册” 自定义事件，那么自定义事件就将对子组件不可用。</p>
<p><code>emits</code>属性应当是一个数组，其存储的值是<code>String</code>类型，标记要 “注册” 的自定义事件的名称。</p>
<h3 id="2-setup"><a href="#2-setup" class="headerlink" title="(2) setup()"></a><strong>(2) <code>setup()</code></strong></h3><p>之前所写的<code>data()</code>、<code>methods</code>等，其实都是不规范的（但仍能使用）。在 Vue 3.0 中，数据、方法、计算属性、生命周期钩子、监视属性等全都应该写在<code>setup</code>属性中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// setup属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> <span class="title class_">Name</span> = <span class="string">&quot;Lacia&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> <span class="title class_">Type</span> = <span class="string">&quot;Type-005&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">SelfIntroduction</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">`I&#x27;m <span class="subst">$&#123;Name&#125;</span>,<span class="subst">$&#123;Type&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 只有被返回了的属性才能在HTML模板中被使用</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; <span class="title class_">Name</span>, <span class="title class_">Type</span>, <span class="title class_">SelfIntroduction</span> &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>setup()</code>属性应该有一个返回值，这个返回值是对象，它的属性在 HTML 模板中可以直接使用，而没有返回的数据则无法直接使用，但可以通过闭包使用。但请注意，上述写法无法做到响应式。</p>
<p>另外，<code>setup()</code>函数执行的时机是在<code>beforeCreate()</code>回调函数执行<span style="color:red;">之前</span>，并且只会执行一次。<code>setup()</code>函数会在执行时接收到两个参数，第一个参数是使用<code>props</code>属性接收到的、从父组件传递过来的参数的对象的代理对象（关于什么是代理对象，下文将详述）；第二个参数则是一个上下文对象。该对象含有一个<code>emit()</code>方法，用于触发自定义事件。关于这个对象此处不做过多赘述，详情请参见 <a class="btn" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html#context ">Vue 3 官方文档</a> 。</p>
<h3 id="3-ref"><a href="#3-ref" class="headerlink" title="(3) ref()"></a><strong>(3) <code>ref()</code></strong></h3><p>这个<code>ref()</code>与之前提到的与 HTML 元素的<code>id</code>属性类似的<code>ref</code>属性不同。当然<code>ref</code>属性并没有被删除，这里讲的是一个在 Vue 组件配置对象中的<code>ref()</code>函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 引入 ref() 函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 通过 ref() 来定义数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> <span class="title class_">Name</span> = <span class="title function_">ref</span>(<span class="string">&quot;Lacia&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> <span class="title class_">Type</span> = <span class="title function_">ref</span>(<span class="string">&quot;Type-005&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">SelfIntroduction</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 修改与打印值的时候，应当修改 value 属性</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Name</span>.<span class="property">value</span> = <span class="string">&quot;Kouka&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">`I&#x27;m <span class="subst">$&#123;Name.value&#125;</span>,<span class="subst">$&#123;Type.value&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; <span class="title class_">Name</span>, <span class="title class_">Type</span>, <span class="title class_">SelfIntroduction</span> &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>经过<code>ref()</code>函数加工的数据可以实现响应式，但修改其值的时候不能直接修改变量，而是应该修改这个变量的<code>value</code>属性，因为<code>ref()</code>函数返回的是一个对象，该对象是引用实现的实例（简称引用对象）。它的底层实现原理依旧与数据代理一致。</p>
<p>在 HTML 模板中使用<code>ref()</code>函数加工过的数据时，不需要加<code>value</code>属性，Vue 会自动帮你解析。</p>
<p>对于对象类型的数据，则不需要<code>ref()</code>函数套娃也能做到响应式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不需要添加 value 属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; Lacia.Name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; Lacia.Age &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 引入 ref() 函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 通过 ref() 函数绑定一个对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> <span class="title class_">Lacia</span> = <span class="title function_">ref</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Age</span>: <span class="number">17</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 修改对象中的数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Lacia</span>.<span class="property">value</span>.<span class="property">Name</span> = <span class="string">&quot;Kouka&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Lacia</span>.<span class="property">value</span>.<span class="property">Age</span> = <span class="number">14</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 查看数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Lacia</span>.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; <span class="title class_">Lacia</span>, test &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击网页中的按钮，控制台将会打印：</p>
<p><img src="/2022/04/23/VueGrammar03/4.png" alt="4" title="4"></p>
<p>可以看到这并不是上文定义的那个对象，而是一个陌生的东西—— <code>Proxy</code> 。它是通过 Vue 3.0 中的<code>reactive()</code>函数定义的，该函数可以认为是<code>defineProperty()</code>函数的升级版。</p>
<h3 id="4-reactive"><a href="#4-reactive" class="headerlink" title="(4) reactive()"></a><strong>(4) <code>reactive()</code></strong></h3><p>相比起<code>ref()</code>函数，通过<code>reactive()</code>函数绑定的对象更加啊便于使用，但<code>reactive()</code>函数不能绑定基本类型的数据，只能绑定对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 引入 ref() 和 reactive() 函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 使用 ref() 函数绑定</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> <span class="title class_">Lacia</span> = <span class="title function_">ref</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Name</span>: <span class="string">&quot;Lacia&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Age</span>: <span class="number">17</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 使用 reactive() 函数绑定</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> <span class="title class_">Method</span> = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Name</span>: <span class="string">&quot;Method&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Age</span>: <span class="number">19</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 修改前者需要使用 value 属性，而后者不需要</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Lacia</span>.<span class="property">value</span>.<span class="property">Age</span> = <span class="number">14</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="title class_">Method</span>.<span class="property">Age</span> = <span class="number">24</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; <span class="title class_">Lacia</span>, test, <span class="title class_">Method</span> &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实<code>ref()</code>函数的底层也是调用了<code>reactive()</code>函数来绑定对象数据。<code>reactive()</code>函数可以实现更轻量级的深度监视，即不管对象套娃套了多少层，它都可以做到监视。它也可以用于绑定数组。</p>
<h3 id="5-Proxy的原理"><a href="#5-Proxy的原理" class="headerlink" title="(5) Proxy的原理"></a><strong>(5) <code>Proxy</code>的原理</strong></h3><p>Vue 3.0 的响应式原理就是基于<code>Proxy</code>的，因此有必要了解<code>Proxy</code>的底层原理。</p>
<p><code>Proxy()</code>是定义在<code>window</code>对象下的一个构造函数，因此可以直接在前端代码中使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个需要被代理的对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Target</span> = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">114514</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 2.0 的代理方式</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">V2</span> = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable constant_">V2</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="comment">// 侦测到数据被读取</span></span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Target</span>.<span class="property">a</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">Value</span>) &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="comment">// 侦测到数据被修改，重新渲染 HTML 模板</span></span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="title class_">Target</span>.<span class="property">a</span> = <span class="number">114514</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue 3.0 的代理方式</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">V3</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">Target</span>, &#123;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 设置配置对象</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>相比起 Vue 2.0，Vue 3.0 的代理更加简洁明了且不需要耗费繁琐的精力去遍历一个对象下可能含有的对象。</p>
<p><code>Proxy()</code>构造函数的第一个参数就是需要代理的对象，第二个参数则是关于这个对象的一些设置。其中可以设置<code>get()</code>和<code>set()</code>等方法。</p>
<div class="tabs" id="proxymethod"><ul class="nav-tabs"><li class="tab active"><a href="#proxymethod-1"><code>get()</code></a></li><li class="tab"><a href="#proxymethod-2"><code>set()</code></a></li><li class="tab"><a href="#proxymethod-3"><code>deleteProperty()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="proxymethod-1"><p>当需要读取被代理的对象的值时，就会调用<code>get()</code>函数。</p>
<p>它会接收到两个参数：被代理的对象本身和需要读取的属性名。同<code>defineProperty()</code>函数中需要设置的<code>get()</code>函数一样，这个<code>get()</code>函数也需要返回值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 需要被代理的对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title class_">Target</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">a</span>: <span class="number">114514</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">b</span>: <span class="string">&quot;1919810&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 配置代理</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable constant_">V3</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">Target</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">get</span>(<span class="params">Target, Property</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 尝试打印参数到底是什么</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Target =&quot;</span>, <span class="title class_">Target</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Property =&quot;</span>, <span class="title class_">Property</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="string">&quot;测试&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器的控制台中，分别尝试读取<code>a</code>和<code>b</code> ，结果如下：</p>
<p><img src="/2022/04/23/VueGrammar03/5.png" alt="5" title="5"></p>
<p>可以看出，<code>get()</code>函数的返回值就是读取代理对象的属性时的返回值。因此相对合理的读取方式应当是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="title class_">Target</span>, <span class="title class_">Property</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">// 侦测到了读取</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Target</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="proxymethod-2"><p><code>set()</code>函数将会在修改属性与<span style="color:red;">新增属性</span>时被调用。</p>
<p><code>set()</code>函数会多接收到一个参数，那就是该属性需要被修改为什么值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">V3</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">Target</span>, &#123;</span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="comment">//省略 get()</span></span><br><span class="line">    <span class="comment">// ······</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">Target, Property, Value</span>) &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="comment">// 侦测到修改数据</span></span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="title class_">Target</span>[<span class="title class_">Property</span>] = <span class="title class_">Value</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="proxymethod-3"><p>该函数在删除代理对象的属性时将会被调用。</p>
<p><code>deleteProperty()</code>函数的参数与<code>get()</code>函数一致。该函数的返回值应当是一个<code>boolean</code>类型的值，表示删除属性是否成功。<span style="color:red;">请一定要记住在该函数内<code>delete</code>相应的属性，因为当该函数被程序员定义后，将不会默认删除原属性。</span></p></div></div></div>

<h3 id="6-Reflect"><a href="#6-Reflect" class="headerlink" title="(6) Reflect"></a><strong>(6) <code>Reflect</code></strong></h3><p>深入了解过 C#或者 Java 的同学应该已经学过反射了。</p>
<p><code>Reflect</code>是一个定义在<code>window</code>对象下的对象，它与 “静态”的 <code>Object</code>对象有点相似（因为 JavaScript 标准的设计者们在尝试把一些<code>Object</code> 对象下的方法转移到<code>Reflect</code>对象下）。</p>
<p><code>Reflect</code>对象下常见的方法有：</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">参数</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>get()</code></td>
<td align="center">对象，属性名</td>
<td align="center">获得该对象的指定属性值</td>
<td align="center">该对象的指定属性值</td>
</tr>
<tr>
<td align="center"><code>set()</code></td>
<td align="center">对象，属性名，值</td>
<td align="center">将该对象的属性的值修改为指定值</td>
<td align="center"><code>boolean</code> ，指示操作是否成功</td>
</tr>
<tr>
<td align="center"><code>defineProperty()</code></td>
<td align="center">对象，属性名，配置对象</td>
<td align="center">设数据置代理</td>
<td align="center"><code>boolean</code> ，指示操作是否成功</td>
</tr>
<tr>
<td align="center"><code>deleteProperty()</code></td>
<td align="center">对象，属性名</td>
<td align="center">删除该对象的指定属性</td>
<td align="center"><code>boolean</code> ，指示操作是否成功</td>
</tr>
</tbody></table>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><code>Reflect.defineProperty()</code>与<code>Object.defineProperty()</code>的区别</strong></div>

<div style="color:royalblue;">前者在重复定义属性时不会引发报错，只会返回<code>false</code>来指示修改不成功；而后者将会直接抛出异常，中断程序运行。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象和一个用于接收返回值的对象</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Ref</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Result</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用 Reflect.defineProperty() 重复定义属性</span></span><br><span class="line"><span class="title class_">Result</span> = <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Ref</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1. Result =&quot;</span>, <span class="title class_">Result</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Result</span> = <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Ref</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;2. Result =&quot;</span>, <span class="title class_">Result</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 Ref 对象</span></span><br><span class="line"><span class="title class_">Ref</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用 Object.defineProperty() 重复定义属性</span></span><br><span class="line"><span class="title class_">Result</span> = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Ref</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3. Result =&quot;</span>, <span class="title class_">Result</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Result</span> = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Ref</span>, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1. Result =&quot;</span>, <span class="title class_">Result</span>);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">上述代码的输出结果为：</div>

<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">node Hello.js</span></span><br><span class="line">1. Result = true</span><br><span class="line">2. Result = false</span><br><span class="line">3. Result = &#123;&#125;</span><br><span class="line">evalmachine.&lt;anonymous&gt;:10</span><br><span class="line">Result =Object.defineProperty(Ref, &#x27;a&#x27;, &#123;</span><br><span class="line">               ^</span><br><span class="line"></span><br><span class="line">TypeError: Cannot redefine property: a</span><br><span class="line">    at Function.defineProperty (&lt;anonymous&gt;)</span><br><span class="line">    at evalmachine.&lt;anonymous&gt;:10:16</span><br><span class="line">    at Script.runInThisContext (node:vm:129:12)</span><br><span class="line">    at Object.runInThisContext (node:vm:305:38)</span><br><span class="line">    at run ([eval]:1020:15)</span><br><span class="line">    at onRunRequest ([eval]:864:18)</span><br><span class="line">    at onMessage ([eval]:828:13)</span><br><span class="line">    at process.emit (node:events:526:28)</span><br><span class="line">    at emit (node:internal/child_process:938:14)</span><br><span class="line">    at processTicksAndRejections (node:internal/process/task_queues:84:21)</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">因此，在实际开发中能使用<code>Reflect</code>的情况建议尽量使用它，而不要使用<code>Object</code> ，因为很有可能一个未处理的异常抛出就终止了程序的运行。</div>
</div>

<p>Vue 3.0 就是通过<code>Proxy</code>（代理）与<code>Reflect</code>（反射）来实现的响应式。</p>
<h3 id="7-计算属性"><a href="#7-计算属性" class="headerlink" title="(7) 计算属性"></a><strong>(7) 计算属性</strong></h3><p>在 Vue 3.0 中，使用计算属性也需要先<code>import</code> 。虽然也能直接使用 Vue 2.0 的计算属性，但并不推荐这么做。配置计算属性很简单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 引入 ref() 和 computed() 函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> a = <span class="title function_">ref</span>(<span class="number">6</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 定义计算属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> b = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> a.<span class="property">value</span> ** <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; a, b &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Vue 3.0 中，<code>computed</code>变成了一个函数，该函数接收一个参数函数，该函数的返回值就是此计算属性的值。并且，计算属性是可以定义到由<code>reactive()</code>函数创建的代理对象下的。</p>
<p>上述写法是计算属性的简写形式，只能读不能写。要想获得可以写入的计算属性，应当使用完整的计算属性书写方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> a = <span class="title function_">ref</span>(<span class="number">6</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 完整的计算属性书写方式</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> b = <span class="title function_">computed</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 定义 get() 方法</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">return</span> a.<span class="property">value</span> ** <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 定义 set() 方法</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    a.<span class="property">value</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(value));</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; a, b &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-监视属性"><a href="#8-监视属性" class="headerlink" title="(8) 监视属性"></a><strong>(8) 监视属性</strong></h3><h4 id="1-watch"><a href="#1-watch" class="headerlink" title="1. watch()"></a><strong>1. <code>watch()</code></strong></h4><p>与计算属性一样，监视属性也变成了一个需要引入的函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 引入 ref() 和 watch() 函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> a = <span class="title function_">ref</span>(<span class="number">6</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 设置计算属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">watch</span>(a, <span class="function">(<span class="params">New, Old</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// ······</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 侦测到数据改变后的代码</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// ······</span></span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; a &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相比旧版本的<code>watch</code> ，新版本的监视属性允许监视多个值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;MainStruct&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> a = <span class="title function_">ref</span>(<span class="number">6</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> b = <span class="title function_">ref</span>(<span class="string">&quot;测试&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 设置多个计算属性</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">watch</span>([a, b], <span class="function">(<span class="params">New, Old</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 尝试查看传入的参数</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;New =&quot;</span>, <span class="title class_">New</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Old =&quot;</span>, <span class="title class_">Old</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123; a, b &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在网页中修改值，将会在控制台中打印：</p>
<p><img src="/2022/04/23/VueGrammar03/6.png" alt="6" title="6"></p>
<p>可以看出传递给函数的参数变为了数组，并且是按照要监视的属性在参数数组中的位置，来排列新值和就值。一旦数组中的某一个变量的值改变，就会触发回调函数。</p>
<p>此外，<code>watch()</code>还能接收第三个参数，该参数是一个配置对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    [a, b],</span><br><span class="line">    <span class="function">(<span class="params">New, Old</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试查看传入的参数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;New =&quot;</span>, <span class="title class_">New</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Old =&quot;</span>, <span class="title class_">Old</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 第三个参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指示在页面首次加载时立即执行回调函数</span></span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>深度监视模式与监视<code>reactive()</code>创建的代理对象</strong></div>

<div style="color:goldenrod;">深度监视模式在监视<span style="color:red;">代理对象本身</span>的情况下是失效的（或者说没法关闭），因为Vue 3.0的底层代理逻辑（ <code>Proxy</code> ）就注定了它只能是深度监视的。另外，监视代理对象时，虽然能侦测到属性值的变化，但是传给回调函数的<code>New</code>与<code>Old</code>都是代理对象本身，即无法获取改变之前的值。因为传回的都是代理对象本身，它不掌握数据，所以新旧值都是引用的外部数据，引用本身不变，而这个外部数据已经被修改了。</div>
</div>

<p>因此，在 Vue 3.0 中，监视代理对象的某一个属性，需要通过函数返回值的方式来传递参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">114514</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1919810</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> temp.<span class="property">a</span>, <span class="function">(<span class="params">New, Old</span>) =&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">        <span class="comment">// 你的代码</span></span><br><span class="line">        <span class="comment">// ······</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">return</span> &#123; a &#125;;</span><br></pre></td></tr></table></figure>

<p>当监视一个代理对象内的多个属性时，就必须使用数组，并且其中的每一个元素都应当是像上述代码中的<code>() => temp.a</code>一样的函数。当<span style="color:red;">只</span>监视代理对象中的<span style="color:red;">对象中的属性</span>时，需要使用深度监视模式。</p>
<h4 id="2-watchEffect"><a href="#2-watchEffect" class="headerlink" title="2. watchEffect()"></a><strong>2. <code>watchEffect()</code></strong></h4><p><code>watchEffect()</code>函数是Vue 3.0新增的函数，该函数同样也能用于监视。它只接受一个参数，该参数是一个回调函数。</p>
<p>使用<code>watchEffect()</code>函数进行监视时，不需要指明要监视的变量。所有在该回调函数内使用的变量的值改变时，回调函数就会重新执行。相比<code>watch()</code>函数，<code>watchEffect()</code>函数智能了不少。通常会在该函数的回调函数内编写Ajax请求。</p>
<h3 id="9-toRef-与toRefs"><a href="#9-toRef-与toRefs" class="headerlink" title="(9) toRef()与toRefs()"></a><strong>(9) <code>toRef()</code>与<code>toRefs()</code></strong></h3><p><code>toRef()</code>函数接受两个参数，前者是一个对象，后者是该对象的属性名。该函数会将指定的属性加工为引用对象。使用该函数时可以传入<code>reactive()</code>函数创建的代理对象，生成的引用对象也具有响应式的效果。</p>
<p>它与<code>ref()</code>函数最大的区别在于，前者是真的 “引用” ，而后者是新建实例的 “引用” 。当传入的数据是一个代理对象时，修改前者创建的引用对象，代理对象也会跟着改变；而后者无法做到这一点，因为后者 “引用” 的是一个全新对象。</p>
<p>而<code>toRefs()</code>则是一次性处理一个对象下的所有属性，因此它不需要第二个参数。</p>
<p><del>反正我是觉得这俩函数花里胡哨的没啥用。</del></p>
<h2 id="九、新的标签"><a href="#九、新的标签" class="headerlink" title="九、新的标签"></a><strong>九、新的标签</strong></h2><p>下文介绍的标签不是HTML自带的标签，而是Vue定义的可以在模板中使用的标签。</p>
<h3 id="1-lt-teleport-gt"><a href="#1-lt-teleport-gt" class="headerlink" title="(1) &lt;teleport&gt;"></a><strong>(1) <code>&lt;teleport&gt;</code></strong></h3><p><code>&lt;teleport&gt;</code>标签可以将位于其内部的HTML文本（包含HTML元素及其结构） “传送” 到指定的元素下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MainStruct</span> <span class="attr">v-show</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">MainStruct</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 标明要传送其内部的结构到 id 为 test 的 &lt;div&gt; 标签下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;div#test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;temp.a&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;temp.b&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 父组件中的结构将会出现在此 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器中展示的HTML结构如下：</p>
<p><img src="/2022/04/23/VueGrammar03/7.png" alt="7" title="7"></p>
<p><code>&lt;teleport&gt;</code>标签能将其中的HTML结构传送到任意位置，包括<code>&lt;body&gt;</code>标签，但传送的底层实现类似于<code>appendChild()</code>函数，即传送的HTML结构会变成该元素下的最后一个子元素。</p>
<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">Vue是一个庞大的、还在不断更新的库。此文所述，止冰山一角。要想深入了解，掌握ES6~ES12的新语法、学习JavaScript高级编程、阅读Vue的完整API文档是不可避免的。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>JavaScript库</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5+CSS3基础</title>
    <url>/2022/01/29/WebDevelop/</url>
    <content><![CDATA[<img src="/2022/01/29/WebDevelop/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">建议至少有过一门编程语言的学习经历再学习HTML与CSS</div>
</div>

<span id="more"></span>

<h2 id="一、HTML5基础"><a href="#一、HTML5基础" class="headerlink" title="一、HTML5基础"></a><strong>一、HTML5基础</strong></h2><p>HTML全名为超文本标记语言。这意味着它的作用仅仅是“标记”。除了标记某段文本是什么类型以外，它不应该执行其他功能，包括设置文本样式。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>HTML的功能</strong></div>

<div style="color:royalblue;">在网页开发中，HTML负责描述网页的结构，决定了网页的每一部分“是什么”。虽然HTML也能一定程度上设置网页的外观，但非常不推荐这么做，因为它是CSS的功能。</div>
</div>

<p>HTML5是HTML的新一代标准。大部分浏览器都已经支持了这一套标准。<del>IE除外。话说微软都要放弃IE了。</del></p>
<h3 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="(1) 基础语法"></a><strong>(1) 基础语法</strong></h3><p>HTML几乎没有语法。使用HTML的标签，标记某段文本是属于什么类型的，设置一些网页的相关信息。这就是HTML的功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在HTML中，标签分为两种，一种是有一个开头标签与一个结束标签的标签；另一种则只有开头而没有结束标签，<span style="color:red;">这种我们一般称为自结束标签。</span></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/1.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种标签就既是开始标签又是结束标签。h1标签代表其中的文本是一级标题，img标签这是声明这一块应该是一张图片。src为img标签的属性，它的值为要引用的图片的路径。“img&#x2F;1.png”为相对路径。设置多个属性时，需要使用空格而不是分号或者逗号。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>标签的属性</strong></div>

<div style="color:royalblue;">每个标签都有它的独特的属性，也有适用于所有标签的全局属性。</div>
</div>

<p>一个HTML文件的整体结构应该是这样的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span>  <span class="comment">&lt;!--[1]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span>  <span class="comment">&lt;!--[2]--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  <span class="comment">&lt;!--[3]--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页名称<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="comment">&lt;!--[4]--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--JavaScript、CSS引用部分--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--[5]元数据设置部分--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  <span class="comment">&lt;!--[6]--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--[7]网页的头部--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--[8]网页的主要内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--[9]网页的尾部--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note default"><div style="color:dimgray;font-size:1.5em;"><strong>代码的注释</strong></div>

<div style="color:dimgray;">
[1] 声明标签，用于声明这份HTML文件遵循什么标准。此处为HTML5标准的声明。<br>
[2] html标签，声明了网页的主体。在这个标签之外的任何信息都不会出现在浏览器中。lang属性为html标签的属性，它规定了网页的语言。<br>
[3] head标签，通常网页的名称、给搜索引擎抓取的关键字、给搜索引擎抓取的网页描述、对JavaScript和CSS的引用设置、元数据等都应该放在这里。<br>
[4] title标签，声明了网页的名称。它将显示在你的浏览器的标签页上。<br>
[5] meta标签，用于声明元数据。元数据你可以暂时理解为一些“全局变量”。charset属性则规定了网页的编码格式，此处为UTF-8。<br>
[6] body标签，要显示在网页中的内容都应该放在这个标签内。<br>
[7] header标签，文章的主标题或者网页顶部的导航栏应该放在这个标签内。<br>
[8] main标签，网页的主要内容应该放在这个标签内，例如文章。<br>
[9] footer标签，网页的版权、备案等信息应该放在这个标签内。
</div>
</div>

<h3 id="2-标签"><a href="#2-标签" class="headerlink" title="(2) 标签"></a><strong>(2) 标签</strong></h3><p>HTML的标签非常多，这里只列举一些重要的。</p>
<div class="tabs" id="htmlmarks"><ul class="nav-tabs"><li class="tab active"><a href="#htmlmarks-1">注释</a></li><li class="tab"><a href="#htmlmarks-2">&lt;!doctype&gt;</a></li><li class="tab"><a href="#htmlmarks-3">&lt;a&gt;</a></li><li class="tab"><a href="#htmlmarks-4">&lt;audio&gt;</a></li><li class="tab"><a href="#htmlmarks-5">&lt;iframe&gt;</a></li><li class="tab"><a href="#htmlmarks-6">&lt;img&gt;</a></li><li class="tab"><a href="#htmlmarks-7">&lt;input&gt;</a></li><li class="tab"><a href="#htmlmarks-8">&lt;link&gt;</a></li><li class="tab"><a href="#htmlmarks-9">&lt;meta&gt;</a></li><li class="tab"><a href="#htmlmarks-10">&lt;textarea&gt;</a></li><li class="tab"><a href="#htmlmarks-11">&lt;video&gt;</a></li><li class="tab"><a href="#htmlmarks-12">&lt;dl&gt;</a></li><li class="tab"><a href="#htmlmarks-13">&lt;ol&gt;与&lt;ul&gt;</a></li><li class="tab"><a href="#htmlmarks-14">&lt;select&gt;</a></li></ul><div class="tab-content"><div class="tab-pane active" id="htmlmarks-1"><p>HTML的注释格式比较特殊。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    注释样例</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>所有在&lt;!--与--&gt;之间的字符都会被认为是注释。</p></div><div class="tab-pane" id="htmlmarks-2"><div style="color:red;">自结束标签。</div>

<p>!doctype标签用于声明网页的标准。因为HTML5已被多数浏览器支持，所以一般会声明为HTML5。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="htmlmarks-3"><p>a标签为超链接标签。</p>
<p>常用属性：</p>
<div class="tabs" id="aproperty"><ul class="nav-tabs"><li class="tab active"><a href="#aproperty-1">href</a></li><li class="tab"><a href="#aproperty-2">target</a></li></ul><div class="tab-content"><div class="tab-pane active" id="aproperty-1"><p>设置超链接的链接地址，如果为“#”，点击超链接时则会回到网页顶部。如果没有此属性，则在其中的文本不会成为超链接文本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>超链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>普通文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下</p>
<p><a href="https://www.baidu.com">超链接文本</a><br><a>普通文本</a></p>
<p>点击超链接文本，将会跳转至百度，而点击普通文本将不会有任何反应。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>两点注意</strong></div>

<div style="color:goldenrod;">

<ol>
<li>当你希望超链接能跳转到其它网站时，请记得加上http或者https前缀，否则浏览器将会把链接解析为相对路径。</li>
<li>上面的“普通文本”在此博客中将会显示为红色的超链接。这是因为此博客的CSS的设置影响了它。你编写的代码应该不会出现超链接的样式。</li>
</ol>
</div>
</div></div><div class="tab-pane" id="aproperty-2"><p>只有当href属性被设置了的时候，target属性才会有效。它设置如何打开链接。</p>
<ul>
<li>_blank，在新窗口打开。</li>
<li>_self，在当前页面打开。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>在新窗口打开<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>在当前页面打开<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下</p>
<p><a href="https://www.baidu.com" target="_blank">在新窗口打开</a><br><a href="https://www.baidu.com" target="_self">在当前页面打开</a></p></div></div></div></div><div class="tab-pane" id="htmlmarks-4"><p>audio标签为音频标签。</p>
<p>常用属性：</p>
<div class="tabs" id="audioproperty"><ul class="nav-tabs"><li class="tab active"><a href="#audioproperty-1">autoplay</a></li><li class="tab"><a href="#audioproperty-2">controls</a></li><li class="tab"><a href="#audioproperty-3">loop</a></li><li class="tab"><a href="#audioproperty-4">muted</a></li><li class="tab"><a href="#audioproperty-5">preload</a></li><li class="tab"><a href="#audioproperty-6">src</a></li></ul><div class="tab-content"><div class="tab-pane active" id="audioproperty-1"><p>autoplay属性设定音频是否自动播放。它不需要设定值，只要写上该属性就能生效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;/musics/ChaseTheWorld.mp3&quot;</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>自动播放的问题</strong></div>

<div style="color:goldenrod;">现在很多浏览器，尤其是手机的浏览器，大多数都默认禁止自动播放。如果设置了自动播放却没有自动播放，那就是浏览器的问题了。<del>或者是你音频路径有问题。</del></div>

<p><img src="/2022/01/29/WebDevelop/2.png" alt="2 2" title="2"></p>
</div></div><div class="tab-pane" id="audioproperty-2"><p>controls属性设定是否显示播放器，以控制音频的播放。它不需要设定值，只要写上该属性就能生效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;/musics/ChaseTheWorld.mp3&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下（请注意音量）</p>
<p><audio src="/musics/ChaseTheWorld.mp3" controls></audio></p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>播放器样式</strong></div>

<div style="color:goldenrod;">这里的播放器是浏览器默认提供的播放器。不同的浏览器提供的样式可能不同，这可能会导致网页排版出现问题。当然你也可以规定一个统一的播放器样式，但本文并不涉及这点。</div>
</div></div><div class="tab-pane" id="audioproperty-3"><p>loop属性设定音频是否循环播放。它不需要设定值，只要写上该属性就能生效。</p></div><div class="tab-pane" id="audioproperty-4"><p>muted属性设定音频是否一开始为静音。它不需要设定值，只要写上该属性就能生效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;/musics/ChaseTheWorld.mp3&quot;</span> <span class="attr">controls</span> <span class="attr">muted</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下</p>
<p><audio src="/musics/ChaseTheWorld.mp3" controls muted></audio></p>
<p>点击播放，你会发现是静音状态。</p></div><div class="tab-pane" id="audioproperty-5"><p>preload属性设置了音频的加载方式。</p>
<ul>
<li>auto，自动加载</li>
<li>metadata，以元数据方式加载音频（优先加载）</li>
<li>none，不主动加载音频</li>
</ul></div><div class="tab-pane" id="audioproperty-6"><p>src属性设定了音频路径。这个路径一般为相对路径。</p></div></div></div>

<p>音频标签不是自结束标签，因此它可以做一些特殊操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/musics/ChaseTheWorld.mp3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第一个音频--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;/musics/ChaseTheWorld.mp3&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    您的浏览器不支持音频</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第二个音频--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;/musics/ChaseTheWorld.mp3&quot;</span>&gt;</span></span><br><span class="line">    您的浏览器不支持音频</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--第三个音频--&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下</p>
<audio controls>
    <source src="/musics/ChaseTheWorld.mp3">
</audio>
    <!--第一个音频-->

<audio src="/musics/ChaseTheWorld.mp3" controls>
    您的浏览器不支持音频
</audio>
<!--第二个音频-->

<audio src="/musics/ChaseTheWorld.mp3">
    您的浏览器不支持音频
</audio>
<!--第三个音频，不显示播放器-->

<p>可以看到，第一个播放器成功加载了音频。并且，audio标签中的文字并没有显示出来，不论是否使用了control标签。</p>
<p>audio标签会隐藏其中的文字，但如果浏览器不支持audio标签，那么解析的时候就会以一般文本的方式解析其中的文字。即：如果浏览器不支持音频，那么就会显示其中的文字“您的浏览器不支持音频”。</p></div><div class="tab-pane" id="htmlmarks-5"><p>iframe标签为内联框架标签。简单来讲就是在网页的内部划定一块区域。</p>
<p>常见属性有：</p>
<ul>
<li>height，设置框架的高度为多少像素</li>
<li>width，设置框架的宽度为多少像素</li>
<li>src，设置要显示的内容的路径</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://bing.com&quot;</span> <span class="attr">height</span>=<span class="string">&quot;600px&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600px&quot;</span>&gt;</span></span><br><span class="line">    内联框架</span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果为</p>
<iframe src="https://bing.com" height="600px" width="600px">
    内联框架
</iframe>

<p>你可能需要加载一会。框架内显示的就是必应。<del>为什么不是百度？因为百度根本就显示不出来。</del>同时“内联框架”这几个字也消失了，其原理与audio一样。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>内联框架的样式</strong></div>

<div style="color:royalblue;">内联框架中的网页没有缩放，而且滚动条很丑。要想美化内联框架，你需要学习CSS。</div>
</div></div><div class="tab-pane" id="htmlmarks-6"><div style="color:red;">自结束标签。</div>

<p>img标签为图片标签。可以用这个标签来显示图片。</p>
<p>常见属性有：</p>
<div class="tabs" id="imgproperty"><ul class="nav-tabs"><li class="tab active"><a href="#imgproperty-1">alt</a></li><li class="tab"><a href="#imgproperty-2">height&width</a></li><li class="tab"><a href="#imgproperty-3">loading</a></li><li class="tab"><a href="#imgproperty-4">src</a></li></ul><div class="tab-content"><div class="tab-pane active" id="imgproperty-1"><p>alt属性可以设置图片的描述文本。当图片加载失败的时候，就会显示这个文本。网页朗读器在读取图片时也会读取这个文本。</p></div><div class="tab-pane" id="imgproperty-2"><p>height与width属性分别设置了显示图像的高度与宽度。可以设置为auto，浏览器会自动进行缩放。</p></div><div class="tab-pane" id="imgproperty-3"><p>loading属性设置了图片的加载方式。</p>
<ul>
<li>eager，与网页一起加载</li>
<li>lazy，当网页加载完毕以后再加载图片</li>
</ul></div><div class="tab-pane" id="imgproperty-4"><p>src设置了要显示的图像的路径。</p></div></div></div>

<p>使用样例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/DDR.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;auto&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下</p>
<img src="images/DDR.png" width="300" height="auto"></div><div class="tab-pane" id="htmlmarks-7"><div style="color:red;">自结束标签。</div>

<p>input标签为输入框标签。这个“输入框”有很多种，包括文本、数字、勾选、下拉列表等。由于其属性很多，此处便从简表述。详细内容请参见 <a class="btn" href="https://www.runoob.com/tags/tag-input.html ">菜鸟教程</a> 。</p>
<ul>
<li>type，设置输入的类型</li>
<li>value，设置默认的输入值</li>
<li>placeholder，设置输入框的提示信息</li>
<li>pattern，设置用于检测输入的正则表达式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">button</span> <span class="attr">value</span>=<span class="string">&quot;114514&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;来点输入&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;然而什么都不会发生&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下</p>
<input type="text" button value="114514" placeholder="来点输入">
<input type="submit" value="然而什么都不会发生">

<p>输入框内默认输入了114514，删除之后可以看到提示信息“来点输入”。点击按钮确实什么都不会发生（因为并没有定义事件，而这是JavaScript的功能。）</p></div><div class="tab-pane" id="htmlmarks-8"><div style="color:red;">自结束标签。</div>

<p>link标签为链接标签。主要用于链接各类文本：一个网站的其他网页、网页的CSS文件、网页的JavaScript文件等。这个标签主要写在head标签内。</p>
<p>常用属性有：</p>
<ul>
<li>href，链接文件的路径</li>
<li>rel，设置链接文件与这个网页的关系</li>
<li>type，设置链接文件的类型</li>
</ul></div><div class="tab-pane" id="htmlmarks-9"><p>meta标签为元数据标签，它定义了网页的元数据，这部分数据不会被浏览器显示，但是会被浏览器解析。关于元数据，详见 <a class="btn" href="https://www.runoob.com/tags/tag-meta.html ">菜鸟教程</a> 。</p></div><div class="tab-pane" id="htmlmarks-10"><p>textarea标签为文本域标签。在此标签中的文本将成为文本域的默认输入。</p>
<p>常用属性有：</p>
<ul>
<li>cols、rows，设置域宽度与高度</li>
<li>maxlength，设置允许的最大字符数</li>
<li>placeholder，设置输入提示</li>
<li>readonly，设置为只读</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;来点输入&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;100&quot;</span>&gt;</span>114514<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果为</p>
<textarea cols="50" rows="10" placeholder="来点输入" maxlength="100">114514</textarea></div><div class="tab-pane" id="htmlmarks-11"><p>video标签为视频标签。它的很多行为与audio标签类似。</p>
<ul>
<li>autoplay，设置是否自动播放</li>
<li>controls，设置是否显示播放进度条</li>
<li>height&amp;width，设置播放器高度&amp;宽度</li>
<li>loop，设置是否循环播放</li>
<li>muted，设置是否初始为静音</li>
<li>poster，设置视频封面的路径</li>
<li>preload，设置视频的加载方式<ul>
<li>为auto时，自动加载</li>
<li>为metadata时，以元数据方式加载（优先加载）</li>
<li>为none时，不主动加载</li>
</ul>
</li>
<li>src，设置视频的路径</li></ul></div><div class="tab-pane" id="htmlmarks-12"><p>dl标签为定义列表标签。在定义列表中，你可以使用&lt;dt&gt;自定义序号，使用&lt;dd&gt;写文字内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第一段<span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第二段<span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果如下</p>
<dl>
    <dt>第一段</dt><dd>内容1</dd>
    <dt>第二段</dt><dd>内容2</dd>
</dl>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong><del>都怪CSS</del></strong></div>

<div style="color:royalblue;">上面的“内容1”与“内容2”本来应该有缩进，但是因为此博客的CSS设置导致它们的缩进没了。</div>
</div></div><div class="tab-pane" id="htmlmarks-13"><p>ol标签为有序列表标签，ul为无序列表标签。可以使用li标签来标记列表中的一项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果为</p>
<ol>
    <li>第一项</li>
    <li>第二项</li>
    <li>第三项</li>
</ol>
<ul>
    <li>第一项</li>
    <li>第二项</li>
    <li>第三项</li>
</ul>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>列表套娃</strong></div>

<div style="color:royalblue;">列表是可以套娃的。你想怎么套就怎么套，并且浏览器还会自动为你的子列表设置与父列表不一样的标记。你可以动手试试。</div>
</div></div><div class="tab-pane" id="htmlmarks-14"><p>select标签为下拉列表标签，它有属性multiple，启用以后可以多选。可以用option标签定义选项，option标签有属性selected，启用这个属性的选项会成为默认选中的选项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>选项114514<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码效果为</p>
<select>
    <option>选项1</option>
    <option>选项2</option>
    <option>选项3</option>
    <option selected>选项114514</option>
    <option>选项4</option>
</select></div></div></div>

<p>由于HTML的标签实在过多，此处就不再一一列举。想查看所有标签，请前往 <a class="btn" href="https://www.runoob.com/tags/html-reference.html ">菜鸟教程</a> 。</p>
<p>标签没必要一个一个去记，只需要记住一些常见的就行。剩下的标签，需要的时候再找它。</p>
<p>下面是一些常见的、没什么常用特殊属性的标签。</p>
<ul>
<li>&lt;article&gt;，网页中的文章</li>
<li>&lt;aside&gt;，网页的侧边栏</li>
<li>&lt;blockquote&gt;，引用的文字，会自带缩进</li>
<li>&lt;br&gt;，换行，自结束标签</li>
<li>&lt;code&gt;，网页中的代码区域</li>
<li>&lt;div&gt;，网页中的一行。这个在网页中最常见</li>
<li>&lt;em&gt;，字体变为斜体</li>
<li>&lt;h1&gt;~&lt;h6&gt;，第几级标题</li>
<li>&lt;hr&gt;，水平分割线，自结束标签</li>
<li>&lt;nav&gt;，网页导航部分</li>
<li>&lt;p&gt;，一个段落</li>
<li>&lt;q&gt;，给文本添加双引号</li>
<li>&lt;span&gt;，网页中的一块，内容有多长就占用网页中多少面积，不想用div独占一行的时候可以用它</li>
<li>&lt;strong&gt;，文本加粗</li>
<li>&lt;style&gt;，在这个标签内可以直接写CSS语句</li>
<li>&lt;sub&gt;，文本为下标</li>
</ul>
<h3 id="3-属性"><a href="#3-属性" class="headerlink" title="(3) 属性"></a><strong>(3) 属性</strong></h3><p>有一些属性是所有标签都有的属性。这些属性被称为全局属性。常见的全局属性有：</p>
<div class="tabs" id="globalproperty"><ul class="nav-tabs"><li class="tab active"><a href="#globalproperty-1">lang</a></li><li class="tab"><a href="#globalproperty-2">class</a></li><li class="tab"><a href="#globalproperty-3">id</a></li><li class="tab"><a href="#globalproperty-4">style</a></li></ul><div class="tab-content"><div class="tab-pane active" id="globalproperty-1"><p>设置这个标签内的语言。通常将lang属性设置在html标签下，以规定网页全局使用的语言。</p></div><div class="tab-pane" id="globalproperty-2"><p>规定标签的类名。多个标签可以共享一个类名，一个标签可以拥有多个类名。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>类名</strong></div>

<div style="color:royalblue;">类名是很重要的。通过在CSS中指定类名，就能直接设置含有这个类名的所有标签的样式。而一个标签能含有多个类名，这代表它的样式可以叠加。当然叠加也是有规律与限制的，这将在CSS部分讲到。</div>
</div></div><div class="tab-pane" id="globalproperty-3"><p>规定标签的唯一ID。ID不能重复，一个标签只能有一个ID，而在所有的标签中ID不允许有重名。</p></div><div class="tab-pane" id="globalproperty-4"><p>设置标签的内联样式的CSS，可以直接设置这个属性来规定标签的外观与样式。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>内联样式的CSS</strong></div>

<div style="color:royalblue;">style属性的属性值就是CSS的语句。虽然style标签（注意是style标签而不是style属性）内也能写CSS，但是并不推荐这么做。</div>
</div></div></div></div>

<h2 id="二、CSS3基础"><a href="#二、CSS3基础" class="headerlink" title="二、CSS3基础"></a><strong>二、CSS3基础</strong></h2><p>CSS全名叫层叠样式表。它定义了网页的外观，可以通过CSS来设置标签的显示位置、大小、颜色等各种外观。CSS3是CSS的标准之一，目前也已经被多数浏览器所接受。</p>
<p>你可以在HTML文件的head标签下，写一个style标签，然后直接在这个标签内接写CSS语句。你也可以通过下面的HTML语句来引用CSS：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;Hello.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，rel属性被设定为“链接的文件是这个网页的样式表”，type指定了“以CSS文件的方式”解析链接的文件，href属性下的“Hello.css”应该替换为你的CSS文件的相对路径。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>删除type属性</strong></div>

<div style="color:royalblue;">type属性规定了如何解析链接文件。删除这个属性也能正确引用CSS，因为浏览器智能地根据文件的后缀名判断这是一个CSS文件。但不推荐这么做——万一遇到了不智能的浏览器呢？</div>
</div>

<h3 id="1-选择器"><a href="#1-选择器" class="headerlink" title="(1) 选择器"></a><strong>(1) 选择器</strong></h3><p>CSS通过某种方式选中HTML中的标签，然后设置它的外观。语法大致如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码将会让你的网页中main标签下的字体变为红色，main标签的背景变为蓝色。</p>
<p>接下来将介绍CSS如何选中HTML的标签。</p>
<h4 id="Ⅰ-一般选择器"><a href="#Ⅰ-一般选择器" class="headerlink" title="Ⅰ. 一般选择器"></a><strong>Ⅰ. 一般选择器</strong></h4><p>标签选择器，就是直接指定HTML中标签的名字，直接修改这一类标签的外观。</p>
<div class="tabs" id="generalselector"><ul class="nav-tabs"><li class="tab active"><a href="#generalselector-1">*</a></li><li class="tab"><a href="#generalselector-2">div</a></li><li class="tab"><a href="#generalselector-3">.CLASS</a></li><li class="tab"><a href="#generalselector-4">div &gt; span</a></li><li class="tab"><a href="#generalselector-5">div span</a></li><li class="tab"><a href="#generalselector-6">div + span</a></li><li class="tab"><a href="#generalselector-7">div ~ span</a></li><li class="tab"><a href="#generalselector-8">[height]</a></li><li class="tab"><a href="#generalselector-9">[height=500px]</a></li><li class="tab"><a href="#generalselector-10">[alt^="114"]</a></li><li class="tab"><a href="#generalselector-11">[alt$="114"]</a></li><li class="tab"><a href="#generalselector-12">[alt*="114"]</a></li></ul><div class="tab-content"><div class="tab-pane active" id="generalselector-1"><p>选中所有的标签。这个选择器很暴力。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网页会整个变为蓝底。你可以随便在你的网页中增加文字，它们都会变成红色的字。</p></div><div class="tab-pane" id="generalselector-2"><p>选中所有的div标签。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网页中的所有div标签会变为蓝底。你可以随便在你的div标签中增加文字，它们都会变成红色的字。</p></div><div class="tab-pane" id="generalselector-3"><p>选中所有的含有类名CLASS的标签。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.CLASS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="generalselector-4"><p>选中所有的父标签为div的span标签</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>父标签</strong></div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">在上面的代码中,div为span的父标签，body为div的父标签，而body不是span的父标签。</div>
</div></div><div class="tab-pane" id="generalselector-5"><p>选中所有的祖先标签为div的span标签。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>祖先标签</strong></div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">在上面的代码中，body、div都是span的祖先标签。</div>
</div></div><div class="tab-pane" id="generalselector-6"><p>选中所有的上一个兄弟标签为div的span标签。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>兄弟标签及其顺序</strong></div>

<div style="color:royalblue;">拥有同一个父标签的标签为兄弟标签。它们的顺序就是在HTML文件中的先后顺序。</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">在上面的代码中，h1与span互为兄弟标签，h1为span的上一个兄弟标签，span为h1的下一个兄弟标签。</div>
</div></div><div class="tab-pane" id="generalselector-7"><p>选中之前的兄弟标签中含有div标签的span标签。</p></div><div class="tab-pane" id="generalselector-8"><p>选中所有含有height属性的标签。只要含有height属性，不论是textarea标签还是img标签，都会被选中。</p></div><div class="tab-pane" id="generalselector-9"><p>选中所有含有属性height，且该属性值为“500px”的标签。</p></div><div class="tab-pane" id="generalselector-10"><p>选中所有含有属性alt，且该属性值以“114”开头的标签。</p></div><div class="tab-pane" id="generalselector-11"><p>选中所有含有属性alt，且该属性值以“114”结尾的标签。</p></div><div class="tab-pane" id="generalselector-12"><p>选中所有含有属性alt，且该属性值含有“114”的标签。</p></div></div></div>

<h4 id="Ⅱ-伪类-amp-伪标签选择器-amp-ID选择器"><a href="#Ⅱ-伪类-amp-伪标签选择器-amp-ID选择器" class="headerlink" title="Ⅱ. 伪类&amp;伪标签选择器&amp;ID选择器"></a><strong>Ⅱ. 伪类&amp;伪标签选择器&amp;ID选择器</strong></h4><p>这些选择器可以作为一般选择器的修饰符工作。</p>
<div class="tabs" id="fakeclassselector"><ul class="nav-tabs"><li class="tab active"><a href="#fakeclassselector-1">div:first-child</a></li><li class="tab"><a href="#fakeclassselector-2">div:last-child</a></li><li class="tab"><a href="#fakeclassselector-3">div:nth-child(i)</a></li><li class="tab"><a href="#fakeclassselector-4">div:nth-child(i)</a></li><li class="tab"><a href="#fakeclassselector-5">div:first-of-type</a></li><li class="tab"><a href="#fakeclassselector-6">div:last-of-type</a></li><li class="tab"><a href="#fakeclassselector-7">div:nth-of-type(i)</a></li><li class="tab"><a href="#fakeclassselector-8">div:not([style])</a></li><li class="tab"><a href="#fakeclassselector-9">a:link</a></li><li class="tab"><a href="#fakeclassselector-10">a:visited</a></li><li class="tab"><a href="#fakeclassselector-11">div:hover</a></li><li class="tab"><a href="#fakeclassselector-12">div:active</a></li><li class="tab"><a href="#fakeclassselector-13">div:first-letter</a></li><li class="tab"><a href="#fakeclassselector-14">div:selection</a></li><li class="tab"><a href="#fakeclassselector-15">div:before</a></li><li class="tab"><a href="#fakeclassselector-16">div:after</a></li><li class="tab"><a href="#fakeclassselector-17">#ID</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fakeclassselector-1"><p>选中所有作为第一个子标签的div标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>div:first-child将选中第一个div标签而不是第二个div标签。</p></div><div class="tab-pane" id="fakeclassselector-2"><p>选中所有作为最后一个子标签的div标签。</p></div><div class="tab-pane" id="fakeclassselector-3"><p>选中所有作为第i个子标签的div标签。其中i为一个正整数。</p></div><div class="tab-pane" id="fakeclassselector-4"><p>选中所有作为第i个子标签的div标签。其中i为一个正整数，或者以下特殊值：</p>
<ul>
<li>even，选中为第偶数个子标签的div标签</li>
<li>odd，选中为第奇数个子标签的div标签</li>
</ul></div><div class="tab-pane" id="fakeclassselector-5"><p>选中HTML文件中第一个出现的div标签</p></div><div class="tab-pane" id="fakeclassselector-6"><p>选中HTML文件中最后一个出现的div标签</p></div><div class="tab-pane" id="fakeclassselector-7"><p>选中HTML文件中第i个出现的div标签。其中i为一个正整数，或者以下特殊值：</p>
<ul>
<li>even，选中第偶数个出现的div标签</li>
<li>odd，选中第奇数个出现的div标签</li>
</ul></div><div class="tab-pane" id="fakeclassselector-8"><p>选中所有不含style属性的div标签。符合not()括号内的标签将被排除在外。</p></div><div class="tab-pane" id="fakeclassselector-9"><p>选中所有链接未被访问过的a标签。</p></div><div class="tab-pane" id="fakeclassselector-10"><p>选中所有链接被访问过的a标签。</p></div><div class="tab-pane" id="fakeclassselector-11"><p>选中所有被鼠标指向的div标签。</p></div><div class="tab-pane" id="fakeclassselector-12"><p>选中所有正在被鼠标点击的div标签。</p></div><div class="tab-pane" id="fakeclassselector-13"><p>选中div标签中的第一个字符。</p></div><div class="tab-pane" id="fakeclassselector-14"><p>选中div标签中所有被鼠标选中的字符。</p></div><div class="tab-pane" id="fakeclassselector-15"><p>选中div标签的第一个字符开始之前。</p>
<p>可以在这个选择器下使用属性content，这样可以在所有div标签的内容前插入指定的字符。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;114514&quot;</span>;</span><br><span class="line">    <span class="comment">/*在div标签的内容之前插入114514*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="fakeclassselector-16"><p>选中div标签的第一个字符开始之后。</p>
<p>可以在这个选择器下使用属性content，这样可以在所有div标签的内容后插入指定的字符。</p></div><div class="tab-pane" id="fakeclassselector-17"><p>选中id&#x3D;“ID”的标签。</p></div></div></div>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>选择器叠叠乐</strong></div>

<div style="color:royalblue;">上述的所有选择器都是可以叠加与混合使用的。</div>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>,<span class="selector-tag">div</span> &gt; <span class="selector-class">.CLASS</span>,<span class="selector-id">#NAV</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">上面的选择器选中了所有的div标签、所有的父标签为div标签且含有类名CLASS的标签与ID为NAV的标签。</div>
</div>

<p>关于更多选择器，详细参见 <a class="btn" href="https://www.runoob.com/cssref/css-selectors.html ">菜鸟教程</a> 。</p>
<h4 id="Ⅲ-选择器的优先级"><a href="#Ⅲ-选择器的优先级" class="headerlink" title="Ⅲ. 选择器的优先级"></a><strong>Ⅲ. 选择器的优先级</strong></h4><p>当通过不同的选择器选中同一个标签之后，如果不同的选择器都对同一个属性进行了设置，那么就会产生冲突。浏览器会选择优先级较高的外观。</p>
<p>在选择器的某个属性后面添加 <mark class="label primary">!important</mark> 关键字，它将成为最高优先级。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同类别的外观设置中，优先级的顺序如下：<br>!important关键字＞内联样式＞ID选择器＞类&amp;伪类选择器＞标签&amp;伪标签选择器＞通配选择器＞继承的属性。</p>
<p>属性是可以被继承的。父标签的属性可以影响它的所有后代标签，但是这种继承属性的优先级是最低的，它将被覆盖。</p>
<p>优先级也是可以叠加的。选择器越多，优先级就越高。但是，不论低优先级的选择器有多少，也无法超越一个高优先级的选择器。它只能在与同等优先级的选择器的竞争中“胜出”。</p>
<h4 id="Ⅳ-常用的属性"><a href="#Ⅳ-常用的属性" class="headerlink" title="Ⅳ. 常用的属性"></a><strong>Ⅳ. 常用的属性</strong></h4><div class="tabs" id="selectorproperty"><ul class="nav-tabs"><li class="tab active"><a href="#selectorproperty-1">height&width</a></li><li class="tab"><a href="#selectorproperty-2">background</a></li><li class="tab"><a href="#selectorproperty-3">opacity</a></li><li class="tab"><a href="#selectorproperty-4">border</a></li><li class="tab"><a href="#selectorproperty-5">margin</a></li><li class="tab"><a href="#selectorproperty-6">padding</a></li><li class="tab"><a href="#selectorproperty-7">overflow</a></li><li class="tab"><a href="#selectorproperty-8">display</a></li><li class="tab"><a href="#selectorproperty-9">visibility</a></li></ul><div class="tab-content"><div class="tab-pane active" id="selectorproperty-1"><p>设置标签内容的高度&amp;宽度。单位为像素，需在数字后写上单位“px”。</p></div><div class="tab-pane" id="selectorproperty-2"><p>与background（背景）相关的属性有：</p>
<ul>
<li>background-color，设置标签内容的背景颜色。</li>
<li>background-image，设置标签内容的背景图片。参数应该为相对路径或者链接。</li>
<li>background-attachment，仅在image被设定时有效，设置背景图片是滚动的还是固定的。</li>
<li>background-size，设置背景的大小。</li>
</ul></div><div class="tab-pane" id="selectorproperty-3"><p>设置标签内容的透明度。</p></div><div class="tab-pane" id="selectorproperty-4"><p>与border（边框）相关的属性有：</p>
<ul>
<li>border-width，设置边框宽度。只有一个参数时，上下左右的宽度均为这个参数。也可以填4个参数，其顺序为上右下左的边框宽度。</li>
<li>border-color，设置边框的颜色</li>
<li>border-style，设置边框的样式。其参数如下：</li>
</ul>
<div class="tabs" id="borderstyleoption"><ul class="nav-tabs"><li class="tab active"><a href="#borderstyleoption-1">solid</a></li><li class="tab"><a href="#borderstyleoption-2">dotted</a></li><li class="tab"><a href="#borderstyleoption-3">dashed</a></li><li class="tab"><a href="#borderstyleoption-4">double</a></li></ul><div class="tab-content"><div class="tab-pane active" id="borderstyleoption-1"><p>设置边框为实线。</p></div><div class="tab-pane" id="borderstyleoption-2"><p>设置边框为点状虚线。</p></div><div class="tab-pane" id="borderstyleoption-3"><p>设置边框为虚线。</p></div><div class="tab-pane" id="borderstyleoption-4"><p>设置边框为双实线。</p></div></div></div></div><div class="tab-pane" id="selectorproperty-5"><p>设置标签的外边距。有4个参数，也可以只写1个参数，其顺序为上右下左的外边距宽度。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>外边距与边框与内边距</strong></div>

<div style="color:royalblue;">还是上图比较好解释。</div>

<p><img src="/2022/01/29/WebDevelop/6.png" alt="6 6" title="6"></p>
</div></div><div class="tab-pane" id="selectorproperty-6"><p>设置标签的内边距。有4个参数，也可以只写1个参数，其顺序为上右下左的内边距宽度。</p></div><div class="tab-pane" id="selectorproperty-7"><p>设置标签的内容溢出时，如何显示内容。</p>
<ul>
<li>auto，根据需要自动生成滚动条</li>
<li>hidden，隐藏溢出的内容</li>
<li>visible，显示溢出的内容</li>
<li>scroll，使用垂直与水平的滚动条</li></ul></div><div class="tab-pane" id="selectorproperty-8"><p>设置标签的显示方式。</p>
<ul>
<li>inline，以行内标签方式显示</li>
<li>block，以块标签方式显示</li>
<li>inline-block，以行内块标签方式显示</li>
<li>table，以表格方式显示</li>
<li>none，隐藏此标签</li>
</ul>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>行内标签与块标签</strong></div>

<div style="color:royalblue;">行内标签会独占网页的一行，常见的标签如&lt;p&gt;，&lt;div&gt;标签。块标签则不会独占，内容有多少就只占多少宽度，常见的标签如&lt;span&gt;。行内标签可以设置宽高，但绝不会与其它标签共享一行；块标签不能设置宽高，但可以与其他标签共享一行；行内块标签既能设置宽高，也能与其它标签共享一行。</div>
</div></div><div class="tab-pane" id="selectorproperty-9"><p>设置标签的可见性。</p>
<ul>
<li>visible，标签可见</li>
<li>hidden，标签不可见</li>
</ul>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>与display:none的区别</strong></div>

<div style="color:royalblue;">当标签设置为visibility:visible时，标签虽然不可见但是仍会占据位置，而被设置为display:none的标签则完全不占据任何位置。</div>
</div></div></div></div>

<div class="note success"><div style="color:green;font-size:1.5em;"><strong>基础知识到此为止</strong></div>

<div style="color:green;">其实HTML5与CSS3还有许多特性与未提及的属性，但此处就不再赘述。</div>
</div>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>网页开发</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>网页开发基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery基础</title>
    <url>/2022/02/12/jQueryGrammar/</url>
    <content><![CDATA[<img src="/2022/02/12/jQueryGrammar/Title.png" alt="标题" style="width:100%;height:auto;">

<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>前置条件</strong></div>

<div style="color:goldenrod;">理解本文需要有CSS基础，并且建议最好学过JavaScript。</div>
</div>

<span id="more"></span>

<h2 id="一、简介与安装"><a href="#一、简介与安装" class="headerlink" title="一、简介与安装"></a><strong>一、简介与安装</strong></h2><p>jQuery是JavaScript的一个库，它提供了比JavaScript更方便快捷的DOM操作，让程序员能够以像写CSS一样写JavaScript，大大减少了代码量，并且提高了可读性。</p>
<p>jQuery可以在官网直接下载，也可以使用Node.js下载。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">npm install jquery</span></span><br></pre></td></tr></table></figure>

<p>本体在 <code>/node_modules/jquery/dist</code> 文件夹里。文件名中含有 <code>min</code> 字样的 <code>.js</code> 文件是压缩过的jQuery库，它大小更小但是不便于阅读，适合用于网页。不带 <code>min</code> 字样的就是方便程序员阅读的未压缩的版本。</p>
<p>将你选好的jQuery库引入到HTML文件中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/jQuery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;Hello.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中， <code>Hello.js</code> 是用户自定义的JavaScript，它必须在jQuery之后引入，否则会报错。</p>
<h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a><strong>二、基础语法</strong></h2><h3 id="1-获取标签对象"><a href="#1-获取标签对象" class="headerlink" title="(1) 获取标签对象"></a><strong>(1) 获取标签对象</strong></h3><p>在未引入jQuery的情况下，要获取标签对象需要使用非常长的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ID&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> j = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#D&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码的第一种获取方式非常长，并且需要根据查找标签的方式更换函数名。第二种获取方式是JavaScript吸收了jQuery的优点以后新添加的特性。但它们都不如jQuery简洁：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>];  <span class="comment">//以CSS的方式书写标签对象</span></span><br></pre></td></tr></table></figure>

<p>对没错，你只需要使用 <code>$</code> ，并且在其后的括号中以CSS查找标签的方式书写你要获取的标签即可。需要添加 <code>[0]</code> 是因为只要查找到了标签对象，就会以数组的形式返回结果。</p>
<h3 id="2-更改标签样式"><a href="#2-更改标签样式" class="headerlink" title="(2) 更改标签样式"></a><strong>(2) 更改标签样式</strong></h3><p>JavaScript更改标签的样式需要使用 <code>.style</code> ，并且更改的时候还要留意需要转换为字符串。而引入jQuery以后，只需要以如下方式书写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">$(i).<span class="title function_">css</span>(&#123;</span><br><span class="line">    <span class="string">&quot;background-color&quot;</span>: <span class="string">&quot;gray&quot;</span>,</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">$(<span class="string">&quot;body&quot;</span>).<span class="title function_">css</span>(&#123;</span><br><span class="line">    <span class="string">&quot;background-color&quot;</span>: <span class="string">&quot;gray&quot;</span>,</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-window-onload"><a href="#3-window-onload" class="headerlink" title="(3) window.onload"></a><strong>(3) <code>window.onload</code></strong></h3><p>在JavaScript中， <code>window.onload</code> 方法只能被定义一次。后定义的方法将覆盖先定义的方法。为了解决这个问题需要使用 <code>window.addEventListener("load", Function)</code> 。引入jQuery后，你只需要一段简短的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码便能实现 <code>window.addEventListener("load", Function)</code> 的功能。你只需要在注释处写上你的代码即可。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>二者的区别</strong></div>

<div style="color:royalblue;">jQuery的这种方法会让函数在DOM加载完后、图片加载完之前被调用，而 <code>addEventListener()</code> 则会让函数在所有资源加载完以后再被调用。</div>
</div>

<h3 id="4-解决-冲突"><a href="#4-解决-冲突" class="headerlink" title="(4) 解决 $ 冲突"></a><strong>(4) 解决 <code>$</code> 冲突</strong></h3><p>有时候你需要引入的JavaScript脚本不止一个。而后引入的JavaScript中如果将 <code>$</code> 符号用作变量名、函数名或者其他用途，则会造成冲突。为了解决这种冲突，jQuery提供了以其他符号替代 <code>$</code> 的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必须在其它所有的代码之前声明</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">RES</span>=jQuery.<span class="title function_">noConflict</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">RES</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="title function_">RES</span>(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="title function_">RES</span>(i).<span class="title function_">css</span>(&#123;</span><br><span class="line">        <span class="string">&quot;background-color&quot;</span>: <span class="string">&quot;gray&quot;</span>,</span><br><span class="line">        <span class="comment">//其余的“CSS”代码</span></span><br><span class="line">        <span class="comment">//······</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//其余的代码</span></span><br><span class="line">    <span class="comment">//······</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="三、核心函数"><a href="#三、核心函数" class="headerlink" title="三、核心函数"></a><strong>三、核心函数</strong></h2><p>看完上述的代码，有JavaScript基础的同学应该已经明白了。jQuery库中定义了一个函数 <code>$()</code> ，它就是jQuery的核心函数。由于JavaScript并不限制变量的类型，因此什么鬼都能往这个函数里传。但只有如下类型的参数会有效：</p>
<ul>
<li>函数。jQuery库将会把函数添加到DOM加载完后执行的队列中。</li>
<li>字符串。<ol>
<li>字符串为选择器。jQuery库将会解析这个选择器，并返回标签对象数组。</li>
<li>字符串为HTML代码。jQuery库将会解析HTML代码，并返回这个标签对象。你可以通过这种方式来动态地向网页中插入标签。</li>
</ol>
</li>
<li>DOM标签对象。jQuery库会将这个对象封装为数组并返回。</li>
</ul>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>jQuery对象</strong></div>

<div style="color:royalblue;">其实说返回数组是不太准确的，准确地说是返回一个jQuery对象。只不过这个对象有数字的索引，是个伪数组。</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="title function_">RES</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br></pre></td></tr></table></figure>

<div style="color:royalblue;">可以在浏览器的控制台中看到：</div>

<p><img src="/2022/02/12/jQueryGrammar/1.png" alt="1 1" title="1"></p>
<div style="color:royalblue;">这里选中了8个 <code>div</code> 标签对象，并且可以通过数字索引来获取其中的对象。</div>
</div>

<p>jQuery的核心函数 <code>$()</code> 还定义了一些其他的方法。这些方法都必须通过 <code>$</code> 对象来调用。</p>
<div class="tabs" id="corefunction"><ul class="nav-tabs"><li class="tab active"><a href="#corefunction-1"><code>map()</code></a></li><li class="tab"><a href="#corefunction-2"><code>trim()</code></a></li><li class="tab"><a href="#corefunction-3"><code>isWindow()</code></a></li><li class="tab"><a href="#corefunction-4"><code>isArray()</code></a></li><li class="tab"><a href="#corefunction-5"><code>isFunction()</code></a></li><li class="tab"><a href="#corefunction-6"><code>holdReady()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="corefunction-1"><p>与 <code>each()</code> 方法相似，但它的返回值与函数参数略有不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = &#123; <span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">114514</span>, <span class="number">4</span>: <span class="number">1919810</span>, <span class="attr">length</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> j = $.<span class="title function_">map</span>(i, <span class="keyword">function</span> (<span class="params">Index, Value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Index</span>, <span class="title class_">Value</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Index</span> + <span class="string">&quot;&quot;</span> + <span class="title class_">Value</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/02/12/jQueryGrammar/3.png" alt="3 3" title="3"></p></div><div class="tab-pane" id="corefunction-2"><p>jQuery提供的 <code>trim()</code> 方法可以删除字符串中两端的空格，并返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="string">&quot;  114  514   1919   810  &quot;</span>;</span><br><span class="line"><span class="keyword">var</span> j = $.<span class="title function_">trim</span>(i);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i =&quot;</span>, i);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;j =&quot;</span>, j);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="/2022/02/12/jQueryGrammar/4.png" alt="4 4" title="4"></p></div><div class="tab-pane" id="corefunction-3"><p><code>isWindow()</code> 方法用于判断传入的参数是否为 <code>window</code> 对象，若是则返回 <code>true</code> ，否则返回 <code>false</code> 。</p></div><div class="tab-pane" id="corefunction-4"><p><code>isArray()</code> 方法用于判断传入的参数是否为 <code>Array</code> 对象，即真数组，若是则返回 <code>true</code> ，否则返回 <code>false</code> 。</p></div><div class="tab-pane" id="corefunction-5"><p><code>isFunction()</code> 方法用于判断传入的参数是否为函数，若是则返回 <code>true</code> ，否则返回 <code>false</code> 。</p></div><div class="tab-pane" id="corefunction-6"><p><code>holdReady()</code> 方法用于控制 <code>$(document).ready()</code> 里的代码运行。传入 <code>true</code> 后，其中的代码将被挂起，直到某处运行 <code>$.holdReady(false)</code> 。</p></div></div></div>

<h2 id="四、常用方法"><a href="#四、常用方法" class="headerlink" title="四、常用方法"></a><strong>四、常用方法</strong></h2><p>jQuery的设计理念就是更少的代码做更多的事，因此它将一些JavaScript的操作复杂的方法给封装成了简单易用的方法，这些方法定义在jQuery对象下，因此必须使用jQuery对象来调用。</p>
<div class="tabs" id="usefulfunction"><ul class="nav-tabs"><li class="tab active"><a href="#usefulfunction-1"><code>attr()</code></a></li><li class="tab"><a href="#usefulfunction-2"><code>removeAttr()</code></a></li><li class="tab"><a href="#usefulfunction-3"><code>eq()</code></a></li><li class="tab"><a href="#usefulfunction-4"><code>prop()</code></a></li><li class="tab"><a href="#usefulfunction-5"><code>removeProp()</code></a></li><li class="tab"><a href="#usefulfunction-6"><code>addClass()</code></a></li><li class="tab"><a href="#usefulfunction-7"><code>removeClass()</code></a></li><li class="tab"><a href="#usefulfunction-8"><code>toggleClass()</code></a></li><li class="tab"><a href="#usefulfunction-9"><code>html()</code></a></li><li class="tab"><a href="#usefulfunction-10"><code>text()</code></a></li><li class="tab"><a href="#usefulfunction-11"><code>val()</code></a></li><li class="tab"><a href="#usefulfunction-12"><code>css()</code></a></li><li class="tab"><a href="#usefulfunction-13"><code>siblings()</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="usefulfunction-1"><p><code>attr()</code> 方法是JavaScript中 <code>getAttribute()</code> 方法、 <code>setAttribute()</code> 方法的封装。它用于获取或修改jQuery对象中的标签对象的属性结点。</p>
<p>当只传入一个参数时，jQuery库会将其解析为标签对象的属性结点名，并返回其值。<span style="color:red;">若jQuery对象中有多个标签对象，则只会返回第一个标签对象的属性结点值。若该属性结点未定义则返回 <code>undefined</code> 。</span></p>
<p>当传入两个参数时，第一个参数被解析为属性结点名，第二个参数被解析为要修改成什么值， <span style="color:red;">并且会修改所有jQuery对象中的标签对象。</span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>($(<span class="string">&quot;div&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;class&quot;</span>));</span><br><span class="line"><span class="comment">//打印第一个div标签的class属性值</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;Proletarian&quot;</span>);</span><br><span class="line"><span class="comment">//将所有div标签的class属性值修改为Proletarian</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="usefulfunction-2"><p>与 <code>attr()</code> 方法相反，它的作用是删除jQuery对象中所有标签对象的指定属性结点。可以使用 <code> </code> （空格）分隔你要删除的属性结点名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">removeAttr</span>(<span class="string">&quot;class id&quot;</span>);</span><br><span class="line"><span class="comment">//删除所有div标签的class和id属性</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="usefulfunction-3"><p>该方法用于获取jQuery对象中的第i个标签对象，并把这个标签对象封装为jQuery对象再返回。 <code>eq()</code> 方法的参数只有一个，该参数是从0开始的索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;div&quot;</span>).<span class="title function_">eq</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> j = $($(<span class="string">&quot;div&quot;</span>)[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="usefulfunction-4"><p>要理解 <code>prop()</code> 方法，必须先理属性和属性结点。在JavaScript中，对象（变量）的成员变量叫做属性，而HTML的标签的属性，则被叫做属性结点。也就是说，JavaScript获取的HTML标签对象不仅有属性结点，还有额外的属性。 <code>prop()</code> 方法能修改或新增对象属性，也能修改或新增HTML标签对象的属性结点。</p>
<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>二者的区别</strong></div>

<div style="color:royalblue;"><code>prop()</code> 方法的适用范围更广。在获取属性时建议使用 <code>prop()</code> 方法，在返回诸如 <code>checked</code> 等属性结点值时， <code>prop()</code> 方法会返回 <code>true</code> 或者 <code>false</code> ，而<code>attr()</code> 方法会返回 <code>checked</code> 或者 <code>undefined</code> 。</div>
</div></div><div class="tab-pane" id="usefulfunction-5"><p>与 <code>prop()</code> 方法相反，它的作用是删除jQuery对象中所有标签对象的指定属性。可以使用 <code> </code> （空格）分隔你要删除的属性。</p></div><div class="tab-pane" id="usefulfunction-6"><p><code>addClass()</code> 方法用于添加标签对象的类名。 <code>prop()</code> 方法与 <code>attr()</code> 方法都只能修改或新增类名而不能实现添加，因此如果要添加类名只能使用 <code>addClass()</code> 方法。</p>
<p>用 <code> </code> （空格）分隔你想要添加的多个类名。</p></div><div class="tab-pane" id="usefulfunction-7"><p>与 <code>addClass()</code> 方法相反， <code>removeClass()</code> 方法用于删除标签对象的类名。</p>
<p>用 <code> </code> （空格）分隔你想要删除的多个类名。</p></div><div class="tab-pane" id="usefulfunction-8"><p>当标签对象存在 <code>toggleClass()</code> 的参数中的类名时，则删除类名；不存在时则添加类名。</p></div><div class="tab-pane" id="usefulfunction-9"><p><code>html()</code> 方法用于获取或修改标签对象中的文本，相当于获取或修改标签对象的  <code>innerHTML</code> 属性。它可以新增子标签。当不写参数时则返回 <code>innerHTML</code> 属性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">i.<span class="title function_">html</span>(<span class="string">&quot;&lt;p&gt;114514&lt;/p&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码作用为向 <code>&lt;div&gt;</code> 标签中插入 <code>&lt;p&gt;</code> 标签，并且 <code>&lt;p&gt;</code> 标签内的文本为114514。</p></div><div class="tab-pane" id="usefulfunction-10"><p><code>html()</code> 方法用于获取或修改标签对象中的文本，相当于获取或修改标签对象的  <code>innerText</code> 属性。它不能新增子标签，只能修改内部文本。当不写参数时则返回 <code>innerText</code> 属性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">i.<span class="title function_">html</span>(<span class="string">&quot;&lt;p&gt;114514&lt;/p&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码作用为将 <code>&lt;div&gt;</code> 标签中的文本修改为&lt;p&gt;114514&lt;/p&gt;，不会新增 <code>&lt;p&gt;</code> 标签。</p></div><div class="tab-pane" id="usefulfunction-11"><p><code>val()</code> 方法用于获取或修改标签对象的 <code>value</code> 属性。不写参数时将会返回 <code>value</code> 属性值，否则将会把 <code>value</code> 属性值修改为参数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">i.<span class="title function_">val</span>(<span class="string">&quot;&lt;p&gt;114514&lt;/p&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>input</code> 标签（即输入框）中的文本设置为&lt;p&gt;114514&lt;&#x2F;p&gt;。</p></div><div class="tab-pane" id="usefulfunction-12"><p>上文已经粗略地提到了 <code>css()</code> 方法的用法。它还能获取jQuery对象中的第一个标签对象的CSS属性值，只需要传入属性名即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;div&quot;</span>).<span class="title function_">eq</span>(<span class="number">5</span>).<span class="title function_">css</span>(<span class="string">&quot;width&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码用于获取第6个 <code>&lt;div&gt;</code> 标签的width属性值。</p></div><div class="tab-pane" id="usefulfunction-13"><p>当不传入参数时， <code>siblings()</code> 方法将会返回当前jQuery对象中标签对象的所有兄弟标签；如果要传入参数，参数的格式应该与CSS的选择器一致，此时将返回符合选择器条件的兄弟元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = $(<span class="string">&quot;li.selected&quot;</span>).<span class="title function_">siblings</span>(<span class="string">&quot;.active&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码选中了含有selected类名的 <code>&lt;li&gt;</code> 标签的含有active类名的兄弟标签。</p></div></div></div>

<p>关于更多jQuery的API，详情请参见 <a class="btn" href="https://jquery.cuishifeng.cn/ ">jQuery API 中文文档</a> 。</p>
<h2 id="五、事件"><a href="#五、事件" class="headerlink" title="五、事件"></a><strong>五、事件</strong></h2><h3 id="1-添加事件"><a href="#1-添加事件" class="headerlink" title="(1) 添加事件"></a><strong>(1) 添加事件</strong></h3><p>当然，jQuery也简化了 <code>addEventListener()</code> 方法。可以直接使用jQuery对象下的 <code>on()</code> 方法来绑定事件，用法与 <code>addEventListener()</code> 方法一致，并且也可以写多个事件，事件之间不会相互覆盖。</p>
<p>但还有更简洁的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#test&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>jQuery为每一个事件都做了相应的方法。上述的代码作用为向id为test的标签添加一个点击事件，点击标签时将弹出信息“Hello, world!”。类似的方法还有 <code>mouseenter()</code> 、 <code>mouseover()</code> 、 <code>mouseleave()</code> 等，此处不再赘述。</p>
<h3 id="2-删除事件"><a href="#2-删除事件" class="headerlink" title="(2) 删除事件"></a><strong>(2) 删除事件</strong></h3><p>要解除绑定，可以使用 <code>off()</code> 方法。它有三种模式：</p>
<ul>
<li>不传入参数。那么将会清除绑定的全部事件。</li>
<li>传入一个参数。将参数解析为事件类型，清楚该类型绑定的全部事件。</li>
<li>传入两个参数。将第一个参数解析为事件类型，第二个参数解析为绑定的函数名，清除该事件类型下绑定的该函数。</li>
</ul>
<h3 id="3-事件冒泡"><a href="#3-事件冒泡" class="headerlink" title="(3) 事件冒泡"></a><strong>(3) 事件冒泡</strong></h3><p>当你为子标签和父标签都绑定了事件时，尤其是点击这种事件，在你点击子标签后，父子标签的事件往往都会被触发，这种情况一般被称为事件冒泡。为了阻止事件冒泡，可以在编写子标签的函数时以如下方式书写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">i</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">j</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info"><div style="color:royalblue;font-size:1.5em;"><strong>默认事件</strong></div>

<div style="color:royalblue;">上述的代码中，第一种方式不仅会打断事件冒泡，还会打断默认事件。默认事件即标签默认会触发的事件，例如 <code>&lt;a&gt;</code> 标签点击后默认会跳转到链接地址，使用第一种方法添加点击事件以后将打断跳转，而第二种方法则不会。如果只想打断默认事件，可以使用如下方式：</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">j</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();   <span class="comment">//仅打断默认事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

<h3 id="4-自动触发"><a href="#4-自动触发" class="headerlink" title="(4) 自动触发"></a><strong>(4) 自动触发</strong></h3><p>如果要自动触发某事件，可以使用 <code>trigger()</code>方法 或者 <code>triggerHandler()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">triggerHandler</span>(<span class="string">&quot;click&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码在执行时均会立即触发所有 <code>&lt;div&gt;</code> 标签的点击事件。但区别在于， <code>trigger()</code> 方法会触发事件冒泡与默认事件，而 <code>triggerHandler()</code> 方法不会触发事件冒泡和默认事件。</p>
<div class="note warning"><div style="color:goldenrod;font-size:1.5em;"><strong>特殊的 <code>&lt;a&gt;</code> 标签</strong></div>

<div style="color:goldenrod;">使用 <code>trigger()</code> 方法触发 <code>&lt;a&gt;</code> 标签的点击事件时，不会触发点击超链接跳转的默认事件。这是特殊情况。如果你需要触发跳转的默认事件，请在 <code>&lt;a&gt;</code> 标签内添加子标签，使用 <code>trigger()</code> 方法触发子标签的点击事件。</div>
</div>

<p>使用 <code>trigger()</code>方法 和 <code>on()</code> 方法进行搭配，就可以实现自定义事件。</p>
<h3 id="5-命名空间"><a href="#5-命名空间" class="headerlink" title="(5) 命名空间"></a><strong>(5) 命名空间</strong></h3><p>如果想让某一类型的某一个事件能够被单独地使用 <code>trigger()</code> 方法触发，可以使用事件的命名空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#test&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click.RES&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;RES&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#test&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click.Lacia&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Lacia&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&quot;#test&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click.RES&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码给id为test的标签绑定了两个点击事件。点击时， <code>click.RES</code> 事件与 <code>click.Lacia</code> 事件均会出发。但当DOM加载完毕时， <code>$("#test").trigger("click.RES");</code> 只会触发 <code>click.RES</code> 事件。</p>
<h3 id="6-事件委托"><a href="#6-事件委托" class="headerlink" title="(6) 事件委托"></a><strong>(6) 事件委托</strong></h3><p>利用事件冒泡的特性，可以将子标签的事件委托给父标签监听。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#test&quot;</span>).<span class="title function_">delegate</span>(<span class="string">&quot;button&quot;</span>, <span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码将 <code>&lt;button&gt;</code> 子标签的点击事件委托给id为test的父标签监听。当点击按钮时，控制台中返回的标签将会是 <code>&lt;button&gt;</code> 标签。利用委托，就可以把动态生成的子标签的所有事件全部交给父标签监听，而不必在新增时挨个重新设置子标签的事件。</p>
<h2 id="六、动画"><a href="#六、动画" class="headerlink" title="六、动画"></a><strong>六、动画</strong></h2><p>由于CSS3已经追加了强大的动画功能，因此使用JavaScript写动画已经不再是最佳选择。但仍有一些动画无可避免地必须使用JavaScript编写。</p>
<p>jQuery将动画封装成了 <code>animate()</code> 方法。该方法有4个参数：</p>
<ol>
<li>第1个参数与CSS或者 <code>css()</code> 方法的写法一致。在这个参数内改变的属性将自带动画效果；</li>
<li>第2个参数控制动画的时长，需传入 <code>number</code> 型变量，单位是ms。</li>
<li>第3个参数为动画的执行模式。有 <code>"linear"</code> 、 <code>"swing"</code> 选项。前者为匀速，后者相当于CSS的 <code>ease-in-out</code> 。</li>
<li>第4个参数为动画结束后执行的函数。</li>
</ol>
<p>写在同一个 <code>animate()</code> 方法里的动画会同时执行，而写在不同的 <code>animate()</code> 方法内的动画则会按照调用的先后顺序依次执行，并且 <code>animate()</code> 方法可以链式调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;width&quot;</span>: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">&#125;, <span class="number">500</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">    <span class="string">&quot;width&quot;</span>: <span class="string">&quot;500px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: <span class="string">&quot;500px&quot;</span>,</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码在将 <code>&lt;div&gt;</code> 标签的大小变为100×100像素之后，紧接着会将其大小扩大到500×500。两次动画时长均为0.5s，并且动画之间没有间隔。要想推迟第二个动画的执行，可以使用 <code>delay()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;width&quot;</span>: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">&#125;, <span class="number">500</span>).<span class="title function_">delay</span>(<span class="number">1000</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">    <span class="string">&quot;width&quot;</span>: <span class="string">&quot;500px&quot;</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>: <span class="string">&quot;500px&quot;</span>,</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p><code>delay()</code> 方法的参数为延时时间，单位为ms。上述代码的第二个动画将会在第一个动画结束以后推迟1s执行。</p>
<p>要想停止动画，可以使用 <code>stop()</code> 方法。该方法接受两个 <code>bool</code> 参数：</p>
<ol>
<li>第1个参数控制是否清空当前动画队列；</li>
<li>第2个参数控制打断动画后，是否变为该动画的完成状态。</li>
</ol>
<p>当不传入参数时默认为 <code>false，false</code> ，即打断当前动画但不影响后续动画的执行。</p>
]]></content>
      <categories>
        <category>计算机科学</category>
        <category>编程语言</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>计算机科学</tag>
        <tag>JavaScript库</tag>
      </tags>
  </entry>
</search>
